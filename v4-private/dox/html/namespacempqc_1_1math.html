<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC-Docs: mpqc::math Namespace Reference</title>
<!--BEGIN PROJECT_ICON-->
<link rel="icon" href="$projecticon" type="image/x-icon" />
<!--END PROJECT_ICON-->
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--BEGIN COPY_CLIPBOARD-->
<script type="text/javascript" src="clipboard.js"></script>
<!--END COPY_CLIPBOARD-->
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init();
        DoxygenAwesomeParagraphLink.init();
    </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"$logosize/></td>
  <td id="projectalign">
   <div id="projectname">MPQC-Docs<span id="projectnumber">&#160;4.0.0-beta.1</span>
   </div>
   <div id="projectbrief">Massively Parallel Electronic Structure platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempqc.html">mpqc</a></li><li class="navelem"><a class="el" href="namespacempqc_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">mpqc::math Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacempqc_1_1math_1_1binary__operators" id="r_namespacempqc_1_1math_1_1binary__operators"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math_1_1binary__operators.html">binary_operators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacempqc_1_1math_1_1clustering" id="r_namespacempqc_1_1math_1_1clustering"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math_1_1clustering.html">clustering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacempqc_1_1math_1_1detail" id="r_namespacempqc_1_1math_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacempqc_1_1math_1_1groups" id="r_namespacempqc_1_1math_1_1groups"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math_1_1groups.html">groups</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacempqc_1_1math_1_1mra" id="r_namespacempqc_1_1math_1_1mra"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math_1_1mra.html">mra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1math_1_1_canonical_column_phase_control.html">CanonicalColumnPhaseControl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1math_1_1compress.html">compress</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_c_p3.html">CP3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes 3-way CP decomposition of a order-3 tensor.  <a href="classmpqc_1_1math_1_1_c_p3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_davidson_eigensolver.html">DavidsonEigensolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Davidson Eigensolver.  <a href="classmpqc_1_1math_1_1_davidson_eigensolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_davidson_eigensolver_factory.html">DavidsonEigensolverFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory class for <a class="el" href="classmpqc_1_1math_1_1_davidson_eigensolver.html" title="Davidson Eigensolver.">DavidsonEigensolver</a>.  <a href="classmpqc_1_1math_1_1_davidson_eigensolver_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_davidson_eigensolver_preconditioner.html">DavidsonEigensolverPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioner for <a class="el" href="classmpqc_1_1math_1_1_davidson_eigensolver.html" title="Davidson Eigensolver.">DavidsonEigensolver</a>.  <a href="classmpqc_1_1math_1_1_davidson_eigensolver_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_decomp_to_ta_tensor.html">DecompToTaTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_d_i_i_s.html">DIIS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for creating <a class="el" href="classmpqc_1_1math_1_1_d_i_i_s.html" title="Factory for creating DIIS objects.">DIIS</a> objects.  <a href="classmpqc_1_1math_1_1_d_i_i_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_finite_difference_derivative.html">FiniteDifferenceDerivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmpqc_1_1math_1_1_function.html" title="Function maps Parameters to a Value.">Function</a> maps Parameters to a Value.  <a href="classmpqc_1_1math_1_1_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_function_visitor_base.html">FunctionVisitorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_group.html">Group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmpqc_1_1math_1_1_group.html" title="Group is an abstract discrete group.">Group</a> is an abstract discrete group.  <a href="classmpqc_1_1math_1_1_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements Kahan summation for real and complex floating-point types  <a href="structmpqc_1_1math_1_1_kahan_accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>KahanAccumulator&lt; Complex, std::enable_if_t&lt;!std::is_floating_point_v&lt; Complex &gt; &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>KahanAccumulator&lt; Real, std::enable_if_t&lt; std::is_floating_point_v&lt; Real &gt; &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1math_1_1_k_means_clustering.html">KMeansClustering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1math_1_1mat__to__tile_3_01_t_a_1_1_tile_3_01_decomposed_tensor_3_01_t_01_4_01_4_01_4.html">mat_to_tile&lt; TA::Tile&lt; DecomposedTensor&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>mat_to_tile&lt; Tile, std::enable_if_t&lt; TA::detail::is_contiguous_tensor_v&lt; Tile &gt; &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1math_1_1mat__to__tile__base.html">mat_to_tile_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1math_1_1_nonnegative_spectral_range.html">NonnegativeSpectralRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reports a spectral range of a nonnegative matrix after reconditioning Computing spectral range of a non-negative matrix can produce inaccurate eigenvalues (even negative) and eigenvectors near zero. gensqrtinv and conditioned_orthogonalizer compute approximate generalized X=S^{-1/2} and (optionally) Xinv=MS{1/2} of matrix S, such that adjoint(X).S.X is approximately 1 and Sʹ = adjoint(Xinv).Xinv is a reconditioned S. This reports the spectral range of S and Sʹ.  <a href="structmpqc_1_1math_1_1_nonnegative_spectral_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_optimizer.html">Optimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is itself a <a class="el" href="classmpqc_1_1math_1_1_function.html" title="Function maps Parameters to a Value.">Function</a>, namely <a class="el" href="classmpqc_1_1math_1_1_function.html">Function&lt;Params, std::tuple&lt;&gt;&gt;</a>.  <a href="classmpqc_1_1math_1_1_optimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1pair__accumulator.html">pair_accumulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1pair__smasher.html">pair_smasher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_petite_list.html">PetiteList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for symmetric tensor algebra.  <a href="classmpqc_1_1math_1_1_petite_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_quasi_newton_optimizer.html">QuasiNewtonOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is itself a <a class="el" href="classmpqc_1_1math_1_1_function.html" title="Function maps Parameters to a Value.">Function</a>, namely Function&lt;Params, OptimizerParams&gt;.  <a href="classmpqc_1_1math_1_1_quasi_newton_optimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_real_solid_harmonic.html">RealSolidHarmonic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_real_spherical_harmonic.html">RealSphericalHarmonic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_single_state_davidson_eigensolver.html">SingleStateDavidsonEigensolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_spherical_harmonic.html">SphericalHarmonic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_spinor_spherical_harmonic.html">SpinorSphericalHarmonic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_symm_petite_list.html">SymmPetiteList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_ta_to_decomp_tensor.html">TaToDecompTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_taylor_expansion_coefficients.html">TaylorExpansionCoefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-th order Taylor expansion of a function of <code>K</code> variables.  <a href="classmpqc_1_1math_1_1_taylor_expansion_coefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1math_1_1_taylor_expansion_function.html">TaylorExpansionFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a35d88d37ba6045aba75686f2da8c7f25" id="r_a35d88d37ba6045aba75686f2da8c7f25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a35d88d37ba6045aba75686f2da8c7f25">mpfloat</a> = long double</td></tr>
<tr class="separator:a35d88d37ba6045aba75686f2da8c7f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb508667c4e7e2b919b52d35adf107b" id="r_acfb508667c4e7e2b919b52d35adf107b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">OrthogOutput</a> Output, typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:acfb508667c4e7e2b919b52d35adf107b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#acfb508667c4e7e2b919b52d35adf107b">ConditionalOrthogOutput</a> = std::conditional_t&lt; Output==<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15a02129bb861061d1a052c592e2dc6b383">OrthogOutput::X</a>, std::tuple&lt; TA::DistArray&lt; Tile, Policy &gt;, <a class="el" href="structmpqc_1_1math_1_1_nonnegative_spectral_range.html">NonnegativeSpectralRange</a>&lt; TA::detail::scalar_t&lt; Tile &gt; &gt; &gt;, std::tuple&lt; TA::DistArray&lt; Tile, Policy &gt;, TA::DistArray&lt; Tile, Policy &gt;, <a class="el" href="structmpqc_1_1math_1_1_nonnegative_spectral_range.html">NonnegativeSpectralRange</a>&lt; TA::detail::scalar_t&lt; Tile &gt; &gt; &gt; &gt;</td></tr>
<tr class="separator:acfb508667c4e7e2b919b52d35adf107b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82709d31afb8b917c53f177c664c73f" id="r_aa82709d31afb8b917c53f177c664c73f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa82709d31afb8b917c53f177c664c73f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a> = Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:aa82709d31afb8b917c53f177c664c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4edc461603cdd44dbd70281e40567739" id="r_a4edc461603cdd44dbd70281e40567739"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739">ClusteringMethod</a> { <br />
&#160;&#160;<a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739a6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739a7bdf23368e94f382913959359221a144">KMeans_Forgy</a>
, <a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739a4648d0430728e7ab3bbbea6618acd399">KMeans_PlusPlus</a>
, <a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739a34ee121804c9b1396e6ad445f510d901">KMeans_CentroidThenMaxDist</a>
, <br />
&#160;&#160;<a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739a7a1920d61156abc05a60135aefe8bc67">Default</a> = KMeans_CentroidThenMaxDist
<br />
 }</td></tr>
<tr class="memdesc:a4edc461603cdd44dbd70281e40567739"><td class="mdescLeft">&#160;</td><td class="mdescRight">known methods for clustering  <a href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739">More...</a><br /></td></tr>
<tr class="separator:a4edc461603cdd44dbd70281e40567739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae50adb8d3490b303e6d1fc7846ff15" id="r_aaae50adb8d3490b303e6d1fc7846ff15"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">OrthogOutput</a> { <a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15a02129bb861061d1a052c592e2dc6b383">X</a>
, <a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15a86f780010dd9309712d1dd4d9886647d">XAndXInverse</a>
 }</td></tr>
<tr class="memdesc:aaae50adb8d3490b303e6d1fc7846ff15"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls whether gensqrtinv produces X or X and its "inverse"  <a href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">More...</a><br /></td></tr>
<tr class="separator:aaae50adb8d3490b303e6d1fc7846ff15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab889c32f48707ecbe045597b6bb7a88e" id="r_ab889c32f48707ecbe045597b6bb7a88e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> { <br />
&#160;&#160;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88ead12fbc9a2ba3b0b91a4190959b4c966b">Align</a>
, <a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88ea4aa0f8a9fd5a5c0f77d1aabb6c58b0a2">L4</a>
, <a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88ea15fc3950b7c08c0b533f05a119795393">Entropy</a>
, <a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88eaefcbcff9c8282fe81b2aa6f54da99d16">Align_L4</a>
, <br />
&#160;&#160;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88eae424533468d113dd6670dcb29d43f78a">Align_Entropy</a>
, <a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88ea7a1920d61156abc05a60135aefe8bc67">Default</a>
<br />
 }</td></tr>
<tr class="memdesc:ab889c32f48707ecbe045597b6bb7a88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">methods for canonicalizing the columns of a matrix  <a href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">More...</a><br /></td></tr>
<tr class="separator:ab889c32f48707ecbe045597b6bb7a88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343a5ca944dd4ae30b58373883cdfa85" id="r_a343a5ca944dd4ae30b58373883cdfa85"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a343a5ca944dd4ae30b58373883cdfa85">CoulombGauge</a> { <a class="el" href="namespacempqc_1_1math.html#a343a5ca944dd4ae30b58373883cdfa85a7a1920d61156abc05a60135aefe8bc67">Default</a>
, <a class="el" href="namespacempqc_1_1math.html#a343a5ca944dd4ae30b58373883cdfa85a4ca32cf75df1f52742531e3a08c470e4">Ewald</a>
, <a class="el" href="namespacempqc_1_1math.html#a343a5ca944dd4ae30b58373883cdfa85adc2e5a54767663833b5f96a475b27cf4">EwaldMakovPayne</a>
, <a class="el" href="namespacempqc_1_1math.html#a343a5ca944dd4ae30b58373883cdfa85afedb2d84cafe20862cb4399751a8a7e3">invalid</a>
 }</td></tr>
<tr class="memdesc:a343a5ca944dd4ae30b58373883cdfa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">types of Coulomb potential gauge  <a href="namespacempqc_1_1math.html#a343a5ca944dd4ae30b58373883cdfa85">More...</a><br /></td></tr>
<tr class="separator:a343a5ca944dd4ae30b58373883cdfa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5716b7e21b52c0e42fbb4ecc252a3fea" id="r_a5716b7e21b52c0e42fbb4ecc252a3fea"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5716b7e21b52c0e42fbb4ecc252a3fea">make_clustering_method_type2string</a> ()</td></tr>
<tr class="separator:a5716b7e21b52c0e42fbb4ecc252a3fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a79a4f34ce13e36d2f3262e8cb9fdc0" id="r_a9a79a4f34ce13e36d2f3262e8cb9fdc0"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a9a79a4f34ce13e36d2f3262e8cb9fdc0">make_clustering_method_string2type</a> ()</td></tr>
<tr class="separator:a9a79a4f34ce13e36d2f3262e8cb9fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad141437494c402b64a9965cc624b81d9" id="r_ad141437494c402b64a9965cc624b81d9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad141437494c402b64a9965cc624b81d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::complex&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad141437494c402b64a9965cc624b81d9">Z</a> (T1 re, T2 im)</td></tr>
<tr class="separator:ad141437494c402b64a9965cc624b81d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688ed666bc219d14ea6bf773f71a481" id="r_a5688ed666bc219d14ea6bf773f71a481"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a5688ed666bc219d14ea6bf773f71a481"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5688ed666bc219d14ea6bf773f71a481">as_real</a> (const T &amp;v)</td></tr>
<tr class="separator:a5688ed666bc219d14ea6bf773f71a481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6042e840c46df9a5ebff21fc30c3702f" id="r_a6042e840c46df9a5ebff21fc30c3702f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = double&gt; </td></tr>
<tr class="memitem:a6042e840c46df9a5ebff21fc30c3702f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6042e840c46df9a5ebff21fc30c3702f">as_real</a> (const std::complex&lt; T &gt; &amp;z, U imag_threshold=1e-6)</td></tr>
<tr class="separator:a6042e840c46df9a5ebff21fc30c3702f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df3dbfd3647f094d52af54757831678" id="r_a9df3dbfd3647f094d52af54757831678"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9df3dbfd3647f094d52af54757831678"><td class="memTemplItemLeft" align="right" valign="top">constexpr const std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a9df3dbfd3647f094d52af54757831678">as_real</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a9df3dbfd3647f094d52af54757831678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d63102d2134bd65b142b24584e66944" id="r_a3d63102d2134bd65b142b24584e66944"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = double&gt; </td></tr>
<tr class="memitem:a3d63102d2134bd65b142b24584e66944"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3d63102d2134bd65b142b24584e66944">as_real</a> (const std::vector&lt; std::complex&lt; T &gt; &gt; &amp;vec, U imag_threshold=1e-6)</td></tr>
<tr class="separator:a3d63102d2134bd65b142b24584e66944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e610035b2b0eca64175fa064ca053d" id="r_a94e610035b2b0eca64175fa064ca053d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename  = std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a94e610035b2b0eca64175fa064ca053d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const boost::container::small_vector&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a94e610035b2b0eca64175fa064ca053d">as_real</a> (const boost::container::small_vector&lt; T, N &gt; &amp;vec)</td></tr>
<tr class="separator:a94e610035b2b0eca64175fa064ca053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7613e2c8947d8b92aca648551d3a081" id="r_ad7613e2c8947d8b92aca648551d3a081"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename U  = double&gt; </td></tr>
<tr class="memitem:ad7613e2c8947d8b92aca648551d3a081"><td class="memTemplItemLeft" align="right" valign="top">constexpr boost::container::small_vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad7613e2c8947d8b92aca648551d3a081">as_real</a> (const boost::container::small_vector&lt; std::complex&lt; T &gt;, N &gt; &amp;vec, U imag_threshold=1e-6)</td></tr>
<tr class="separator:ad7613e2c8947d8b92aca648551d3a081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49254eaf15ecc4877f273f7346398ea" id="r_ad49254eaf15ecc4877f273f7346398ea"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols, int Options, int MaxRows, int MaxCols, typename  = std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ad49254eaf15ecc4877f273f7346398ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr Eigen::Matrix&lt; T, Rows, Cols, Options, MaxRows, MaxCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad49254eaf15ecc4877f273f7346398ea">as_real</a> (const Eigen::Matrix&lt; T, Rows, Cols, Options, MaxRows, MaxCols &gt; &amp;mat)</td></tr>
<tr class="separator:ad49254eaf15ecc4877f273f7346398ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6910b0bd23347a1374688634e7f3c9e" id="r_af6910b0bd23347a1374688634e7f3c9e"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols, int Options, int MaxRows, int MaxCols, typename U  = double&gt; </td></tr>
<tr class="memitem:af6910b0bd23347a1374688634e7f3c9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr Eigen::Matrix&lt; T, Rows, Cols, Options, MaxRows, MaxCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af6910b0bd23347a1374688634e7f3c9e">as_real</a> (const Eigen::Matrix&lt; std::complex&lt; T &gt;, Rows, Cols, Options, MaxRows, MaxCols &gt; &amp;mat, U imag_threshold=1e-6)</td></tr>
<tr class="separator:af6910b0bd23347a1374688634e7f3c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aee62e3221832775773127bf5462aa" id="r_aa1aee62e3221832775773127bf5462aa"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename Source &gt; </td></tr>
<tr class="memitem:aa1aee62e3221832775773127bf5462aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa1aee62e3221832775773127bf5462aa">numeric_cast</a> (Source &amp;&amp;src)</td></tr>
<tr class="separator:aa1aee62e3221832775773127bf5462aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7a62d038c06d4dd4b9c918944dd11" id="r_a61e7a62d038c06d4dd4b9c918944dd11"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:a61e7a62d038c06d4dd4b9c918944dd11"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a61e7a62d038c06d4dd4b9c918944dd11">conj</a> (Numeric ω)</td></tr>
<tr class="separator:a61e7a62d038c06d4dd4b9c918944dd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e429e41dd3e7239fbf526a6665b75fe" id="r_a8e429e41dd3e7239fbf526a6665b75fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e429e41dd3e7239fbf526a6665b75fe"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8e429e41dd3e7239fbf526a6665b75fe">zero</a> ()</td></tr>
<tr class="separator:a8e429e41dd3e7239fbf526a6665b75fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e1a241df7b750a2b1bc31f37566fd3" id="r_a51e1a241df7b750a2b1bc31f37566fd3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a51e1a241df7b750a2b1bc31f37566fd3"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a51e1a241df7b750a2b1bc31f37566fd3">zero&lt; float &gt;</a> ()</td></tr>
<tr class="separator:a51e1a241df7b750a2b1bc31f37566fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a6dab682dd58a2f68cf0a88bebba1f" id="r_ad1a6dab682dd58a2f68cf0a88bebba1f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad1a6dab682dd58a2f68cf0a88bebba1f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad1a6dab682dd58a2f68cf0a88bebba1f">zero&lt; double &gt;</a> ()</td></tr>
<tr class="separator:ad1a6dab682dd58a2f68cf0a88bebba1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c58350987c6761c67fc07352c867d06" id="r_a8c58350987c6761c67fc07352c867d06"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8c58350987c6761c67fc07352c867d06"><td class="memTemplItemLeft" align="right" valign="top">long double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8c58350987c6761c67fc07352c867d06">zero&lt; long double &gt;</a> ()</td></tr>
<tr class="separator:a8c58350987c6761c67fc07352c867d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270f15f1b891fb7a5a25b6d6c05a3415" id="r_a270f15f1b891fb7a5a25b6d6c05a3415"><td class="memTemplParams" colspan="2">template&lt;typename Real1 , typename Real2 &gt; </td></tr>
<tr class="memitem:a270f15f1b891fb7a5a25b6d6c05a3415"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a270f15f1b891fb7a5a25b6d6c05a3415">operator+</a> (<a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt; v1, Real2 v2)</td></tr>
<tr class="separator:a270f15f1b891fb7a5a25b6d6c05a3415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32b9efeceaa3fa3a905c55d9bcd7c04" id="r_ac32b9efeceaa3fa3a905c55d9bcd7c04"><td class="memTemplParams" colspan="2">template&lt;typename Real1 , typename Real2 &gt; </td></tr>
<tr class="memitem:ac32b9efeceaa3fa3a905c55d9bcd7c04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ac32b9efeceaa3fa3a905c55d9bcd7c04">operator+</a> (Real2 v2, <a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt; v1)</td></tr>
<tr class="separator:ac32b9efeceaa3fa3a905c55d9bcd7c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dc7fcc318ed5ef50064e79f9823049" id="r_aa1dc7fcc318ed5ef50064e79f9823049"><td class="memTemplParams" colspan="2">template&lt;typename Real1 , typename Real2 &gt; </td></tr>
<tr class="memitem:aa1dc7fcc318ed5ef50064e79f9823049"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa1dc7fcc318ed5ef50064e79f9823049">operator+</a> (<a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt; v1, <a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real2 &gt; v2)</td></tr>
<tr class="separator:aa1dc7fcc318ed5ef50064e79f9823049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c52511d0da0fcf91a55802ed6ae7a7" id="r_ac5c52511d0da0fcf91a55802ed6ae7a7"><td class="memTemplParams" colspan="2">template&lt;typename Real1 , typename Real2 &gt; </td></tr>
<tr class="memitem:ac5c52511d0da0fcf91a55802ed6ae7a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ac5c52511d0da0fcf91a55802ed6ae7a7">operator-</a> (<a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt; v1, Real2 v2)</td></tr>
<tr class="separator:ac5c52511d0da0fcf91a55802ed6ae7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce3ed06769a5968a25a2754efd73d50" id="r_adce3ed06769a5968a25a2754efd73d50"><td class="memTemplParams" colspan="2">template&lt;typename Real1 , typename Real2 &gt; </td></tr>
<tr class="memitem:adce3ed06769a5968a25a2754efd73d50"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#adce3ed06769a5968a25a2754efd73d50">operator-</a> (Real2 v2, <a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt; v1)</td></tr>
<tr class="separator:adce3ed06769a5968a25a2754efd73d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06981702fc122962d4d4fa9da093ddf9" id="r_a06981702fc122962d4d4fa9da093ddf9"><td class="memTemplParams" colspan="2">template&lt;typename Real1 , typename Real2 &gt; </td></tr>
<tr class="memitem:a06981702fc122962d4d4fa9da093ddf9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a06981702fc122962d4d4fa9da093ddf9">operator-</a> (<a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt; v1, <a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real2 &gt; v2)</td></tr>
<tr class="separator:a06981702fc122962d4d4fa9da093ddf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018f56eab0ce54995d179096ecf1b074" id="r_a018f56eab0ce54995d179096ecf1b074"><td class="memTemplParams" colspan="2">template&lt;typename Char , typename Real &gt; </td></tr>
<tr class="memitem:a018f56eab0ce54995d179096ecf1b074"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Char &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a018f56eab0ce54995d179096ecf1b074">operator&lt;&lt;</a> (std::basic_ostream&lt; Char &gt; &amp;os, const <a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real &gt; &amp;v)</td></tr>
<tr class="separator:a018f56eab0ce54995d179096ecf1b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeb0b6fbdba23fd1f97431eb0955c98" id="r_adfeb0b6fbdba23fd1f97431eb0955c98"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfeb0b6fbdba23fd1f97431eb0955c98"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#adfeb0b6fbdba23fd1f97431eb0955c98">concat</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:adfeb0b6fbdba23fd1f97431eb0955c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f913f164081976ad6f145171117c1f" id="r_a08f913f164081976ad6f145171117c1f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a08f913f164081976ad6f145171117c1f"><td class="memTemplItemLeft" align="right" valign="top">boost::container::small_vector&lt; T, std::max(N1, N2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a08f913f164081976ad6f145171117c1f">concat</a> (const boost::container::small_vector&lt; T, N1 &gt; &amp;a, const boost::container::small_vector&lt; T, N2 &gt; &amp;b)</td></tr>
<tr class="separator:a08f913f164081976ad6f145171117c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e733360ff20c11ea71066839608c7a7" id="r_a6e733360ff20c11ea71066839608c7a7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6e733360ff20c11ea71066839608c7a7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; T, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6e733360ff20c11ea71066839608c7a7">zip</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; U &gt; &amp;b)</td></tr>
<tr class="separator:a6e733360ff20c11ea71066839608c7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bd91a878b892080cb0fe62719728f1" id="r_a44bd91a878b892080cb0fe62719728f1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , std::size_t N1, typename T2 , std::size_t N2&gt; </td></tr>
<tr class="memitem:a44bd91a878b892080cb0fe62719728f1"><td class="memTemplItemLeft" align="right" valign="top">boost::container::small_vector&lt; std::pair&lt; T1, T2 &gt;, std::min(N1, N2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a44bd91a878b892080cb0fe62719728f1">zip</a> (const boost::container::small_vector&lt; T1, N1 &gt; &amp;a, const boost::container::small_vector&lt; T2, N2 &gt; &amp;b)</td></tr>
<tr class="separator:a44bd91a878b892080cb0fe62719728f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fef660c76c4e0c0306b5b27ee9c88d" id="r_a57fef660c76c4e0c0306b5b27ee9c88d"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a57fef660c76c4e0c0306b5b27ee9c88d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a57fef660c76c4e0c0306b5b27ee9c88d">symmetrize</a> (<a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;t)</td></tr>
<tr class="memdesc:a57fef660c76c4e0c0306b5b27ee9c88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">symmetrizes sets of equivalent tiled modes of a DistArray  <br /></td></tr>
<tr class="separator:a57fef660c76c4e0c0306b5b27ee9c88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad875575ffa8e3a601eb672889bd177e3" id="r_ad875575ffa8e3a601eb672889bd177e3"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad875575ffa8e3a601eb672889bd177e3">nderiv</a> (size_t nparam, size_t deriv_order)</td></tr>
<tr class="separator:ad875575ffa8e3a601eb672889bd177e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779163b5fa06e9912b6b9b6efc2a465a" id="r_a779163b5fa06e9912b6b9b6efc2a465a"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a779163b5fa06e9912b6b9b6efc2a465a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a779163b5fa06e9912b6b9b6efc2a465a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classmpqc_1_1math_1_1_taylor_expansion_coefficients.html">TaylorExpansionCoefficients</a>&lt; Value &gt; &amp;x)</td></tr>
<tr class="separator:a779163b5fa06e9912b6b9b6efc2a465a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f81f037771f9805a07dde53c8c1d5aa" id="r_a8f81f037771f9805a07dde53c8c1d5aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8f81f037771f9805a07dde53c8c1d5aa">to_string</a> (<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a6fd2e3aaa379968daec8b9a5e0559410">PetiteList::Symmetry</a> symmetry)</td></tr>
<tr class="separator:a8f81f037771f9805a07dde53c8c1d5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2255fa0428166d1f037d6d3a3fd73d6" id="r_ab2255fa0428166d1f037d6d3a3fd73d6"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab2255fa0428166d1f037d6d3a3fd73d6">to_wstring</a> (<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a6fd2e3aaa379968daec8b9a5e0559410">PetiteList::Symmetry</a> symmetry)</td></tr>
<tr class="separator:ab2255fa0428166d1f037d6d3a3fd73d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e27a6b13adf482be354cd6d90daa76e" id="r_a5e27a6b13adf482be354cd6d90daa76e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5e27a6b13adf482be354cd6d90daa76e">to_string</a> (<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> method)</td></tr>
<tr class="memdesc:a5e27a6b13adf482be354cd6d90daa76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert CanonicalColumnPhaseMethod to std::string  <br /></td></tr>
<tr class="separator:a5e27a6b13adf482be354cd6d90daa76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509c1f3cafb5a39df41561b6f0e6ce2a" id="r_a509c1f3cafb5a39df41561b6f0e6ce2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a509c1f3cafb5a39df41561b6f0e6ce2a">to_canonical_column_phase_method</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a509c1f3cafb5a39df41561b6f0e6ce2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert std::string to CanonicalColumnPhaseMethod  <br /></td></tr>
<tr class="separator:a509c1f3cafb5a39df41561b6f0e6ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae739cec487a3f4ec2437a8b4dcf904ed" id="r_ae739cec487a3f4ec2437a8b4dcf904ed"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="structmpqc_1_1math_1_1_canonical_column_phase_control.html">CanonicalColumnPhaseControl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ae739cec487a3f4ec2437a8b4dcf904ed">canonical_column_phase_control</a> ()</td></tr>
<tr class="memdesc:ae739cec487a3f4ec2437a8b4dcf904ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">accesses the singleton object that controls canonical_column_phase functions  <br /></td></tr>
<tr class="separator:ae739cec487a3f4ec2437a8b4dcf904ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf438ea6cc7c6dc1cd78856f9ce606f2" id="r_aaf438ea6cc7c6dc1cd78856f9ce606f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aaf438ea6cc7c6dc1cd78856f9ce606f2">pop_canonical_column_phase_control</a> ()</td></tr>
<tr class="memdesc:aaf438ea6cc7c6dc1cd78856f9ce606f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">pops the last control object from the stack  <br /></td></tr>
<tr class="separator:aaf438ea6cc7c6dc1cd78856f9ce606f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caa8e219636efd0bab2d143ac55d27a" id="r_a7caa8e219636efd0bab2d143ac55d27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a7caa8e219636efd0bab2d143ac55d27a">pop_canonical_column_phase_control</a> (std::shared_ptr&lt; const <a class="el" href="structmpqc_1_1math_1_1_canonical_column_phase_control.html">CanonicalColumnPhaseControl</a> &gt; ctl)</td></tr>
<tr class="memdesc:a7caa8e219636efd0bab2d143ac55d27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pops the last control object from the stack, ensures that it equals <code>ctl</code>  <br /></td></tr>
<tr class="separator:a7caa8e219636efd0bab2d143ac55d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bf185f29d6891f31f3f26d78ad122e" id="r_ab5bf185f29d6891f31f3f26d78ad122e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmpqc_1_1math_1_1_canonical_column_phase_control.html">CanonicalColumnPhaseControl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab5bf185f29d6891f31f3f26d78ad122e">push_canonical_column_phase_control</a> ()</td></tr>
<tr class="memdesc:ab5bf185f29d6891f31f3f26d78ad122e"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new control object on the stack as a copy of last object  <br /></td></tr>
<tr class="separator:ab5bf185f29d6891f31f3f26d78ad122e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a658571742bd129fe131af7b2284b1b" id="r_a1a658571742bd129fe131af7b2284b1b"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Compare &gt; </td></tr>
<tr class="memitem:a1a658571742bd129fe131af7b2284b1b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a1a658571742bd129fe131af7b2284b1b">range_degeneracies</a> (Range &amp;&amp;range, Compare comp)</td></tr>
<tr class="separator:a1a658571742bd129fe131af7b2284b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440bc52caf01c0e690109178258cd1d5" id="r_a440bc52caf01c0e690109178258cd1d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename NumericFromTExtracter &gt; </td></tr>
<tr class="memitem:a440bc52caf01c0e690109178258cd1d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a440bc52caf01c0e690109178258cd1d5">relative_difference</a> (T _v1, T _v2, NumericFromTExtracter numeric_from=[](const T &amp;_v) { return _v;})</td></tr>
<tr class="separator:a440bc52caf01c0e690109178258cd1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa6f6297747c91120658e7426c3424f" id="r_abaa6f6297747c91120658e7426c3424f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abaa6f6297747c91120658e7426c3424f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#abaa6f6297747c91120658e7426c3424f">canonical_greater</a> (T v1, T v2, TA::detail::scalar_t&lt; T &gt; rel_cmp_thresh)</td></tr>
<tr class="memdesc:abaa6f6297747c91120658e7426c3424f"><td class="mdescLeft">&#160;</td><td class="mdescRight">canonical greater-than comparison of 2 real numbers (orders first by magnitude, then by value)  <br /></td></tr>
<tr class="separator:abaa6f6297747c91120658e7426c3424f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4fef27508593505e4cfaa3b1eb9f22" id="r_abe4fef27508593505e4cfaa3b1eb9f22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe4fef27508593505e4cfaa3b1eb9f22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#abe4fef27508593505e4cfaa3b1eb9f22">canonical_less</a> (T v1, T v2, TA::detail::scalar_t&lt; T &gt; rel_cmp_thresh)</td></tr>
<tr class="memdesc:abe4fef27508593505e4cfaa3b1eb9f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">canonical less-than comparison of 2 real numbers (orders first by magnitude, then by value)  <br /></td></tr>
<tr class="separator:abe4fef27508593505e4cfaa3b1eb9f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e991210a817b5facda479edd24b523" id="r_af4e991210a817b5facda479edd24b523"><td class="memTemplParams" colspan="2">template&lt;typename Numeric , typename NumericFromTExtracter &gt; </td></tr>
<tr class="memitem:af4e991210a817b5facda479edd24b523"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af4e991210a817b5facda479edd24b523">numeric_range_degeneracies</a> (std::span&lt; Numeric &gt; range, double rel_eps, NumericFromTExtracter numeric_from)</td></tr>
<tr class="separator:af4e991210a817b5facda479edd24b523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c5cc9ff270f29c7ea311dcf6165d83" id="r_a42c5cc9ff270f29c7ea311dcf6165d83"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:a42c5cc9ff270f29c7ea311dcf6165d83"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a42c5cc9ff270f29c7ea311dcf6165d83">match_numeric_range_degeneracies</a> (std::span&lt; Numeric &gt; range, const std::vector&lt; std::size_t &gt; &amp;reference_degeneracies, const TA::detail::scalar_t&lt; Numeric &gt; rel_eps_upper_bound)</td></tr>
<tr class="separator:a42c5cc9ff270f29c7ea311dcf6165d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5e1bbc021c37a113f71d50f3fb5b70" id="r_a9f5e1bbc021c37a113f71d50f3fb5b70"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:a9f5e1bbc021c37a113f71d50f3fb5b70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a9f5e1bbc021c37a113f71d50f3fb5b70">check_numeric_range_degeneracies</a> (std::span&lt; Numeric &gt; range, TiledArray::detail::scalar_t&lt; Numeric &gt; rel_eps, const std::vector&lt; std::size_t &gt; &amp;proposed_degeneracies)</td></tr>
<tr class="separator:a9f5e1bbc021c37a113f71d50f3fb5b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63c4b26d49f74c6b8c6dc56ae496dde" id="r_ab63c4b26d49f74c6b8c6dc56ae496dde"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:ab63c4b26d49f74c6b8c6dc56ae496dde"><td class="memTemplItemLeft" align="right" valign="top">Numeric&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab63c4b26d49f74c6b8c6dc56ae496dde">canonical_phase_inverse</a> (const Numeric &amp;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">value</a>)</td></tr>
<tr class="separator:ab63c4b26d49f74c6b8c6dc56ae496dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaececfc679d1c478296e47697597a6513" id="r_gaececfc679d1c478296e47697597a6513"><td class="memTemplParams" colspan="2">template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:gaececfc679d1c478296e47697597a6513"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p.html#gaececfc679d1c478296e47697597a6513">canonicalize_column_phase_nondeg</a> (Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;matrix, std::vector&lt; Eigen::Index &gt; *pd_element_rowidx_ptr, TA::detail::scalar_t&lt; _Numeric &gt; rel_eps)</td></tr>
<tr class="memdesc:gaececfc679d1c478296e47697597a6513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalizes column phases without accounting for degeneracies among columns.  <br /></td></tr>
<tr class="separator:gaececfc679d1c478296e47697597a6513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05339acc15c9773ec353be2e29aed095" id="r_ga05339acc15c9773ec353be2e29aed095"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:ga05339acc15c9773ec353be2e29aed095"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p.html#ga05339acc15c9773ec353be2e29aed095">canonical_column_phase_impl</a> (const Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;A, TA::detail::scalar_t&lt; _Numeric &gt; A_element_comparison_tolerance=1e-4, std::vector&lt; size_t &gt; degenerate_panel_sizes={}, bool canonicalize_panel_order=false)</td></tr>
<tr class="memdesc:ga05339acc15c9773ec353be2e29aed095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalizes column phases and accounts for degeneracies among columns.  <br /></td></tr>
<tr class="separator:ga05339acc15c9773ec353be2e29aed095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2768700def100ce439bbfa5bc9bf9e" id="r_a1b2768700def100ce439bbfa5bc9bf9e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename T , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols, typename _Numeric &gt; </td></tr>
<tr class="memitem:a1b2768700def100ce439bbfa5bc9bf9e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a1b2768700def100ce439bbfa5bc9bf9e">canonical_column_phase</a> (const Eigen::Matrix&lt; T, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;A, TA::detail::scalar_t&lt; _Numeric &gt; A_element_comparison_tolerance, std::span&lt; _Numeric &gt; column_attributes, TA::detail::scalar_t&lt; _Numeric &gt; column_attributes_comparison_tolerance, bool canonicalize_panel_order)</td></tr>
<tr class="memdesc:a1b2768700def100ce439bbfa5bc9bf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that takes an Eigen::Matrix  <br /></td></tr>
<tr class="separator:a1b2768700def100ce439bbfa5bc9bf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b10e4432be510341f8d0e90f179d67c" id="r_a6b10e4432be510341f8d0e90f179d67c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename Tile , typename Policy , typename Numeric &gt; </td></tr>
<tr class="memitem:a6b10e4432be510341f8d0e90f179d67c"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6b10e4432be510341f8d0e90f179d67c">canonical_column_phase</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A, TA::detail::scalar_t&lt; Numeric &gt; A_element_comparison_tolerance, std::span&lt; Numeric &gt; column_attributes, TA::detail::scalar_t&lt; Numeric &gt; column_attribute_comparison_tolerance, bool canonicalize_panel_order)</td></tr>
<tr class="memdesc:a6b10e4432be510341f8d0e90f179d67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that takes a TA::DistArray  <br /></td></tr>
<tr class="separator:a6b10e4432be510341f8d0e90f179d67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af63ecffee0bd450cc69213ce49b884" id="r_a6af63ecffee0bd450cc69213ce49b884"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Numeric &gt; </td></tr>
<tr class="memitem:a6af63ecffee0bd450cc69213ce49b884"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6af63ecffee0bd450cc69213ce49b884">canonical_column_phase</a> (<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, const TA::DistArray&lt; Tile, Policy &gt; &amp;A, TA::detail::scalar_t&lt; Numeric &gt; A_element_comparison_tolerance, std::span&lt; Numeric &gt; column_attributes, TA::detail::scalar_t&lt; Numeric &gt; column_attribute_comparison_tolerance, bool canonicalize_panel_order)</td></tr>
<tr class="memdesc:a6af63ecffee0bd450cc69213ce49b884"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that takes a TA::DistArray and takes CanonicalColumnPhaseMethod as regular argument  <br /></td></tr>
<tr class="separator:a6af63ecffee0bd450cc69213ce49b884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5754059c0b0f3ffc5294d46f2bdc51eb" id="r_ga5754059c0b0f3ffc5294d46f2bdc51eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:ga5754059c0b0f3ffc5294d46f2bdc51eb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; std::remove_const_t&lt; _Numeric &gt;, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p_guided.html#ga5754059c0b0f3ffc5294d46f2bdc51eb">canonical_column_phase</a> (const Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;A, TA::detail::scalar_t&lt; _Numeric &gt; A_element_comparison_tolerance, std::span&lt; _Numeric &gt; column_attributes, const std::vector&lt; std::size_t &gt; &amp;reference_degeneracies, bool canonicalize_panel_order, const TA::detail::scalar_t&lt; _Numeric &gt; column_attributes_rel_eps_upper_bound)</td></tr>
<tr class="memdesc:ga5754059c0b0f3ffc5294d46f2bdc51eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that takes an Eigen::Matrix  <br /></td></tr>
<tr class="separator:ga5754059c0b0f3ffc5294d46f2bdc51eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb2b1d227ad9d2de5404a4c64e27f99" id="r_gabeb2b1d227ad9d2de5404a4c64e27f99"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename Tile , typename Policy , typename Numeric &gt; </td></tr>
<tr class="memitem:gabeb2b1d227ad9d2de5404a4c64e27f99"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p_guided.html#gabeb2b1d227ad9d2de5404a4c64e27f99">canonical_column_phase</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A, TA::detail::scalar_t&lt; Numeric &gt; A_element_comparison_tolerance, std::span&lt; Numeric &gt; column_attributes, const std::vector&lt; std::size_t &gt; &amp;reference_degeneracies, bool canonicalize_panel_order, const TA::detail::scalar_t&lt; Numeric &gt; rel_eps_upper_bound)</td></tr>
<tr class="memdesc:gabeb2b1d227ad9d2de5404a4c64e27f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that takes a TA::DistArray  <br /></td></tr>
<tr class="separator:gabeb2b1d227ad9d2de5404a4c64e27f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d818aa12e4be9732f52855a9f1d445" id="r_gae4d818aa12e4be9732f52855a9f1d445"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename T , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols, typename _Numeric &gt; </td></tr>
<tr class="memitem:gae4d818aa12e4be9732f52855a9f1d445"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p_fixed.html#gae4d818aa12e4be9732f52855a9f1d445">canonical_column_phase</a> (const Eigen::Matrix&lt; T, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;A, TA::detail::scalar_t&lt; _Numeric &gt; A_element_comparison_tolerance, const std::vector&lt; std::size_t &gt; &amp;reference_degeneracies, bool canonicalize_panel_order)</td></tr>
<tr class="memdesc:gae4d818aa12e4be9732f52855a9f1d445"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that takes an Eigen::Matrix  <br /></td></tr>
<tr class="separator:gae4d818aa12e4be9732f52855a9f1d445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb2ddd59043ec033f053dc69fa9ee57" id="r_gadfb2ddd59043ec033f053dc69fa9ee57"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename Tile , typename Policy , typename Numeric &gt; </td></tr>
<tr class="memitem:gadfb2ddd59043ec033f053dc69fa9ee57"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p_fixed.html#gadfb2ddd59043ec033f053dc69fa9ee57">canonical_column_phase</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A, TA::detail::scalar_t&lt; Numeric &gt; A_element_comparison_tolerance, const std::vector&lt; std::size_t &gt; &amp;reference_degeneracies, bool canonicalize_panel_order)</td></tr>
<tr class="memdesc:gadfb2ddd59043ec033f053dc69fa9ee57"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that takes a TA::DistArray  <br /></td></tr>
<tr class="separator:gadfb2ddd59043ec033f053dc69fa9ee57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80b51befcfd34b9ff9c36a42923fd7b" id="r_aa80b51befcfd34b9ff9c36a42923fd7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename RealT &gt; </td></tr>
<tr class="memitem:aa80b51befcfd34b9ff9c36a42923fd7b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa80b51befcfd34b9ff9c36a42923fd7b">antihermitian_matrix_strictupper_to_full</a> (Eigen::Index n, const RealT *uptri_real)</td></tr>
<tr class="separator:aa80b51befcfd34b9ff9c36a42923fd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c06c722b38faf0be334e1163292db3" id="r_ad7c06c722b38faf0be334e1163292db3"><td class="memTemplParams" colspan="2">template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:ad7c06c722b38faf0be334e1163292db3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad7c06c722b38faf0be334e1163292db3">compute_pd_element_rowidx</a> (const Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;matrix, TA::detail::scalar_t&lt; _Numeric &gt; rel_eps=1e-4)</td></tr>
<tr class="memdesc:ad7c06c722b38faf0be334e1163292db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the <em>phase-defining</em> element of each column.  <br /></td></tr>
<tr class="separator:ad7c06c722b38faf0be334e1163292db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd1fd58bfb5187e546aa723548df236" id="r_abfd1fd58bfb5187e546aa723548df236"><td class="memTemplParams" colspan="2">template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:abfd1fd58bfb5187e546aa723548df236"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#abfd1fd58bfb5187e546aa723548df236">permutation_to_canonical_column_order</a> (const Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;A, const std::vector&lt; Eigen::Index &gt; &amp;pd_element_rowidx, const std::vector&lt; std::size_t &gt; &amp;degenerate_panel_sizes, TA::detail::scalar_t&lt; _Numeric &gt; A_element_comparison_tolerance=1e-4, bool reorder_panels=true)</td></tr>
<tr class="memdesc:abfd1fd58bfb5187e546aa723548df236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders columns (or degenerate panels) into canonical order.  <br /></td></tr>
<tr class="separator:abfd1fd58bfb5187e546aa723548df236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dbd6d3c89024c21af4c1e6b13075e4" id="r_a22dbd6d3c89024c21af4c1e6b13075e4"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a22dbd6d3c89024c21af4c1e6b13075e4"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; double &gt;, TA::DistArray&lt; Tile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a22dbd6d3c89024c21af4c1e6b13075e4">nnheig</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A, double evd_max_condition_number=1e8, bool canonicalize_phase=false)</td></tr>
<tr class="memdesc:a22dbd6d3c89024c21af4c1e6b13075e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes eigenvalues and eigenvectors of non-negative hermitian matrix A  <br /></td></tr>
<tr class="separator:a22dbd6d3c89024c21af4c1e6b13075e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a7a3925d4acc87e66d5c0c1d837c87" id="r_a41a7a3925d4acc87e66d5c0c1d837c87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">OrthogOutput</a> Output = OrthogOutput::X, typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a41a7a3925d4acc87e66d5c0c1d837c87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1math.html#acfb508667c4e7e2b919b52d35adf107b">ConditionalOrthogOutput</a>&lt; Output, Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a41a7a3925d4acc87e66d5c0c1d837c87">gensqrtinv</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;S, bool symmetric=false, double max_condition_number=1e8, bool canonicalize_phase=false)</td></tr>
<tr class="memdesc:a41a7a3925d4acc87e66d5c0c1d837c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">given hermitian nonnegative metric <code>S</code> computes its generalized square root <code>X</code> such that <code>adjoint(X).S.X = I</code> Hence columns of <code>X</code> define an orthonormal (possibly near-linearly-dependent, if <code>symmetric</code> is true) basis in a vector space with metric <code>S</code>  <br /></td></tr>
<tr class="separator:a41a7a3925d4acc87e66d5c0c1d837c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc649ac3ad6f64658c13c790a97fa7b6" id="r_acc649ac3ad6f64658c13c790a97fa7b6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">OrthogOutput</a> Output = OrthogOutput::X, typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:acc649ac3ad6f64658c13c790a97fa7b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1math.html#acfb508667c4e7e2b919b52d35adf107b">ConditionalOrthogOutput</a>&lt; Output, Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#acc649ac3ad6f64658c13c790a97fa7b6">conditioned_orthogonalizer</a> (TA::DistArray&lt; Tile, Policy &gt; S_array, bool symmetric=false, double S_condition_number_threshold=1/std::sqrt(std::numeric_limits&lt; typename TA::detail::scalar_type&lt; Tile &gt;::type &gt;::epsilon()), bool canonicalize_phase=false)</td></tr>
<tr class="memdesc:acc649ac3ad6f64658c13c790a97fa7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function follows Lowdin's orthogonalization procedure to compute inverse square root of a metric <code>S</code> and/or the square root of <code>S</code> based on the given condition number.  <br /></td></tr>
<tr class="separator:acc649ac3ad6f64658c13c790a97fa7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661e50c8b8d2539452ba34478dc5846e" id="r_a661e50c8b8d2539452ba34478dc5846e"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a661e50c8b8d2539452ba34478dc5846e"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a661e50c8b8d2539452ba34478dc5846e">create_diagonal_array_from_eigen</a> (madness::World &amp;world, const TA::TiledRange1 &amp;trange1, const TA::TiledRange1 &amp;trange2, typename Tile::numeric_type val)</td></tr>
<tr class="separator:a661e50c8b8d2539452ba34478dc5846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da828bcd8f09edb5650a2090ed8f459" id="r_a1da828bcd8f09edb5650a2090ed8f459"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a1da828bcd8f09edb5650a2090ed8f459"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a1da828bcd8f09edb5650a2090ed8f459">min_eval_guess</a> (It <a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22ca8b04d5e3775d298e78455efc5ca404d5">first</a>, It <a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22caa9f0e61a137d86aa9db53465e0801612">second</a>)</td></tr>
<tr class="separator:a1da828bcd8f09edb5650a2090ed8f459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f00bda1ee2167d04edda6ffbb6a805" id="r_a46f00bda1ee2167d04edda6ffbb6a805"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a46f00bda1ee2167d04edda6ffbb6a805"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a46f00bda1ee2167d04edda6ffbb6a805">symmetric_min_max_evals</a> (Array const &amp;S)</td></tr>
<tr class="separator:a46f00bda1ee2167d04edda6ffbb6a805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d53fb82cbab16761b698f2df43eafdc" id="r_a9d53fb82cbab16761b698f2df43eafdc"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a9d53fb82cbab16761b698f2df43eafdc"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a9d53fb82cbab16761b698f2df43eafdc">init_X</a> (Array const &amp;S)</td></tr>
<tr class="separator:a9d53fb82cbab16761b698f2df43eafdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82da456aeca60d90c5ca5013324d8fb" id="r_ab82da456aeca60d90c5ca5013324d8fb"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:ab82da456aeca60d90c5ca5013324d8fb"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab82da456aeca60d90c5ca5013324d8fb">invert</a> (Array const &amp;S)</td></tr>
<tr class="separator:ab82da456aeca60d90c5ca5013324d8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a97cbe6ee465c79280f5f804fdd9ee" id="r_ae6a97cbe6ee465c79280f5f804fdd9ee"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:ae6a97cbe6ee465c79280f5f804fdd9ee"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ae6a97cbe6ee465c79280f5f804fdd9ee">min_eval_est</a> (Array const &amp;H, Array const &amp;S)</td></tr>
<tr class="separator:ae6a97cbe6ee465c79280f5f804fdd9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee9336a8084375c301af7e1a21ab291" id="r_a2ee9336a8084375c301af7e1a21ab291"><td class="memTemplParams" colspan="2">template&lt;typename Numeric , typename Proj  = mpqc::identity&gt; </td></tr>
<tr class="memitem:a2ee9336a8084375c301af7e1a21ab291"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a2ee9336a8084375c301af7e1a21ab291">numeric_range_degeneracies</a> (std::span&lt; Numeric &gt; range, double rel_eps=1e-4, Proj numeric_from={})</td></tr>
<tr class="separator:a2ee9336a8084375c301af7e1a21ab291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8fdfb670bcba2645c6c9e65c656bbb" id="r_gabf8fdfb670bcba2645c6c9e65c656bbb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM = CanonicalColumnPhaseMethod::Default, typename T , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols, typename _Numeric &gt; </td></tr>
<tr class="memitem:gabf8fdfb670bcba2645c6c9e65c656bbb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p_auto.html#gabf8fdfb670bcba2645c6c9e65c656bbb">canonical_column_phase</a> (const Eigen::Matrix&lt; T, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;A, TiledArray::detail::scalar_t&lt; _Numeric &gt; A_element_comparison_tolerance, std::span&lt; _Numeric &gt; column_attributes, TiledArray::detail::scalar_t&lt; _Numeric &gt; column_attribute_comparison_tolerance=-1., bool canonicalize_panel_order=false)</td></tr>
<tr class="separator:gabf8fdfb670bcba2645c6c9e65c656bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad389e302dc3314c6d4cdcaf36f2fb863" id="r_gad389e302dc3314c6d4cdcaf36f2fb863"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM = CanonicalColumnPhaseMethod::Default, typename Tile  = MPQC_DEFAULT_REAL_TA_TILE_CLASS, typename Policy  = MPQC_DEFAULT_TA_POLICY_CLASS, typename Numeric &gt; </td></tr>
<tr class="memitem:gad389e302dc3314c6d4cdcaf36f2fb863"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p_auto.html#gad389e302dc3314c6d4cdcaf36f2fb863">canonical_column_phase</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A, TiledArray::detail::scalar_t&lt; Numeric &gt; A_element_comparison_tolerance, std::span&lt; Numeric &gt; column_attributes, TiledArray::detail::scalar_t&lt; Numeric &gt; column_attribute_comparison_tolerance=-1., bool canonicalize_panel_order=false)</td></tr>
<tr class="separator:gad389e302dc3314c6d4cdcaf36f2fb863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939efd3db3b670ce9d13205bcc97c232" id="r_ga939efd3db3b670ce9d13205bcc97c232"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = MPQC_DEFAULT_REAL_TA_TILE_CLASS, typename Policy  = MPQC_DEFAULT_TA_POLICY_CLASS, typename Numeric &gt; </td></tr>
<tr class="memitem:ga939efd3db3b670ce9d13205bcc97c232"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___math_matrix_c_c_p_auto.html#ga939efd3db3b670ce9d13205bcc97c232">canonical_column_phase</a> (<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, const TA::DistArray&lt; Tile, Policy &gt; &amp;A, TiledArray::detail::scalar_t&lt; Numeric &gt; A_element_comparison_tolerance, std::span&lt; Numeric &gt; column_attributes, TiledArray::detail::scalar_t&lt; Numeric &gt; column_attribute_comparison_tolerance=-1., bool canonicalize_panel_order=false)</td></tr>
<tr class="separator:ga939efd3db3b670ce9d13205bcc97c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdf899e26d1bb277ee714b79dc8a317" id="r_aafdf899e26d1bb277ee714b79dc8a317"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:aafdf899e26d1bb277ee714b79dc8a317"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aafdf899e26d1bb277ee714b79dc8a317">generalized_inverse_sqrt</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A, const double target_condition_number=1e8, const bool try_cholesky=true)</td></tr>
<tr class="separator:aafdf899e26d1bb277ee714b79dc8a317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cd9ad5a778d060ed187cba804794a1" id="r_a33cd9ad5a778d060ed187cba804794a1"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a33cd9ad5a778d060ed187cba804794a1"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; typename TA::detail::scalar_t&lt; Tile &gt; &gt;, TA::DistArray&lt; Tile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a33cd9ad5a778d060ed187cba804794a1">heig</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A, const TA::DistArray&lt; Tile, Policy &gt; &amp;B, const bool try_cholesky=true, const double B_target_condition_number=1e8)</td></tr>
<tr class="memdesc:a33cd9ad5a778d060ed187cba804794a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves generalized hermitian eigenproblem  <br /></td></tr>
<tr class="separator:a33cd9ad5a778d060ed187cba804794a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf270c27528fa0288cc72ded598bc33" id="r_accf270c27528fa0288cc72ded598bc33"><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr class="memitem:accf270c27528fa0288cc72ded598bc33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#accf270c27528fa0288cc72ded598bc33">gram_schmidt</a> (std::vector&lt; D &gt; &amp;V, double threshold, std::size_t start=0)</td></tr>
<tr class="separator:accf270c27528fa0288cc72ded598bc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd34283d2a717f729d32e0ae006fde05" id="r_abd34283d2a717f729d32e0ae006fde05"><td class="memTemplParams" colspan="2">template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:abd34283d2a717f729d32e0ae006fde05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#abd34283d2a717f729d32e0ae006fde05">gram_schmidt</a> (Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;V, double threshold, std::size_t start=0)</td></tr>
<tr class="separator:abd34283d2a717f729d32e0ae006fde05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24681b119cb56ce3b4f02d27ac81d5a2" id="r_a24681b119cb56ce3b4f02d27ac81d5a2"><td class="memTemplParams" colspan="2">template&lt;typename D1 , typename D2 &gt; </td></tr>
<tr class="memitem:a24681b119cb56ce3b4f02d27ac81d5a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a24681b119cb56ce3b4f02d27ac81d5a2">gram_schmidt</a> (const std::vector&lt; D1 &gt; &amp;V1, std::vector&lt; D2 &gt; &amp;V2, double threshold)</td></tr>
<tr class="separator:a24681b119cb56ce3b4f02d27ac81d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18894bcfa7762d1ae608063cbf8bc5b6" id="r_a18894bcfa7762d1ae608063cbf8bc5b6"><td class="memTemplParams" colspan="2">template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:a18894bcfa7762d1ae608063cbf8bc5b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a18894bcfa7762d1ae608063cbf8bc5b6">gram_schmidt</a> (const Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;V1, Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;V2, double threshold)</td></tr>
<tr class="separator:a18894bcfa7762d1ae608063cbf8bc5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674388c45ca8c48f95e5e13fd64ca0e0" id="r_a674388c45ca8c48f95e5e13fd64ca0e0"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a674388c45ca8c48f95e5e13fd64ca0e0"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a674388c45ca8c48f95e5e13fd64ca0e0">inverse</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A, const bool try_cholesky=true)</td></tr>
<tr class="memdesc:a674388c45ca8c48f95e5e13fd64ca0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes inverse of a hermitian positive-definite matrix  <br /></td></tr>
<tr class="separator:a674388c45ca8c48f95e5e13fd64ca0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e138deca4ad919292d6e9b6b6adf560" id="r_a4e138deca4ad919292d6e9b6b6adf560"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TReal &gt; </td></tr>
<tr class="memitem:a4e138deca4ad919292d6e9b6b6adf560"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a4e138deca4ad919292d6e9b6b6adf560">print_single_state_davidson_energy_iteration</a> (std::size_t iter, const T &amp;delta_e, const TReal &amp;error, const T &amp;eig, double time1, double time2)</td></tr>
<tr class="memdesc:a4e138deca4ad919292d6e9b6b6adf560"><td class="mdescLeft">&#160;</td><td class="mdescRight">print excitation energy and other stats at given iteration for 1 state  <br /></td></tr>
<tr class="separator:a4e138deca4ad919292d6e9b6b6adf560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c64914ec64b3e06403130b1680913a" id="r_a11c64914ec64b3e06403130b1680913a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TReal &gt; </td></tr>
<tr class="memitem:a11c64914ec64b3e06403130b1680913a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a11c64914ec64b3e06403130b1680913a">print_davidson_energy_iteration</a> (std::size_t iter, const <a class="el" href="namespacempqc.html#a3da9a3fb456dd9f37bdcd05455b8cffe">EigenVector</a>&lt; T &gt; &amp;delta_e, const <a class="el" href="namespacempqc.html#a3da9a3fb456dd9f37bdcd05455b8cffe">EigenVector</a>&lt; TReal &gt; &amp;error, const <a class="el" href="namespacempqc.html#a3da9a3fb456dd9f37bdcd05455b8cffe">EigenVector</a>&lt; T &gt; &amp;eig, double time1, double time2)</td></tr>
<tr class="memdesc:a11c64914ec64b3e06403130b1680913a"><td class="mdescLeft">&#160;</td><td class="mdescRight">print excitation energy at each iteration  <br /></td></tr>
<tr class="separator:a11c64914ec64b3e06403130b1680913a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750912b6fc64da0bcd60bd0d7d611d36" id="r_a750912b6fc64da0bcd60bd0d7d611d36"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Idx &gt; </td></tr>
<tr class="memitem:a750912b6fc64da0bcd60bd0d7d611d36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a750912b6fc64da0bcd60bd0d7d611d36">print_dominant_elements</a> (const std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;dominants)</td></tr>
<tr class="memdesc:a750912b6fc64da0bcd60bd0d7d611d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">print dominant index and element in vector with indices ordered as vir, occ  <br /></td></tr>
<tr class="separator:a750912b6fc64da0bcd60bd0d7d611d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261da1b1dcd43fa1de0ec547028ae44c" id="r_a261da1b1dcd43fa1de0ec547028ae44c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Idx &gt; </td></tr>
<tr class="memitem:a261da1b1dcd43fa1de0ec547028ae44c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a261da1b1dcd43fa1de0ec547028ae44c">print_cis_dominant_elements</a> (std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;dominants)</td></tr>
<tr class="memdesc:a261da1b1dcd43fa1de0ec547028ae44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">print dominant index and element in cis vector, with index ordered as i,a  <br /></td></tr>
<tr class="separator:a261da1b1dcd43fa1de0ec547028ae44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285291bb1383a9dbce1f1c1bc183430f" id="r_a285291bb1383a9dbce1f1c1bc183430f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Idx &gt; </td></tr>
<tr class="memitem:a285291bb1383a9dbce1f1c1bc183430f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a285291bb1383a9dbce1f1c1bc183430f">print_t1_dominant_elements</a> (std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;dominants)</td></tr>
<tr class="memdesc:a285291bb1383a9dbce1f1c1bc183430f"><td class="mdescLeft">&#160;</td><td class="mdescRight">print dominant index and element in t1, with index ordered as a, i  <br /></td></tr>
<tr class="separator:a285291bb1383a9dbce1f1c1bc183430f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa488ca12f9d49f2e762ce5eb9da1a9e2" id="r_aa488ca12f9d49f2e762ce5eb9da1a9e2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Idx &gt; </td></tr>
<tr class="memitem:aa488ca12f9d49f2e762ce5eb9da1a9e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa488ca12f9d49f2e762ce5eb9da1a9e2">print_t1_for_ip</a> (std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;dominants)</td></tr>
<tr class="memdesc:aa488ca12f9d49f2e762ce5eb9da1a9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">print dominant index and element in t1  <br /></td></tr>
<tr class="separator:aa488ca12f9d49f2e762ce5eb9da1a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e1907ca7da7f7659ece0e7d79d791d" id="r_ab3e1907ca7da7f7659ece0e7d79d791d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Idx &gt; </td></tr>
<tr class="memitem:ab3e1907ca7da7f7659ece0e7d79d791d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab3e1907ca7da7f7659ece0e7d79d791d">print_t1_for_ea</a> (std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;dominants)</td></tr>
<tr class="memdesc:ab3e1907ca7da7f7659ece0e7d79d791d"><td class="mdescLeft">&#160;</td><td class="mdescRight">print dominant index and element in t1  <br /></td></tr>
<tr class="separator:ab3e1907ca7da7f7659ece0e7d79d791d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38b29ae9b7c74a7604022c8e5eecd50" id="r_ab38b29ae9b7c74a7604022c8e5eecd50"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Idx &gt; </td></tr>
<tr class="memitem:ab38b29ae9b7c74a7604022c8e5eecd50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab38b29ae9b7c74a7604022c8e5eecd50">print_t2_dominant_elements</a> (std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;dominants)</td></tr>
<tr class="memdesc:ab38b29ae9b7c74a7604022c8e5eecd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">print dominant index and element in t2, with index ordered as a,b,i,j  <br /></td></tr>
<tr class="separator:ab38b29ae9b7c74a7604022c8e5eecd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba0b10abafcc2418c343758652ca13" id="r_a01ba0b10abafcc2418c343758652ca13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01ba0b10abafcc2418c343758652ca13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a01ba0b10abafcc2418c343758652ca13">print_excitation_energy</a> (const <a class="el" href="namespacempqc.html#a3da9a3fb456dd9f37bdcd05455b8cffe">EigenVector</a>&lt; T &gt; &amp;eig, const std::string &amp;type=&quot;&quot;)</td></tr>
<tr class="memdesc:a01ba0b10abafcc2418c343758652ca13"><td class="mdescLeft">&#160;</td><td class="mdescRight">print excitation energy with different units  <br /></td></tr>
<tr class="separator:a01ba0b10abafcc2418c343758652ca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae137646b4e9b5ebd4773238e62e212c" id="r_aae137646b4e9b5ebd4773238e62e212c"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:aae137646b4e9b5ebd4773238e62e212c"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aae137646b4e9b5ebd4773238e62e212c">pseudoinverse</a> (TA::DistArray&lt; Tile, Policy &gt; const &amp;A, bool HPSD=false)</td></tr>
<tr class="separator:aae137646b4e9b5ebd4773238e62e212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79dcd2593c8ef516ef3106153143e50" id="r_ae79dcd2593c8ef516ef3106153143e50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae79dcd2593c8ef516ef3106153143e50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc.html#af7d62eef9a57009197611dc94bf57393">RowMatrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ae79dcd2593c8ef516ef3106153143e50">random_unitary</a> (int size, double seed=42.0, double a=0, double b=1)</td></tr>
<tr class="separator:ae79dcd2593c8ef516ef3106153143e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97dc93fc3e75497ea1a49440f8d1fa1" id="r_ac97dc93fc3e75497ea1a49440f8d1fa1"><td class="memTemplParams" colspan="2">template&lt;typename Tile , std::enable_if_t&lt; TiledArray::detail::is_contiguous_tensor_v&lt; Tile &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac97dc93fc3e75497ea1a49440f8d1fa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ac97dc93fc3e75497ea1a49440f8d1fa1">eigen_estimator</a> (std::array&lt; TA::detail::real_t&lt; Tile &gt;, 2 &gt; &amp;result, Tile const &amp;tile)</td></tr>
<tr class="separator:ac97dc93fc3e75497ea1a49440f8d1fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc91636eb2d39c979d0b0eeadc29e50" id="r_a7cc91636eb2d39c979d0b0eeadc29e50"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a7cc91636eb2d39c979d0b0eeadc29e50"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a7cc91636eb2d39c979d0b0eeadc29e50">max_eval_est</a> (Array const &amp;S)</td></tr>
<tr class="separator:a7cc91636eb2d39c979d0b0eeadc29e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274f32c42d2775f692e9a70157563af" id="r_a4274f32c42d2775f692e9a70157563af"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Tensor , std::enable_if_t&lt; TA::detail::is_contiguous_tensor_v&lt; Tensor &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4274f32c42d2775f692e9a70157563af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a4274f32c42d2775f692e9a70157563af">add_to_diag_tile</a> (Scalar val, Tensor &amp;tile)</td></tr>
<tr class="separator:a4274f32c42d2775f692e9a70157563af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1f1ae04a884160da0907bea4cd7ae3" id="r_a3f1f1ae04a884160da0907bea4cd7ae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3f1f1ae04a884160da0907bea4cd7ae3">add_to_diag_tile</a> (double val, TA::Tile&lt; <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; &gt; &amp;tile)</td></tr>
<tr class="separator:a3f1f1ae04a884160da0907bea4cd7ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a2ce6e3d09fda4054a7436ecef0125" id="r_ac5a2ce6e3d09fda4054a7436ecef0125"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:ac5a2ce6e3d09fda4054a7436ecef0125"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ac5a2ce6e3d09fda4054a7436ecef0125">add_to_diag</a> (Array &amp;A, double val)</td></tr>
<tr class="separator:ac5a2ce6e3d09fda4054a7436ecef0125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca9771481c0cbee06ce4cf34e69c13e" id="r_a0ca9771481c0cbee06ce4cf34e69c13e"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a0ca9771481c0cbee06ce4cf34e69c13e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; typename Array::scalar_type, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a0ca9771481c0cbee06ce4cf34e69c13e">eval_guess</a> (Array const &amp;A)</td></tr>
<tr class="memdesc:a0ca9771481c0cbee06ce4cf34e69c13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes {min,max} eigenvalue bounds for a square matrix <code>A</code> using Gerschgorin circle theorem  <br /></td></tr>
<tr class="separator:a0ca9771481c0cbee06ce4cf34e69c13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e455bc3c1ac77c8177657d8bd22d77d" id="r_a3e455bc3c1ac77c8177657d8bd22d77d"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a3e455bc3c1ac77c8177657d8bd22d77d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3e455bc3c1ac77c8177657d8bd22d77d">third_order_update</a> (Array const &amp;S, Array &amp;<a class="el" href="namespacempqc_1_1math.html#ad141437494c402b64a9965cc624b81d9">Z</a>)</td></tr>
<tr class="separator:a3e455bc3c1ac77c8177657d8bd22d77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb1eba8e99835dd279b064a14c4c378" id="r_abcb1eba8e99835dd279b064a14c4c378"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:abcb1eba8e99835dd279b064a14c4c378"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#abcb1eba8e99835dd279b064a14c4c378">iterative_inverse_sqrt</a> (Array const &amp;S)</td></tr>
<tr class="separator:abcb1eba8e99835dd279b064a14c4c378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a3a0eb7a0a10ea4c0bd4a56a8f8340" id="r_a57a3a0eb7a0a10ea4c0bd4a56a8f8340"><td class="memTemplParams" colspan="2">template&lt;std::size_t npts, std::size_t variant = 0&gt; </td></tr>
<tr class="memitem:a57a3a0eb7a0a10ea4c0bd4a56a8f8340"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">make_ahrens_beylkin_quadrature</a> (double r)</td></tr>
<tr class="separator:a57a3a0eb7a0a10ea4c0bd4a56a8f8340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b8724a742955b64a2e05aaf16c3186" id="r_a61b8724a742955b64a2e05aaf16c3186"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a61b8724a742955b64a2e05aaf16c3186">make_ahrens_beylkin_quadrature</a> (double r, std::size_t npts, std::size_t variant=0)</td></tr>
<tr class="separator:a61b8724a742955b64a2e05aaf16c3186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b948bc27e54817c4f77b7ed399c90a" id="r_a97b948bc27e54817c4f77b7ed399c90a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a97b948bc27e54817c4f77b7ed399c90a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a97b948bc27e54817c4f77b7ed399c90a">make_ahrens_beylkin_quadrature&lt; 1, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a97b948bc27e54817c4f77b7ed399c90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66735561c4852148e9a98a960a7c5f9" id="r_af66735561c4852148e9a98a960a7c5f9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af66735561c4852148e9a98a960a7c5f9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af66735561c4852148e9a98a960a7c5f9">make_ahrens_beylkin_quadrature&lt; 2, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:af66735561c4852148e9a98a960a7c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7595902a76f8f83bdfff003cf5015d" id="r_ace7595902a76f8f83bdfff003cf5015d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ace7595902a76f8f83bdfff003cf5015d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ace7595902a76f8f83bdfff003cf5015d">make_ahrens_beylkin_quadrature&lt; 2, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:ace7595902a76f8f83bdfff003cf5015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1418c5950a39359917965b53edf06e94" id="r_a1418c5950a39359917965b53edf06e94"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1418c5950a39359917965b53edf06e94"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a1418c5950a39359917965b53edf06e94">make_ahrens_beylkin_quadrature&lt; 2, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:a1418c5950a39359917965b53edf06e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f885d449ababbac758b1f7dd9f5b582" id="r_a6f885d449ababbac758b1f7dd9f5b582"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6f885d449ababbac758b1f7dd9f5b582"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6f885d449ababbac758b1f7dd9f5b582">make_ahrens_beylkin_quadrature&lt; 2, 3 &gt;</a> (double r)</td></tr>
<tr class="separator:a6f885d449ababbac758b1f7dd9f5b582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30294d12dd1054fec2caf73d9e7db600" id="r_a30294d12dd1054fec2caf73d9e7db600"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a30294d12dd1054fec2caf73d9e7db600"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a30294d12dd1054fec2caf73d9e7db600">make_ahrens_beylkin_quadrature&lt; 2, 4 &gt;</a> (double r)</td></tr>
<tr class="separator:a30294d12dd1054fec2caf73d9e7db600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac9f83924bbb9d00190dbedb81f8f3a" id="r_acac9f83924bbb9d00190dbedb81f8f3a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acac9f83924bbb9d00190dbedb81f8f3a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#acac9f83924bbb9d00190dbedb81f8f3a">make_ahrens_beylkin_quadrature&lt; 3, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:acac9f83924bbb9d00190dbedb81f8f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76646641e2c64e167173f20a63c69918" id="r_a76646641e2c64e167173f20a63c69918"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a76646641e2c64e167173f20a63c69918"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a76646641e2c64e167173f20a63c69918">make_ahrens_beylkin_quadrature&lt; 3, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a76646641e2c64e167173f20a63c69918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b3a9d07e23193561cc36de24f4c170" id="r_aa6b3a9d07e23193561cc36de24f4c170"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa6b3a9d07e23193561cc36de24f4c170"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa6b3a9d07e23193561cc36de24f4c170">make_ahrens_beylkin_quadrature&lt; 3, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:aa6b3a9d07e23193561cc36de24f4c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0ee26785a3bc761076d8facccd829b" id="r_a8a0ee26785a3bc761076d8facccd829b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8a0ee26785a3bc761076d8facccd829b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8a0ee26785a3bc761076d8facccd829b">make_ahrens_beylkin_quadrature&lt; 3, 3 &gt;</a> (double r)</td></tr>
<tr class="separator:a8a0ee26785a3bc761076d8facccd829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd8281f1316e2815d0aead25f7998fc" id="r_a5cd8281f1316e2815d0aead25f7998fc"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5cd8281f1316e2815d0aead25f7998fc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5cd8281f1316e2815d0aead25f7998fc">make_ahrens_beylkin_quadrature&lt; 5, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a5cd8281f1316e2815d0aead25f7998fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ada44b1af94c90bd16f5985b723b17" id="r_ad4ada44b1af94c90bd16f5985b723b17"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad4ada44b1af94c90bd16f5985b723b17"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad4ada44b1af94c90bd16f5985b723b17">make_ahrens_beylkin_quadrature&lt; 5, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:ad4ada44b1af94c90bd16f5985b723b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8c3d48ee7d5724475292f1d04033d9" id="r_add8c3d48ee7d5724475292f1d04033d9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:add8c3d48ee7d5724475292f1d04033d9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#add8c3d48ee7d5724475292f1d04033d9">make_ahrens_beylkin_quadrature&lt; 5, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:add8c3d48ee7d5724475292f1d04033d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38045c346476fdd7f12b9c9c9693bde" id="r_af38045c346476fdd7f12b9c9c9693bde"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af38045c346476fdd7f12b9c9c9693bde"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af38045c346476fdd7f12b9c9c9693bde">make_ahrens_beylkin_quadrature&lt; 6, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:af38045c346476fdd7f12b9c9c9693bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af315d9743fbf39bb3eb7f35e6a5379ca" id="r_af315d9743fbf39bb3eb7f35e6a5379ca"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af315d9743fbf39bb3eb7f35e6a5379ca"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af315d9743fbf39bb3eb7f35e6a5379ca">make_ahrens_beylkin_quadrature&lt; 6, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:af315d9743fbf39bb3eb7f35e6a5379ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa915356477be794f08fa59a5355f107d" id="r_aa915356477be794f08fa59a5355f107d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa915356477be794f08fa59a5355f107d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa915356477be794f08fa59a5355f107d">make_ahrens_beylkin_quadrature&lt; 6, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:aa915356477be794f08fa59a5355f107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef45947cebf88f221189e34b816e114" id="r_a3ef45947cebf88f221189e34b816e114"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3ef45947cebf88f221189e34b816e114"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3ef45947cebf88f221189e34b816e114">make_ahrens_beylkin_quadrature&lt; 7, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a3ef45947cebf88f221189e34b816e114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5d4f24cf4c14d2fa679656856c1df7" id="r_aaf5d4f24cf4c14d2fa679656856c1df7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaf5d4f24cf4c14d2fa679656856c1df7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aaf5d4f24cf4c14d2fa679656856c1df7">make_ahrens_beylkin_quadrature&lt; 7, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:aaf5d4f24cf4c14d2fa679656856c1df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559624947dea945cceae6bd26332ee16" id="r_a559624947dea945cceae6bd26332ee16"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a559624947dea945cceae6bd26332ee16"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a559624947dea945cceae6bd26332ee16">make_ahrens_beylkin_quadrature&lt; 7, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:a559624947dea945cceae6bd26332ee16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8205ae1721ee304e708b0bd91b9fb3fa" id="r_a8205ae1721ee304e708b0bd91b9fb3fa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8205ae1721ee304e708b0bd91b9fb3fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8205ae1721ee304e708b0bd91b9fb3fa">make_ahrens_beylkin_quadrature&lt; 8, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a8205ae1721ee304e708b0bd91b9fb3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f51bde6789e74f3872948c0d5689d4" id="r_a45f51bde6789e74f3872948c0d5689d4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a45f51bde6789e74f3872948c0d5689d4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a45f51bde6789e74f3872948c0d5689d4">make_ahrens_beylkin_quadrature&lt; 8, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a45f51bde6789e74f3872948c0d5689d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ae222c074784c764febf0defaa4bbe" id="r_a89ae222c074784c764febf0defaa4bbe"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a89ae222c074784c764febf0defaa4bbe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a89ae222c074784c764febf0defaa4bbe">make_ahrens_beylkin_quadrature&lt; 9, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a89ae222c074784c764febf0defaa4bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77426741a6b2dd116f83d365f79d047f" id="r_a77426741a6b2dd116f83d365f79d047f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77426741a6b2dd116f83d365f79d047f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a77426741a6b2dd116f83d365f79d047f">make_ahrens_beylkin_quadrature&lt; 10, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a77426741a6b2dd116f83d365f79d047f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99aa556daa7b865b3ec0d3b7f789b28" id="r_ab99aa556daa7b865b3ec0d3b7f789b28"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab99aa556daa7b865b3ec0d3b7f789b28"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab99aa556daa7b865b3ec0d3b7f789b28">make_ahrens_beylkin_quadrature&lt; 10, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:ab99aa556daa7b865b3ec0d3b7f789b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c1eb6fbe831346575cb15b35e7cd2e" id="r_a81c1eb6fbe831346575cb15b35e7cd2e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a81c1eb6fbe831346575cb15b35e7cd2e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a81c1eb6fbe831346575cb15b35e7cd2e">make_ahrens_beylkin_quadrature&lt; 11, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a81c1eb6fbe831346575cb15b35e7cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70235d60235c026551843bc194080eff" id="r_a70235d60235c026551843bc194080eff"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a70235d60235c026551843bc194080eff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a70235d60235c026551843bc194080eff">make_ahrens_beylkin_quadrature&lt; 11, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a70235d60235c026551843bc194080eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd7d2fe60b1c3c7f9751055615c673" id="r_a3dcd7d2fe60b1c3c7f9751055615c673"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3dcd7d2fe60b1c3c7f9751055615c673"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3dcd7d2fe60b1c3c7f9751055615c673">make_ahrens_beylkin_quadrature&lt; 11, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:a3dcd7d2fe60b1c3c7f9751055615c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0166013ca801782b3b19e5c780fe6a6" id="r_af0166013ca801782b3b19e5c780fe6a6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af0166013ca801782b3b19e5c780fe6a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af0166013ca801782b3b19e5c780fe6a6">make_ahrens_beylkin_quadrature&lt; 12, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:af0166013ca801782b3b19e5c780fe6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794e4d61c1d6afc66145124995bcf6ab" id="r_a794e4d61c1d6afc66145124995bcf6ab"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a794e4d61c1d6afc66145124995bcf6ab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a794e4d61c1d6afc66145124995bcf6ab">make_ahrens_beylkin_quadrature&lt; 13, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a794e4d61c1d6afc66145124995bcf6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28827c6e371022f07dca6bd26b529de5" id="r_a28827c6e371022f07dca6bd26b529de5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a28827c6e371022f07dca6bd26b529de5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a28827c6e371022f07dca6bd26b529de5">make_ahrens_beylkin_quadrature&lt; 13, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a28827c6e371022f07dca6bd26b529de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd0a133b038fcbd85fdc6895f0a62e8" id="r_aadd0a133b038fcbd85fdc6895f0a62e8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aadd0a133b038fcbd85fdc6895f0a62e8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aadd0a133b038fcbd85fdc6895f0a62e8">make_ahrens_beylkin_quadrature&lt; 15, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:aadd0a133b038fcbd85fdc6895f0a62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8109a498476b264c6a47b507de7bc239" id="r_a8109a498476b264c6a47b507de7bc239"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8109a498476b264c6a47b507de7bc239"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8109a498476b264c6a47b507de7bc239">make_ahrens_beylkin_quadrature&lt; 15, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a8109a498476b264c6a47b507de7bc239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86202afd7aefe37642118b5ea7b0c2e" id="r_aa86202afd7aefe37642118b5ea7b0c2e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa86202afd7aefe37642118b5ea7b0c2e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa86202afd7aefe37642118b5ea7b0c2e">make_ahrens_beylkin_quadrature&lt; 16, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:aa86202afd7aefe37642118b5ea7b0c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca616347adbd746018d208a3929004" id="r_a8eca616347adbd746018d208a3929004"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8eca616347adbd746018d208a3929004"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8eca616347adbd746018d208a3929004">make_ahrens_beylkin_quadrature&lt; 16, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a8eca616347adbd746018d208a3929004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77426741a6b2dd116f83d365f79d047f" id="r_a77426741a6b2dd116f83d365f79d047f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77426741a6b2dd116f83d365f79d047f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a77426741a6b2dd116f83d365f79d047f">make_ahrens_beylkin_quadrature&lt; 10, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a77426741a6b2dd116f83d365f79d047f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99aa556daa7b865b3ec0d3b7f789b28" id="r_ab99aa556daa7b865b3ec0d3b7f789b28"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab99aa556daa7b865b3ec0d3b7f789b28"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab99aa556daa7b865b3ec0d3b7f789b28">make_ahrens_beylkin_quadrature&lt; 10, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:ab99aa556daa7b865b3ec0d3b7f789b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c1eb6fbe831346575cb15b35e7cd2e" id="r_a81c1eb6fbe831346575cb15b35e7cd2e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a81c1eb6fbe831346575cb15b35e7cd2e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a81c1eb6fbe831346575cb15b35e7cd2e">make_ahrens_beylkin_quadrature&lt; 11, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a81c1eb6fbe831346575cb15b35e7cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70235d60235c026551843bc194080eff" id="r_a70235d60235c026551843bc194080eff"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a70235d60235c026551843bc194080eff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a70235d60235c026551843bc194080eff">make_ahrens_beylkin_quadrature&lt; 11, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a70235d60235c026551843bc194080eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd7d2fe60b1c3c7f9751055615c673" id="r_a3dcd7d2fe60b1c3c7f9751055615c673"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3dcd7d2fe60b1c3c7f9751055615c673"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3dcd7d2fe60b1c3c7f9751055615c673">make_ahrens_beylkin_quadrature&lt; 11, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:a3dcd7d2fe60b1c3c7f9751055615c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0166013ca801782b3b19e5c780fe6a6" id="r_af0166013ca801782b3b19e5c780fe6a6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af0166013ca801782b3b19e5c780fe6a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af0166013ca801782b3b19e5c780fe6a6">make_ahrens_beylkin_quadrature&lt; 12, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:af0166013ca801782b3b19e5c780fe6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794e4d61c1d6afc66145124995bcf6ab" id="r_a794e4d61c1d6afc66145124995bcf6ab"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a794e4d61c1d6afc66145124995bcf6ab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a794e4d61c1d6afc66145124995bcf6ab">make_ahrens_beylkin_quadrature&lt; 13, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a794e4d61c1d6afc66145124995bcf6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28827c6e371022f07dca6bd26b529de5" id="r_a28827c6e371022f07dca6bd26b529de5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a28827c6e371022f07dca6bd26b529de5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a28827c6e371022f07dca6bd26b529de5">make_ahrens_beylkin_quadrature&lt; 13, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a28827c6e371022f07dca6bd26b529de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd0a133b038fcbd85fdc6895f0a62e8" id="r_aadd0a133b038fcbd85fdc6895f0a62e8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aadd0a133b038fcbd85fdc6895f0a62e8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aadd0a133b038fcbd85fdc6895f0a62e8">make_ahrens_beylkin_quadrature&lt; 15, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:aadd0a133b038fcbd85fdc6895f0a62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8109a498476b264c6a47b507de7bc239" id="r_a8109a498476b264c6a47b507de7bc239"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8109a498476b264c6a47b507de7bc239"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8109a498476b264c6a47b507de7bc239">make_ahrens_beylkin_quadrature&lt; 15, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a8109a498476b264c6a47b507de7bc239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86202afd7aefe37642118b5ea7b0c2e" id="r_aa86202afd7aefe37642118b5ea7b0c2e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa86202afd7aefe37642118b5ea7b0c2e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa86202afd7aefe37642118b5ea7b0c2e">make_ahrens_beylkin_quadrature&lt; 16, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:aa86202afd7aefe37642118b5ea7b0c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca616347adbd746018d208a3929004" id="r_a8eca616347adbd746018d208a3929004"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8eca616347adbd746018d208a3929004"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8eca616347adbd746018d208a3929004">make_ahrens_beylkin_quadrature&lt; 16, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a8eca616347adbd746018d208a3929004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b948bc27e54817c4f77b7ed399c90a" id="r_a97b948bc27e54817c4f77b7ed399c90a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a97b948bc27e54817c4f77b7ed399c90a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a97b948bc27e54817c4f77b7ed399c90a">make_ahrens_beylkin_quadrature&lt; 1, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a97b948bc27e54817c4f77b7ed399c90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66735561c4852148e9a98a960a7c5f9" id="r_af66735561c4852148e9a98a960a7c5f9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af66735561c4852148e9a98a960a7c5f9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af66735561c4852148e9a98a960a7c5f9">make_ahrens_beylkin_quadrature&lt; 2, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:af66735561c4852148e9a98a960a7c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7595902a76f8f83bdfff003cf5015d" id="r_ace7595902a76f8f83bdfff003cf5015d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ace7595902a76f8f83bdfff003cf5015d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ace7595902a76f8f83bdfff003cf5015d">make_ahrens_beylkin_quadrature&lt; 2, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:ace7595902a76f8f83bdfff003cf5015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1418c5950a39359917965b53edf06e94" id="r_a1418c5950a39359917965b53edf06e94"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1418c5950a39359917965b53edf06e94"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a1418c5950a39359917965b53edf06e94">make_ahrens_beylkin_quadrature&lt; 2, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:a1418c5950a39359917965b53edf06e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f885d449ababbac758b1f7dd9f5b582" id="r_a6f885d449ababbac758b1f7dd9f5b582"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6f885d449ababbac758b1f7dd9f5b582"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6f885d449ababbac758b1f7dd9f5b582">make_ahrens_beylkin_quadrature&lt; 2, 3 &gt;</a> (double r)</td></tr>
<tr class="separator:a6f885d449ababbac758b1f7dd9f5b582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30294d12dd1054fec2caf73d9e7db600" id="r_a30294d12dd1054fec2caf73d9e7db600"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a30294d12dd1054fec2caf73d9e7db600"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a30294d12dd1054fec2caf73d9e7db600">make_ahrens_beylkin_quadrature&lt; 2, 4 &gt;</a> (double r)</td></tr>
<tr class="separator:a30294d12dd1054fec2caf73d9e7db600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac9f83924bbb9d00190dbedb81f8f3a" id="r_acac9f83924bbb9d00190dbedb81f8f3a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acac9f83924bbb9d00190dbedb81f8f3a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#acac9f83924bbb9d00190dbedb81f8f3a">make_ahrens_beylkin_quadrature&lt; 3, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:acac9f83924bbb9d00190dbedb81f8f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76646641e2c64e167173f20a63c69918" id="r_a76646641e2c64e167173f20a63c69918"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a76646641e2c64e167173f20a63c69918"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a76646641e2c64e167173f20a63c69918">make_ahrens_beylkin_quadrature&lt; 3, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a76646641e2c64e167173f20a63c69918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b3a9d07e23193561cc36de24f4c170" id="r_aa6b3a9d07e23193561cc36de24f4c170"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa6b3a9d07e23193561cc36de24f4c170"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa6b3a9d07e23193561cc36de24f4c170">make_ahrens_beylkin_quadrature&lt; 3, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:aa6b3a9d07e23193561cc36de24f4c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0ee26785a3bc761076d8facccd829b" id="r_a8a0ee26785a3bc761076d8facccd829b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8a0ee26785a3bc761076d8facccd829b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8a0ee26785a3bc761076d8facccd829b">make_ahrens_beylkin_quadrature&lt; 3, 3 &gt;</a> (double r)</td></tr>
<tr class="separator:a8a0ee26785a3bc761076d8facccd829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd8281f1316e2815d0aead25f7998fc" id="r_a5cd8281f1316e2815d0aead25f7998fc"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5cd8281f1316e2815d0aead25f7998fc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5cd8281f1316e2815d0aead25f7998fc">make_ahrens_beylkin_quadrature&lt; 5, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a5cd8281f1316e2815d0aead25f7998fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ada44b1af94c90bd16f5985b723b17" id="r_ad4ada44b1af94c90bd16f5985b723b17"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad4ada44b1af94c90bd16f5985b723b17"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad4ada44b1af94c90bd16f5985b723b17">make_ahrens_beylkin_quadrature&lt; 5, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:ad4ada44b1af94c90bd16f5985b723b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8c3d48ee7d5724475292f1d04033d9" id="r_add8c3d48ee7d5724475292f1d04033d9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:add8c3d48ee7d5724475292f1d04033d9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#add8c3d48ee7d5724475292f1d04033d9">make_ahrens_beylkin_quadrature&lt; 5, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:add8c3d48ee7d5724475292f1d04033d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38045c346476fdd7f12b9c9c9693bde" id="r_af38045c346476fdd7f12b9c9c9693bde"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af38045c346476fdd7f12b9c9c9693bde"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af38045c346476fdd7f12b9c9c9693bde">make_ahrens_beylkin_quadrature&lt; 6, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:af38045c346476fdd7f12b9c9c9693bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af315d9743fbf39bb3eb7f35e6a5379ca" id="r_af315d9743fbf39bb3eb7f35e6a5379ca"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af315d9743fbf39bb3eb7f35e6a5379ca"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af315d9743fbf39bb3eb7f35e6a5379ca">make_ahrens_beylkin_quadrature&lt; 6, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:af315d9743fbf39bb3eb7f35e6a5379ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa915356477be794f08fa59a5355f107d" id="r_aa915356477be794f08fa59a5355f107d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa915356477be794f08fa59a5355f107d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa915356477be794f08fa59a5355f107d">make_ahrens_beylkin_quadrature&lt; 6, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:aa915356477be794f08fa59a5355f107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef45947cebf88f221189e34b816e114" id="r_a3ef45947cebf88f221189e34b816e114"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3ef45947cebf88f221189e34b816e114"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3ef45947cebf88f221189e34b816e114">make_ahrens_beylkin_quadrature&lt; 7, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a3ef45947cebf88f221189e34b816e114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5d4f24cf4c14d2fa679656856c1df7" id="r_aaf5d4f24cf4c14d2fa679656856c1df7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaf5d4f24cf4c14d2fa679656856c1df7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aaf5d4f24cf4c14d2fa679656856c1df7">make_ahrens_beylkin_quadrature&lt; 7, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:aaf5d4f24cf4c14d2fa679656856c1df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559624947dea945cceae6bd26332ee16" id="r_a559624947dea945cceae6bd26332ee16"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a559624947dea945cceae6bd26332ee16"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a559624947dea945cceae6bd26332ee16">make_ahrens_beylkin_quadrature&lt; 7, 2 &gt;</a> (double r)</td></tr>
<tr class="separator:a559624947dea945cceae6bd26332ee16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8205ae1721ee304e708b0bd91b9fb3fa" id="r_a8205ae1721ee304e708b0bd91b9fb3fa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8205ae1721ee304e708b0bd91b9fb3fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8205ae1721ee304e708b0bd91b9fb3fa">make_ahrens_beylkin_quadrature&lt; 8, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a8205ae1721ee304e708b0bd91b9fb3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f51bde6789e74f3872948c0d5689d4" id="r_a45f51bde6789e74f3872948c0d5689d4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a45f51bde6789e74f3872948c0d5689d4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a45f51bde6789e74f3872948c0d5689d4">make_ahrens_beylkin_quadrature&lt; 8, 1 &gt;</a> (double r)</td></tr>
<tr class="separator:a45f51bde6789e74f3872948c0d5689d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ae222c074784c764febf0defaa4bbe" id="r_a89ae222c074784c764febf0defaa4bbe"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a89ae222c074784c764febf0defaa4bbe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a89ae222c074784c764febf0defaa4bbe">make_ahrens_beylkin_quadrature&lt; 9, 0 &gt;</a> (double r)</td></tr>
<tr class="separator:a89ae222c074784c764febf0defaa4bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36abffc93af1514a989f45f298e9535" id="r_af36abffc93af1514a989f45f298e9535"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af36abffc93af1514a989f45f298e9535">gauss_legendre</a> (int N, double a=0, double b=1)</td></tr>
<tr class="memdesc:af36abffc93af1514a989f45f298e9535"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function uses orthogonal polynomial approach for obtaining quadrature roots and weights. Taken from paper: Gaussian Quadrature and the Eigenvalue Problem by John A. Gubner. <a href="http://gubner.ece.wisc.edu/gaussquad.pdf">http://gubner.ece.wisc.edu/gaussquad.pdf</a> The code is outlined at Example 15: Legendre polynomials  <br /></td></tr>
<tr class="separator:af36abffc93af1514a989f45f298e9535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7278fd754ee906264b5dad58173688" id="r_a5f7278fd754ee906264b5dad58173688"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f7278fd754ee906264b5dad58173688"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5f7278fd754ee906264b5dad58173688">tile_to_eigen</a> (TA::Tensor&lt; T &gt; const &amp;t)</td></tr>
<tr class="separator:a5f7278fd754ee906264b5dad58173688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad09d001540cb6ed7bc4978a4c376ce" id="r_a0ad09d001540cb6ed7bc4978a4c376ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ad09d001540cb6ed7bc4978a4c376ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a0ad09d001540cb6ed7bc4978a4c376ce">tile_to_eigen</a> (TA::Tile&lt; <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &gt; const &amp;t)</td></tr>
<tr class="separator:a0ad09d001540cb6ed7bc4978a4c376ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecdfb5b97ed5ba504e56aa9cfbe6fe4" id="r_adecdfb5b97ed5ba504e56aa9cfbe6fe4"><td class="memTemplParams" colspan="2">template&lt;unsigned int EigenStorageOrder = Eigen::RowMajor, typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:adecdfb5b97ed5ba504e56aa9cfbe6fe4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#adecdfb5b97ed5ba504e56aa9cfbe6fe4">array_to_eigen</a> (TA::DistArray&lt; Tile, Policy &gt; const &amp;A)</td></tr>
<tr class="memdesc:adecdfb5b97ed5ba504e56aa9cfbe6fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a TA::DistArray to an Eigen::Matrix, replicating the input matrix if needed  <br /></td></tr>
<tr class="separator:adecdfb5b97ed5ba504e56aa9cfbe6fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2110a15aceb826940596c8ac6a80a1" id="r_a0c2110a15aceb826940596c8ac6a80a1"><td class="memTemplParams" colspan="2">template&lt;unsigned int EigenStorageOrder = Eigen::RowMajor, typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a0c2110a15aceb826940596c8ac6a80a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a0c2110a15aceb826940596c8ac6a80a1">array_to_eigen</a> (TA::DistArrayVector&lt; Tile, Policy &gt; const &amp;A)</td></tr>
<tr class="memdesc:a0c2110a15aceb826940596c8ac6a80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a TA::DistArrayVector to an Eigen::Matrix  <br /></td></tr>
<tr class="separator:a0c2110a15aceb826940596c8ac6a80a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedffc767918748a2201ed2c953c5ad48" id="r_aedffc767918748a2201ed2c953c5ad48"><td class="memTemplParams" colspan="2">template&lt;typename EigenTensor , typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:aedffc767918748a2201ed2c953c5ad48"><td class="memTemplItemLeft" align="right" valign="top">EigenTensor&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aedffc767918748a2201ed2c953c5ad48">array_to_eigen_tensor</a> (TA::DistArray&lt; Tile, Policy &gt; const &amp;A)</td></tr>
<tr class="memdesc:aedffc767918748a2201ed2c953c5ad48"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a TA::DistArray to an Eigen::Tensor  <br /></td></tr>
<tr class="separator:aedffc767918748a2201ed2c953c5ad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d22b534e33a880c9983def797b0928" id="r_a08d22b534e33a880c9983def797b0928"><td class="memTemplParams" colspan="2">template&lt;typename EigenTensor , typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a08d22b534e33a880c9983def797b0928"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; EigenTensor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a08d22b534e33a880c9983def797b0928">array_to_eigen_tensor</a> (TA::DistArrayVector&lt; Tile, Policy &gt; const &amp;A)</td></tr>
<tr class="memdesc:a08d22b534e33a880c9983def797b0928"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a TA::DistArrayVector to a vector of Eigen::Tensor objects  <br /></td></tr>
<tr class="separator:a08d22b534e33a880c9983def797b0928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e58c3d48bb9f9135f02a85fc3efaeb" id="r_a67e58c3d48bb9f9135f02a85fc3efaeb"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a67e58c3d48bb9f9135f02a85fc3efaeb"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a67e58c3d48bb9f9135f02a85fc3efaeb">eigen_to_array</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a>&lt; typename Tile::numeric_type &gt; const &amp;M, TA::TiledRange1 tr0, TA::TiledRange1 tr1, double cut=1e-7)</td></tr>
<tr class="separator:a67e58c3d48bb9f9135f02a85fc3efaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3725bcfb4af1fb6e934aee66f1a850ff" id="r_a3725bcfb4af1fb6e934aee66f1a850ff"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a3725bcfb4af1fb6e934aee66f1a850ff"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::DensePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3725bcfb4af1fb6e934aee66f1a850ff">eigen_to_array</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a>&lt; typename Tile::numeric_type &gt; const &amp;M, TA::TiledRange1 tr0, TA::TiledRange1 tr1, double cut=1e-7)</td></tr>
<tr class="separator:a3725bcfb4af1fb6e934aee66f1a850ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fefc7e931dbb2c94c9702b7b36d86c" id="r_af0fefc7e931dbb2c94c9702b7b36d86c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0fefc7e931dbb2c94c9702b7b36d86c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#af0fefc7e931dbb2c94c9702b7b36d86c">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="separator:af0fefc7e931dbb2c94c9702b7b36d86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1dc8a634d38ea36f095ff65628a8d1" id="r_a1e1dc8a634d38ea36f095ff65628a8d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e1dc8a634d38ea36f095ff65628a8d1"><td class="memTemplItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a1e1dc8a634d38ea36f095ff65628a8d1">tile_clr_storage</a> (TiledArray::Tile&lt; math::DecomposedTensor&lt; T &gt; &gt; const &amp;tile)</td></tr>
<tr class="separator:a1e1dc8a634d38ea36f095ff65628a8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fea7d68962a3c8e90818b4eecfd0fd" id="r_ac6fea7d68962a3c8e90818b4eecfd0fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6fea7d68962a3c8e90818b4eecfd0fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ac6fea7d68962a3c8e90818b4eecfd0fd">add_order2</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, T factor)</td></tr>
<tr class="separator:ac6fea7d68962a3c8e90818b4eecfd0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aba79a53ebd4c43df289744b48d7b6" id="r_a84aba79a53ebd4c43df289744b48d7b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84aba79a53ebd4c43df289744b48d7b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a84aba79a53ebd4c43df289744b48d7b6">add</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r)</td></tr>
<tr class="separator:a84aba79a53ebd4c43df289744b48d7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6478c75a4a7eb210deb28fc8149dab5e" id="r_a6478c75a4a7eb210deb28fc8149dab5e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a6478c75a4a7eb210deb28fc8149dab5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6478c75a4a7eb210deb28fc8149dab5e">add</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, Perm const &amp;p)</td></tr>
<tr class="separator:a6478c75a4a7eb210deb28fc8149dab5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b7e6969ad600828afca08b6444cb7d" id="r_ac5b7e6969ad600828afca08b6444cb7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5b7e6969ad600828afca08b6444cb7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ac5b7e6969ad600828afca08b6444cb7d">add</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, const T factor)</td></tr>
<tr class="separator:ac5b7e6969ad600828afca08b6444cb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578e5805b08457c4b25ff5539cc181c6" id="r_a578e5805b08457c4b25ff5539cc181c6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a578e5805b08457c4b25ff5539cc181c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a578e5805b08457c4b25ff5539cc181c6">add</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, const T factor, Perm const &amp;p)</td></tr>
<tr class="separator:a578e5805b08457c4b25ff5539cc181c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac9a138d8619ca458c2a9fa966c9fc7" id="r_aaac9a138d8619ca458c2a9fa966c9fc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaac9a138d8619ca458c2a9fa966c9fc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aaac9a138d8619ca458c2a9fa966c9fc7">add</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, const T factor)</td></tr>
<tr class="separator:aaac9a138d8619ca458c2a9fa966c9fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1e0923f25b69d295db8485ae8d6753" id="r_aff1e0923f25b69d295db8485ae8d6753"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:aff1e0923f25b69d295db8485ae8d6753"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aff1e0923f25b69d295db8485ae8d6753">add</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, const T factor, Perm const &amp;p)</td></tr>
<tr class="separator:aff1e0923f25b69d295db8485ae8d6753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b2222cb6ddaf591d8b2056908179af" id="r_aa5b2222cb6ddaf591d8b2056908179af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5b2222cb6ddaf591d8b2056908179af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa5b2222cb6ddaf591d8b2056908179af">add_to_order2</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r)</td></tr>
<tr class="separator:aa5b2222cb6ddaf591d8b2056908179af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612763b586f527bd3a1a49aaa79f1181" id="r_a612763b586f527bd3a1a49aaa79f1181"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a612763b586f527bd3a1a49aaa79f1181"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a612763b586f527bd3a1a49aaa79f1181">add_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r)</td></tr>
<tr class="separator:a612763b586f527bd3a1a49aaa79f1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08870cd4cffc684cc33a9e7e10337ca" id="r_ae08870cd4cffc684cc33a9e7e10337ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae08870cd4cffc684cc33a9e7e10337ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ae08870cd4cffc684cc33a9e7e10337ca">add_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, const T factor)</td></tr>
<tr class="separator:ae08870cd4cffc684cc33a9e7e10337ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5154d83ad62aa2ebd2c2d3ff0a15f7a7" id="r_a5154d83ad62aa2ebd2c2d3ff0a15f7a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5154d83ad62aa2ebd2c2d3ff0a15f7a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5154d83ad62aa2ebd2c2d3ff0a15f7a7">add_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, const T factor)</td></tr>
<tr class="separator:a5154d83ad62aa2ebd2c2d3ff0a15f7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae9e3e14bd0c3b64846a9ca5f7c740d" id="r_a8ae9e3e14bd0c3b64846a9ca5f7c740d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8ae9e3e14bd0c3b64846a9ca5f7c740d">recompress</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; &amp;t)</td></tr>
<tr class="memdesc:a8ae9e3e14bd0c3b64846a9ca5f7c740d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently modifies input data regardless could cause some loss of accuracy.  <br /></td></tr>
<tr class="separator:a8ae9e3e14bd0c3b64846a9ca5f7c740d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee6fbfc9b98b223f3148940a1fdbb6a" id="r_a7ee6fbfc9b98b223f3148940a1fdbb6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a7ee6fbfc9b98b223f3148940a1fdbb6a">two_way_decomposition</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; const &amp;t)</td></tr>
<tr class="memdesc:a7ee6fbfc9b98b223f3148940a1fdbb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an empty <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a> if the compression rank was to large.  <br /></td></tr>
<tr class="separator:a7ee6fbfc9b98b223f3148940a1fdbb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a90afdbee5f7409d3327e6103c434f" id="r_a93a90afdbee5f7409d3327e6103c434f"><td class="memItemLeft" align="right" valign="top">TA::Tensor&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a93a90afdbee5f7409d3327e6103c434f">combine</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; const &amp;t)</td></tr>
<tr class="separator:a93a90afdbee5f7409d3327e6103c434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf1607661b44ab7ab5cd8e6899c5ca7" id="r_abaf1607661b44ab7ab5cd8e6899c5ca7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abaf1607661b44ab7ab5cd8e6899c5ca7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#abaf1607661b44ab7ab5cd8e6899c5ca7">piv_cholesky_impl</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;a)</td></tr>
<tr class="separator:abaf1607661b44ab7ab5cd8e6899c5ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae821586386728dfef606d69fc81a2d75" id="r_ae821586386728dfef606d69fc81a2d75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ae821586386728dfef606d69fc81a2d75">piv_cholesky</a> (Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;a)</td></tr>
<tr class="memdesc:ae821586386728dfef606d69fc81a2d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the pivoted Cholesky decomposition  <br /></td></tr>
<tr class="separator:ae821586386728dfef606d69fc81a2d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1a19cd96e43a1619f5d8c1b5a090b2" id="r_adb1a19cd96e43a1619f5d8c1b5a090b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#adb1a19cd96e43a1619f5d8c1b5a090b2">piv_cholesky</a> (Eigen::Matrix&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;a)</td></tr>
<tr class="memdesc:adb1a19cd96e43a1619f5d8c1b5a090b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the pivoted Cholesky decomposition  <br /></td></tr>
<tr class="separator:adb1a19cd96e43a1619f5d8c1b5a090b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dc595b553837a622ebc88b793291f6" id="r_aa7dc595b553837a622ebc88b793291f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Op &gt; </td></tr>
<tr class="memitem:aa7dc595b553837a622ebc88b793291f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa7dc595b553837a622ebc88b793291f6">binary</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, Op &amp;&amp;op)</td></tr>
<tr class="separator:aa7dc595b553837a622ebc88b793291f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d9d38ac0ba2f62898d4990cd5182fb" id="r_a77d9d38ac0ba2f62898d4990cd5182fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Op , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a77d9d38ac0ba2f62898d4990cd5182fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a77d9d38ac0ba2f62898d4990cd5182fb">binary</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, Op &amp;&amp;op, Perm const &amp;p)</td></tr>
<tr class="separator:a77d9d38ac0ba2f62898d4990cd5182fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6763f49fbc5df118acb0e70f0d13220" id="r_ac6763f49fbc5df118acb0e70f0d13220"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Op &gt; </td></tr>
<tr class="memitem:ac6763f49fbc5df118acb0e70f0d13220"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ac6763f49fbc5df118acb0e70f0d13220">inplace_binary</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, Op &amp;&amp;op)</td></tr>
<tr class="separator:ac6763f49fbc5df118acb0e70f0d13220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab977cbde2e8c2793562f7a6a405715eb" id="r_ab977cbde2e8c2793562f7a6a405715eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab977cbde2e8c2793562f7a6a405715eb"><td class="memTemplItemLeft" align="right" valign="top">TA::TensorD&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab977cbde2e8c2793562f7a6a405715eb">gemm</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;a, TA::TensorD const &amp;b, const T factor, TA::math::GemmHelper const &amp;gh)</td></tr>
<tr class="separator:ab977cbde2e8c2793562f7a6a405715eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb79c0f1088481f835ae1c0dd24930f" id="r_a2eb79c0f1088481f835ae1c0dd24930f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2eb79c0f1088481f835ae1c0dd24930f"><td class="memTemplItemLeft" align="right" valign="top">TA::TensorD&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a2eb79c0f1088481f835ae1c0dd24930f">gemm</a> (TA::TensorD &amp;c, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;a, TA::TensorD const &amp;b, const T factor, TA::math::GemmHelper const &amp;gh)</td></tr>
<tr class="separator:a2eb79c0f1088481f835ae1c0dd24930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5701fb7809f62251ec565822cf04b0e9" id="r_a5701fb7809f62251ec565822cf04b0e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5701fb7809f62251ec565822cf04b0e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5701fb7809f62251ec565822cf04b0e9">gemm</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;a, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;b, const T factor, TA::math::GemmHelper const &amp;gh)</td></tr>
<tr class="separator:a5701fb7809f62251ec565822cf04b0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222a9e0202d4e8d84e2c8f52a48607aa" id="r_a222a9e0202d4e8d84e2c8f52a48607aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a222a9e0202d4e8d84e2c8f52a48607aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a222a9e0202d4e8d84e2c8f52a48607aa">gemm</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;c, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;a, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;b, const T factor, TA::math::GemmHelper const &amp;gh)</td></tr>
<tr class="separator:a222a9e0202d4e8d84e2c8f52a48607aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10d576dae7c565485694ff942d8b80f" id="r_aa10d576dae7c565485694ff942d8b80f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa10d576dae7c565485694ff942d8b80f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa10d576dae7c565485694ff942d8b80f">mult</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r)</td></tr>
<tr class="separator:aa10d576dae7c565485694ff942d8b80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb888a534b96627bb7871d47e94cce9" id="r_a3cb888a534b96627bb7871d47e94cce9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a3cb888a534b96627bb7871d47e94cce9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3cb888a534b96627bb7871d47e94cce9">mult</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, Perm const &amp;p)</td></tr>
<tr class="separator:a3cb888a534b96627bb7871d47e94cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41f77a7faf67dff56e494d30d341127" id="r_ad41f77a7faf67dff56e494d30d341127"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ad41f77a7faf67dff56e494d30d341127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad41f77a7faf67dff56e494d30d341127">mult</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, Perm const &amp;p, const T factor)</td></tr>
<tr class="separator:ad41f77a7faf67dff56e494d30d341127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822900574da2e99a826a68c6426084a8" id="r_a822900574da2e99a826a68c6426084a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a822900574da2e99a826a68c6426084a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a822900574da2e99a826a68c6426084a8">mult</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, const T factor)</td></tr>
<tr class="separator:a822900574da2e99a826a68c6426084a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6e3d336a7a1e4ec9415e23d13ee275" id="r_a5d6e3d336a7a1e4ec9415e23d13ee275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d6e3d336a7a1e4ec9415e23d13ee275"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5d6e3d336a7a1e4ec9415e23d13ee275">mult_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r)</td></tr>
<tr class="separator:a5d6e3d336a7a1e4ec9415e23d13ee275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b274fa8bb4dab60d8ae2ac65e427cc" id="r_a16b274fa8bb4dab60d8ae2ac65e427cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16b274fa8bb4dab60d8ae2ac65e427cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a16b274fa8bb4dab60d8ae2ac65e427cc">mult_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, const T factor)</td></tr>
<tr class="separator:a16b274fa8bb4dab60d8ae2ac65e427cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34293f57f3a722c20e97d155e58ff977" id="r_a34293f57f3a722c20e97d155e58ff977"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34293f57f3a722c20e97d155e58ff977"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a34293f57f3a722c20e97d155e58ff977">subt</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r)</td></tr>
<tr class="separator:a34293f57f3a722c20e97d155e58ff977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3f44b2ee27cd01e7d99fb5654885e4" id="r_a3e3f44b2ee27cd01e7d99fb5654885e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a3e3f44b2ee27cd01e7d99fb5654885e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a3e3f44b2ee27cd01e7d99fb5654885e4">subt</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, Perm const &amp;p)</td></tr>
<tr class="separator:a3e3f44b2ee27cd01e7d99fb5654885e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15af7f616bc6e9dd606c590a719eb79a" id="r_a15af7f616bc6e9dd606c590a719eb79a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15af7f616bc6e9dd606c590a719eb79a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a15af7f616bc6e9dd606c590a719eb79a">subt</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, const T factor)</td></tr>
<tr class="separator:a15af7f616bc6e9dd606c590a719eb79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328a1a60f3bba646234ec5c7cb454bac" id="r_a328a1a60f3bba646234ec5c7cb454bac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a328a1a60f3bba646234ec5c7cb454bac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a328a1a60f3bba646234ec5c7cb454bac">subt</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, const T factor, Perm const &amp;p)</td></tr>
<tr class="separator:a328a1a60f3bba646234ec5c7cb454bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c59203a7674df4a74bc03fe5924ff8a" id="r_a7c59203a7674df4a74bc03fe5924ff8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c59203a7674df4a74bc03fe5924ff8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a7c59203a7674df4a74bc03fe5924ff8a">subt</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, const T factor)</td></tr>
<tr class="separator:a7c59203a7674df4a74bc03fe5924ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a0503deb893c6525af47f73c18719f" id="r_a03a0503deb893c6525af47f73c18719f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a03a0503deb893c6525af47f73c18719f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a03a0503deb893c6525af47f73c18719f">subt</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, const T factor, Perm const &amp;p)</td></tr>
<tr class="separator:a03a0503deb893c6525af47f73c18719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedff73a4e29b5c25bfa4527f59651f1" id="r_aeedff73a4e29b5c25bfa4527f59651f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeedff73a4e29b5c25bfa4527f59651f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aeedff73a4e29b5c25bfa4527f59651f1">subt_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r)</td></tr>
<tr class="separator:aeedff73a4e29b5c25bfa4527f59651f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541dfc1e7c9e2bbff00ef26b27a7efd4" id="r_a541dfc1e7c9e2bbff00ef26b27a7efd4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a541dfc1e7c9e2bbff00ef26b27a7efd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a541dfc1e7c9e2bbff00ef26b27a7efd4">subt_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;r, const F factor)</td></tr>
<tr class="separator:a541dfc1e7c9e2bbff00ef26b27a7efd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36919ca904005463640918e389f8045" id="r_ab36919ca904005463640918e389f8045"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab36919ca904005463640918e389f8045"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab36919ca904005463640918e389f8045">subt_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, const T factor)</td></tr>
<tr class="separator:ab36919ca904005463640918e389f8045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6375b84e55fed80731686d5155136702" id="r_a6375b84e55fed80731686d5155136702"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6375b84e55fed80731686d5155136702"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6375b84e55fed80731686d5155136702">trace</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a6375b84e55fed80731686d5155136702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of a decompose tensor Currently not recommended due to implementation details.  <br /></td></tr>
<tr class="separator:a6375b84e55fed80731686d5155136702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb0a75c1f0d66f6492c11dd9abb42da" id="r_adfb0a75c1f0d66f6492c11dd9abb42da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfb0a75c1f0d66f6492c11dd9abb42da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#adfb0a75c1f0d66f6492c11dd9abb42da">sum</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:adfb0a75c1f0d66f6492c11dd9abb42da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of a decomposed tensor tile Currently not recommended due to implementation details.  <br /></td></tr>
<tr class="separator:adfb0a75c1f0d66f6492c11dd9abb42da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acada6b831f29eff14383b95ef70b139d" id="r_acada6b831f29eff14383b95ef70b139d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acada6b831f29eff14383b95ef70b139d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#acada6b831f29eff14383b95ef70b139d">min</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:acada6b831f29eff14383b95ef70b139d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the min of a decomposed tensor tile Currently not recommended due to implementation details.  <br /></td></tr>
<tr class="separator:acada6b831f29eff14383b95ef70b139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81e7a4a6cbfebe5b799ef5d68800682" id="r_aa81e7a4a6cbfebe5b799ef5d68800682"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa81e7a4a6cbfebe5b799ef5d68800682"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aa81e7a4a6cbfebe5b799ef5d68800682">max</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:aa81e7a4a6cbfebe5b799ef5d68800682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max of a decomposed tensor tile Currently not recommended due to implementation details.  <br /></td></tr>
<tr class="separator:aa81e7a4a6cbfebe5b799ef5d68800682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93e6038f3f2fb755f1d700e1e622c0d" id="r_ac93e6038f3f2fb755f1d700e1e622c0d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac93e6038f3f2fb755f1d700e1e622c0d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ac93e6038f3f2fb755f1d700e1e622c0d">abs_min</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:ac93e6038f3f2fb755f1d700e1e622c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the abs_min of a decomposed tensor tile Currently not recommended due to implementation details.  <br /></td></tr>
<tr class="separator:ac93e6038f3f2fb755f1d700e1e622c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d004e186b17199f7bd5cc8d94330edd" id="r_a8d004e186b17199f7bd5cc8d94330edd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d004e186b17199f7bd5cc8d94330edd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8d004e186b17199f7bd5cc8d94330edd">abs_max</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a8d004e186b17199f7bd5cc8d94330edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the abs_max of a decomposed tensor tile Currently not recommended due to implementation details.  <br /></td></tr>
<tr class="separator:a8d004e186b17199f7bd5cc8d94330edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6095b7c5088dc95df5bd4df9ffe35d5a" id="r_a6095b7c5088dc95df5bd4df9ffe35d5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6095b7c5088dc95df5bd4df9ffe35d5a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6095b7c5088dc95df5bd4df9ffe35d5a">product</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a6095b7c5088dc95df5bd4df9ffe35d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of a decomposed tensor tile Currently not recommended due to implementation details.  <br /></td></tr>
<tr class="separator:a6095b7c5088dc95df5bd4df9ffe35d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707064a27f36933c153e53aad7a31096" id="r_a707064a27f36933c153e53aad7a31096"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a707064a27f36933c153e53aad7a31096"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a707064a27f36933c153e53aad7a31096">norm</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="separator:a707064a27f36933c153e53aad7a31096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81770c4f45043cd8b38c1993fa865b13" id="r_a81770c4f45043cd8b38c1993fa865b13"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:a81770c4f45043cd8b38c1993fa865b13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a81770c4f45043cd8b38c1993fa865b13">norm</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t, R &amp;result)</td></tr>
<tr class="separator:a81770c4f45043cd8b38c1993fa865b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211cd76971a4a199641f6c7048ad3741" id="r_a211cd76971a4a199641f6c7048ad3741"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a211cd76971a4a199641f6c7048ad3741"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a211cd76971a4a199641f6c7048ad3741">squared_norm</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="separator:a211cd76971a4a199641f6c7048ad3741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8172076f2311a110904e3be3cbba6de2" id="r_a8172076f2311a110904e3be3cbba6de2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a8172076f2311a110904e3be3cbba6de2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a8172076f2311a110904e3be3cbba6de2">permute</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t, Perm const &amp;p)</td></tr>
<tr class="separator:a8172076f2311a110904e3be3cbba6de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaa169f663b592bda15a383ea916097" id="r_a0aaa169f663b592bda15a383ea916097"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0aaa169f663b592bda15a383ea916097"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a0aaa169f663b592bda15a383ea916097">clone</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="separator:a0aaa169f663b592bda15a383ea916097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8920d2da6639901c0e950d64fa60593" id="r_ad8920d2da6639901c0e950d64fa60593"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ad8920d2da6639901c0e950d64fa60593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ad8920d2da6639901c0e950d64fa60593">scale</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t, F factor)</td></tr>
<tr class="separator:ad8920d2da6639901c0e950d64fa60593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad0139d484ffa7058dc33efafcdd2da" id="r_a7ad0139d484ffa7058dc33efafcdd2da"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a7ad0139d484ffa7058dc33efafcdd2da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a7ad0139d484ffa7058dc33efafcdd2da">scale</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t, F factor, Perm const &amp;p)</td></tr>
<tr class="separator:a7ad0139d484ffa7058dc33efafcdd2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7357cfcdf5baa03d9c5653213e2f539d" id="r_a7357cfcdf5baa03d9c5653213e2f539d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7357cfcdf5baa03d9c5653213e2f539d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a7357cfcdf5baa03d9c5653213e2f539d">neg</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="separator:a7357cfcdf5baa03d9c5653213e2f539d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae313f038e6c0631123fbbc40b18d8c7" id="r_aae313f038e6c0631123fbbc40b18d8c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:aae313f038e6c0631123fbbc40b18d8c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aae313f038e6c0631123fbbc40b18d8c7">neg</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t, Perm const &amp;p)</td></tr>
<tr class="separator:aae313f038e6c0631123fbbc40b18d8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b137756d0c22a809987f46d1c583259" id="r_a0b137756d0c22a809987f46d1c583259"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a0b137756d0c22a809987f46d1c583259"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a0b137756d0c22a809987f46d1c583259">neg_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;t, Perm const &amp;p)</td></tr>
<tr class="separator:a0b137756d0c22a809987f46d1c583259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf517f32d776fd6016b7ea222d6302" id="r_a6fbf517f32d776fd6016b7ea222d6302"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fbf517f32d776fd6016b7ea222d6302"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6fbf517f32d776fd6016b7ea222d6302">neg_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:a6fbf517f32d776fd6016b7ea222d6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682278b1856ce075dd891653e6efb64a" id="r_a682278b1856ce075dd891653e6efb64a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a682278b1856ce075dd891653e6efb64a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a682278b1856ce075dd891653e6efb64a">scale_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;t, F factor)</td></tr>
<tr class="separator:a682278b1856ce075dd891653e6efb64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c834d1d31e48bd0f0343ace9895d7b" id="r_ae0c834d1d31e48bd0f0343ace9895d7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ae0c834d1d31e48bd0f0343ace9895d7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ae0c834d1d31e48bd0f0343ace9895d7b">scale_to</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;t, F factor, Perm const &amp;p)</td></tr>
<tr class="separator:ae0c834d1d31e48bd0f0343ace9895d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5ef59d447b0f973556fc53ca721029" id="r_ade5ef59d447b0f973556fc53ca721029"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade5ef59d447b0f973556fc53ca721029"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ade5ef59d447b0f973556fc53ca721029">compress</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t, double cut)</td></tr>
<tr class="separator:ade5ef59d447b0f973556fc53ca721029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4a7f2760bcf71de9f3fe3417a9d765" id="r_afb4a7f2760bcf71de9f3fe3417a9d765"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb4a7f2760bcf71de9f3fe3417a9d765"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#afb4a7f2760bcf71de9f3fe3417a9d765">empty</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="separator:afb4a7f2760bcf71de9f3fe3417a9d765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9c9ea6474e427180da37e6cd081dca" id="r_a5c9c9ea6474e427180da37e6cd081dca"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Op &gt; </td></tr>
<tr class="memitem:a5c9c9ea6474e427180da37e6cd081dca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a5c9c9ea6474e427180da37e6cd081dca">unary</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, Op &amp;&amp;op)</td></tr>
<tr class="separator:a5c9c9ea6474e427180da37e6cd081dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b512f3375465ad779a6b10121e1bcc" id="r_a48b512f3375465ad779a6b10121e1bcc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Op , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a48b512f3375465ad779a6b10121e1bcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a48b512f3375465ad779a6b10121e1bcc">binary</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;l, Op &amp;&amp;op, Perm const &amp;p)</td></tr>
<tr class="separator:a48b512f3375465ad779a6b10121e1bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4449512dd98cecbb6de4b4b5b5af693" id="r_ae4449512dd98cecbb6de4b4b5b5af693"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Op &gt; </td></tr>
<tr class="memitem:ae4449512dd98cecbb6de4b4b5b5af693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ae4449512dd98cecbb6de4b4b5b5af693">inplace_unary</a> (<a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;l, Op &amp;&amp;op)</td></tr>
<tr class="separator:ae4449512dd98cecbb6de4b4b5b5af693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897e3118c62183307f83e06c61696784" id="r_a897e3118c62183307f83e06c61696784"><td class="memTemplParams" colspan="2">template&lt;typename Array , class conv_class &gt; </td></tr>
<tr class="memitem:a897e3118c62183307f83e06c61696784"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a897e3118c62183307f83e06c61696784">cp_als_rank</a> (const Array &amp;reference, std::vector&lt; Array &gt; &amp;factor_matrices, std::vector&lt; size_t &gt; &amp;symmetries, conv_class &amp;conv, int block_size=1, int rank=0, double max_ALS=5e3, bool fast_pI=true, bool direct=true, bool recompose=false)</td></tr>
<tr class="separator:a897e3118c62183307f83e06c61696784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120b57d0bb436815d10efee45407bc78" id="r_a120b57d0bb436815d10efee45407bc78"><td class="memTemplParams" colspan="2">template&lt;typename Array , class conv_class &gt; </td></tr>
<tr class="memitem:a120b57d0bb436815d10efee45407bc78"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a120b57d0bb436815d10efee45407bc78">cp_rals_rank</a> (const Array &amp;reference, std::vector&lt; Array &gt; &amp;factor_matrices, std::vector&lt; size_t &gt; symmetries, conv_class &amp;conv, int block_size=1, int rank=0, double max_ALS=5e3, bool fast_pI=true, bool direct=true, bool recompose=false)</td></tr>
<tr class="separator:a120b57d0bb436815d10efee45407bc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5da6384adde9d6994093613bab62c2c" id="r_ab5da6384adde9d6994093613bab62c2c"><td class="memTemplParams" colspan="2">template&lt;typename Array , class conv_class &gt; </td></tr>
<tr class="memitem:ab5da6384adde9d6994093613bab62c2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab5da6384adde9d6994093613bab62c2c">cp_df_als_rank</a> (const Array &amp;referenceL, const Array &amp;referenceR, const Array &amp;ref_full, std::vector&lt; Array &gt; &amp;factor_matrices, conv_class &amp;conv, std::vector&lt; size_t &gt; &amp;symm, int block_size=1, int rank=0, double max_ALS=5e3, bool fast_pI=true)</td></tr>
<tr class="separator:ab5da6384adde9d6994093613bab62c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc642265d827a61bfffe3b30ef1d269" id="r_aadc642265d827a61bfffe3b30ef1d269"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:aadc642265d827a61bfffe3b30ef1d269"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#aadc642265d827a61bfffe3b30ef1d269">coupled_cp_als</a> (const Array &amp;referenceL, const Array &amp;referenceR, std::vector&lt; Array &gt; &amp;factor_matrices, int block_size=1, int rank=0, double max_ALS=5e3, double tcutALS=5e-3, int SVD_initial_guess=false, int SVD_rank=0, int step=1)</td></tr>
<tr class="separator:aadc642265d827a61bfffe3b30ef1d269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4b962a6ffd3534d25786e0754fa998" id="r_a9b4b962a6ffd3534d25786e0754fa998"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a9b4b962a6ffd3534d25786e0754fa998"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a9b4b962a6ffd3534d25786e0754fa998">cp_exchange_formation</a> (const Array &amp;referenceL, const Array &amp;referenceR, std::vector&lt; Array &gt; &amp;factor_matrices, int block_size=1, int rank=0, double max_ALS=5e3, double tcutALS=1e-2, bool fast_pI=true)</td></tr>
<tr class="separator:a9b4b962a6ffd3534d25786e0754fa998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71238d9f94c56148031cef5db5ed38ae" id="r_a71238d9f94c56148031cef5db5ed38ae"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a71238d9f94c56148031cef5db5ed38ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a71238d9f94c56148031cef5db5ed38ae">cp_decomp_for_LT_T</a> (const Array &amp;Xab, const Array &amp;Xai, std::vector&lt; Array &gt; &amp;factor_matrices, int block_size=1, int rank=0, double max_ALS=5e3, double tcutALS=1e-2, bool fast_pI=true)</td></tr>
<tr class="separator:a71238d9f94c56148031cef5db5ed38ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6143c4ac50641147a75a9309f9ed9f3f" id="r_a6143c4ac50641147a75a9309f9ed9f3f"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a6143c4ac50641147a75a9309f9ed9f3f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; TiledArray::DistArray&lt; Tile, Policy &gt; &gt;, std::vector&lt; TiledArray::DistArray&lt; Tile, Policy &gt; &gt;, std::vector&lt; TiledArray::DistArray&lt; Tile, Policy &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6143c4ac50641147a75a9309f9ed9f3f">compute_cp3_df_int_decomp</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;Xab, double rank_block_factor, int uocc_tile_size, size_t cp_rank, double cp_precision, const TA::DistArray&lt; Tile, Policy &gt; &amp;Had_reblock_matrix=TA::DistArray&lt; Tile, Policy &gt;(), bool cp_ps=false, bool cp_robust=false, bool verbose=false, bool ta_cp3=false, const TA::DistArray&lt; Tile, Policy &gt; &amp;Xai=TA::DistArray&lt; Tile, Policy &gt;())</td></tr>
<tr class="separator:a6143c4ac50641147a75a9309f9ed9f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fc3080f46a77a1296a675b4866556a" id="r_a29fc3080f46a77a1296a675b4866556a"><td class="memTemplParams" colspan="2">template&lt;typename integral , typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a29fc3080f46a77a1296a675b4866556a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a29fc3080f46a77a1296a675b4866556a">generate_cc_cp3_decomp</a> (integral &amp;ints, int had_block_size_, double cp3_rank_, bool reduced_abcd_memory_, double rank_block_factor_, int vir_block_size, double cp3_precision_, bool ta_als_)</td></tr>
<tr class="separator:a29fc3080f46a77a1296a675b4866556a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e64267f3e8b8e17c90cedfbb2f1f506" id="r_a6e64267f3e8b8e17c90cedfbb2f1f506"><td class="memTemplParams" colspan="2">template&lt;typename integral , typename TArray , typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a6e64267f3e8b8e17c90cedfbb2f1f506"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a6e64267f3e8b8e17c90cedfbb2f1f506">generate_cc_cp4_decomp</a> (integral &amp;ints, TArray Xma, TArray Cma, TArray Cmi, int had_block_size_, double cp3_rank_, double cp4_rank_, double rank_block_factor_, int vir_block_size, double cp3_precision_, double cp4_precision_)</td></tr>
<tr class="separator:a6e64267f3e8b8e17c90cedfbb2f1f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1c7c153eee3c8f698297e933286afa18" id="r_a1c7c153eee3c8f698297e933286afa18"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739">ClusteringMethod</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a1c7c153eee3c8f698297e933286afa18">clustering_method_type2string</a> = <a class="el" href="namespacempqc_1_1math.html#a5716b7e21b52c0e42fbb4ecc252a3fea">make_clustering_method_type2string</a>()</td></tr>
<tr class="separator:a1c7c153eee3c8f698297e933286afa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599a6bfcbe3a562318dbf89b0eb287b6" id="r_a599a6bfcbe3a562318dbf89b0eb287b6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739">ClusteringMethod</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a599a6bfcbe3a562318dbf89b0eb287b6">clustering_method_string2type</a> = <a class="el" href="namespacempqc_1_1math.html#a9a79a4f34ce13e36d2f3262e8cb9fdc0">make_clustering_method_string2type</a>()</td></tr>
<tr class="separator:a599a6bfcbe3a562318dbf89b0eb287b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c86572368c1d2d7d66baad63bdf3ff8" id="r_a9c86572368c1d2d7d66baad63bdf3ff8"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#a9c86572368c1d2d7d66baad63bdf3ff8">string_to_CanonicalColumnPhaseMethod</a></td></tr>
<tr class="separator:a9c86572368c1d2d7d66baad63bdf3ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81dc2e9a385ac3a5deb4e690c3f17d6" id="r_ab81dc2e9a385ac3a5deb4e690c3f17d6"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ab81dc2e9a385ac3a5deb4e690c3f17d6">CanonicalColumnPhaseMethod_to_string</a></td></tr>
<tr class="separator:ab81dc2e9a385ac3a5deb4e690c3f17d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5de0b9a238a8bf0adb0e61919b5020e" id="r_ae5de0b9a238a8bf0adb0e61919b5020e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_force_link.html">ForceLink</a>&lt; <a class="el" href="classmpqc_1_1math_1_1_davidson_eigensolver_factory.html">DavidsonEigensolverFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1math.html#ae5de0b9a238a8bf0adb0e61919b5020e">math_linalg_davidson_force_link</a></td></tr>
<tr class="separator:ae5de0b9a238a8bf0adb0e61919b5020e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acfb508667c4e7e2b919b52d35adf107b" name="acfb508667c4e7e2b919b52d35adf107b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb508667c4e7e2b919b52d35adf107b">&#9670;&#160;</a></span>ConditionalOrthogOutput</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">OrthogOutput</a> Output, typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1math.html#acfb508667c4e7e2b919b52d35adf107b">mpqc::math::ConditionalOrthogOutput</a> = typedef std::conditional_t&lt; Output == <a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15a02129bb861061d1a052c592e2dc6b383">OrthogOutput::X</a>, std::tuple&lt;TA::DistArray&lt;Tile, Policy&gt;, <a class="el" href="structmpqc_1_1math_1_1_nonnegative_spectral_range.html">NonnegativeSpectralRange</a>&lt;TA::detail::scalar_t&lt;Tile&gt; &gt;&gt;, std::tuple&lt;TA::DistArray&lt;Tile, Policy&gt;, TA::DistArray&lt;Tile, Policy&gt;, <a class="el" href="structmpqc_1_1math_1_1_nonnegative_spectral_range.html">NonnegativeSpectralRange</a>&lt;TA::detail::scalar_t&lt;Tile&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa82709d31afb8b917c53f177c664c73f" name="aa82709d31afb8b917c53f177c664c73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82709d31afb8b917c53f177c664c73f">&#9670;&#160;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">mpqc::math::Matrix</a> = typedef Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35d88d37ba6045aba75686f2da8c7f25" name="a35d88d37ba6045aba75686f2da8c7f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d88d37ba6045aba75686f2da8c7f25">&#9670;&#160;</a></span>mpfloat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1math.html#a35d88d37ba6045aba75686f2da8c7f25">mpqc::math::mpfloat</a> = typedef long double</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab889c32f48707ecbe045597b6bb7a88e" name="ab889c32f48707ecbe045597b6bb7a88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab889c32f48707ecbe045597b6bb7a88e">&#9670;&#160;</a></span>CanonicalColumnPhaseMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">mpqc::math::CanonicalColumnPhaseMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>methods for canonicalizing the columns of a matrix </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab889c32f48707ecbe045597b6bb7a88ead12fbc9a2ba3b0b91a4190959b4c966b" name="ab889c32f48707ecbe045597b6bb7a88ead12fbc9a2ba3b0b91a4190959b4c966b"></a>Align&#160;</td><td class="fielddoc"><p>Align with standard basis (non-iterative) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab889c32f48707ecbe045597b6bb7a88ea4aa0f8a9fd5a5c0f77d1aabb6c58b0a2" name="ab889c32f48707ecbe045597b6bb7a88ea4aa0f8a9fd5a5c0f77d1aabb6c58b0a2"></a>L4&#160;</td><td class="fielddoc"><p>maximization of l4 norm of the column panel; the l4 norm is normalized per-column, i.e. we maximize \( ((\sum_r^{n_r} \sum_c^{n_c} |v_{rc}|^4)/n_c)^{1/4} \) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab889c32f48707ecbe045597b6bb7a88ea15fc3950b7c08c0b533f05a119795393" name="ab889c32f48707ecbe045597b6bb7a88ea15fc3950b7c08c0b533f05a119795393"></a>Entropy&#160;</td><td class="fielddoc"><p>minimization of the Shannon entropy of the column panel; the Shannon entropy is normalized per-column, i.e. we maximize \( -(\sum_r^{n_r} \sum_c^{n_c} |v_{rc}|^2 \log(|v_{rc}|^2) )/n_c \) N.B. Shannon entropy is equivalent to von Neumann entropy under certain conditions, hence no prefix </p>
</td></tr>
<tr><td class="fieldname"><a id="ab889c32f48707ecbe045597b6bb7a88eaefcbcff9c8282fe81b2aa6f54da99d16" name="ab889c32f48707ecbe045597b6bb7a88eaefcbcff9c8282fe81b2aa6f54da99d16"></a>Align_L4&#160;</td><td class="fielddoc"><p>First align with standard basis, then sparsity by <code>L4</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="ab889c32f48707ecbe045597b6bb7a88eae424533468d113dd6670dcb29d43f78a" name="ab889c32f48707ecbe045597b6bb7a88eae424533468d113dd6670dcb29d43f78a"></a>Align_Entropy&#160;</td><td class="fielddoc"><p>First align with standard basis, then sparsity by <code>Entropy</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="ab889c32f48707ecbe045597b6bb7a88ea7a1920d61156abc05a60135aefe8bc67" name="ab889c32f48707ecbe045597b6bb7a88ea7a1920d61156abc05a60135aefe8bc67"></a>Default&#160;</td><td class="fielddoc"><p>use <a class="el" href="namespacempqc_1_1math.html#ae739cec487a3f4ec2437a8b4dcf904ed" title="accesses the singleton object that controls canonical_column_phase functions">canonical_column_phase_control()</a>-&gt;method </p>
</td></tr>
</table>

</div>
</div>
<a id="a4edc461603cdd44dbd70281e40567739" name="a4edc461603cdd44dbd70281e40567739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edc461603cdd44dbd70281e40567739">&#9670;&#160;</a></span>ClusteringMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739">mpqc::math::ClusteringMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>known methods for clustering </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4edc461603cdd44dbd70281e40567739a6adf97f83acf6453d4a6a4b1070f3754" name="a4edc461603cdd44dbd70281e40567739a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4edc461603cdd44dbd70281e40567739a7bdf23368e94f382913959359221a144" name="a4edc461603cdd44dbd70281e40567739a7bdf23368e94f382913959359221a144"></a>KMeans_Forgy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4edc461603cdd44dbd70281e40567739a4648d0430728e7ab3bbbea6618acd399" name="a4edc461603cdd44dbd70281e40567739a4648d0430728e7ab3bbbea6618acd399"></a>KMeans_PlusPlus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4edc461603cdd44dbd70281e40567739a34ee121804c9b1396e6ad445f510d901" name="a4edc461603cdd44dbd70281e40567739a34ee121804c9b1396e6ad445f510d901"></a>KMeans_CentroidThenMaxDist&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4edc461603cdd44dbd70281e40567739a7a1920d61156abc05a60135aefe8bc67" name="a4edc461603cdd44dbd70281e40567739a7a1920d61156abc05a60135aefe8bc67"></a>Default&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a343a5ca944dd4ae30b58373883cdfa85" name="a343a5ca944dd4ae30b58373883cdfa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343a5ca944dd4ae30b58373883cdfa85">&#9670;&#160;</a></span>CoulombGauge</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacempqc_1_1math.html#a343a5ca944dd4ae30b58373883cdfa85">mpqc::math::CoulombGauge</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>types of Coulomb potential gauge </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a343a5ca944dd4ae30b58373883cdfa85a7a1920d61156abc05a60135aefe8bc67" name="a343a5ca944dd4ae30b58373883cdfa85a7a1920d61156abc05a60135aefe8bc67"></a>Default&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a343a5ca944dd4ae30b58373883cdfa85a4ca32cf75df1f52742531e3a08c470e4" name="a343a5ca944dd4ae30b58373883cdfa85a4ca32cf75df1f52742531e3a08c470e4"></a>Ewald&#160;</td><td class="fielddoc"><p>Default gauge produced by MADNESS. For open boundary conditions this is just the standard 1/r gauge. If boundary conditions are periodic along any of the axes the default gauge produced by separated convolution ensures that the average potential is \( \langle V \range = Q * \sum c_a \) where \( Q \) is the electric charge (average of the density) and \( c_a \) are the coefficients of normalized Gaussians in the expansion of the 1/r kernel. For zero-charge densities this is equivalent to the Ewald gauge. </p>
</td></tr>
<tr><td class="fieldname"><a id="a343a5ca944dd4ae30b58373883cdfa85adc2e5a54767663833b5f96a475b27cf4" name="a343a5ca944dd4ae30b58373883cdfa85adc2e5a54767663833b5f96a475b27cf4"></a>EwaldMakovPayne&#160;</td><td class="fielddoc"><p>Ewald gauge, defined by the \( \langle V \range = 0 \) condition. </p>
</td></tr>
<tr><td class="fieldname"><a id="a343a5ca944dd4ae30b58373883cdfa85afedb2d84cafe20862cb4399751a8a7e3" name="a343a5ca944dd4ae30b58373883cdfa85afedb2d84cafe20862cb4399751a8a7e3"></a>invalid&#160;</td><td class="fielddoc"><p>Ewald potential corrected for spheropole (constant) dipole contributions, see DOI 10.1103/PhysRevB.51.4014 </p>
</td></tr>
</table>

</div>
</div>
<a id="aaae50adb8d3490b303e6d1fc7846ff15" name="aaae50adb8d3490b303e6d1fc7846ff15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae50adb8d3490b303e6d1fc7846ff15">&#9670;&#160;</a></span>OrthogOutput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">mpqc::math::OrthogOutput</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>controls whether gensqrtinv produces X or X and its "inverse" </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaae50adb8d3490b303e6d1fc7846ff15a02129bb861061d1a052c592e2dc6b383" name="aaae50adb8d3490b303e6d1fc7846ff15a02129bb861061d1a052c592e2dc6b383"></a>X&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaae50adb8d3490b303e6d1fc7846ff15a86f780010dd9309712d1dd4d9886647d" name="aaae50adb8d3490b303e6d1fc7846ff15a86f780010dd9309712d1dd4d9886647d"></a>XAndXInverse&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8d004e186b17199f7bd5cc8d94330edd" name="a8d004e186b17199f7bd5cc8d94330edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d004e186b17199f7bd5cc8d94330edd">&#9670;&#160;</a></span>abs_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::abs_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the abs_max of a decomposed tensor tile Currently not recommended due to implementation details. </p>

</div>
</div>
<a id="ac93e6038f3f2fb755f1d700e1e622c0d" name="ac93e6038f3f2fb755f1d700e1e622c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93e6038f3f2fb755f1d700e1e622c0d">&#9670;&#160;</a></span>abs_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::abs_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the abs_min of a decomposed tensor tile Currently not recommended due to implementation details. </p>

</div>
</div>
<a id="aaac9a138d8619ca458c2a9fa966c9fc7" name="aaac9a138d8619ca458c2a9fa966c9fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac9a138d8619ca458c2a9fa966c9fc7">&#9670;&#160;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff1e0923f25b69d295db8485ae8d6753" name="aff1e0923f25b69d295db8485ae8d6753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1e0923f25b69d295db8485ae8d6753">&#9670;&#160;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84aba79a53ebd4c43df289744b48d7b6" name="a84aba79a53ebd4c43df289744b48d7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84aba79a53ebd4c43df289744b48d7b6">&#9670;&#160;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5b7e6969ad600828afca08b6444cb7d" name="ac5b7e6969ad600828afca08b6444cb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b7e6969ad600828afca08b6444cb7d">&#9670;&#160;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a578e5805b08457c4b25ff5539cc181c6" name="a578e5805b08457c4b25ff5539cc181c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578e5805b08457c4b25ff5539cc181c6">&#9670;&#160;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6478c75a4a7eb210deb28fc8149dab5e" name="a6478c75a4a7eb210deb28fc8149dab5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6478c75a4a7eb210deb28fc8149dab5e">&#9670;&#160;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6fea7d68962a3c8e90818b4eecfd0fd" name="ac6fea7d68962a3c8e90818b4eecfd0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fea7d68962a3c8e90818b4eecfd0fd">&#9670;&#160;</a></span>add_order2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::add_order2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5154d83ad62aa2ebd2c2d3ff0a15f7a7" name="a5154d83ad62aa2ebd2c2d3ff0a15f7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5154d83ad62aa2ebd2c2d3ff0a15f7a7">&#9670;&#160;</a></span>add_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::add_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a612763b586f527bd3a1a49aaa79f1181" name="a612763b586f527bd3a1a49aaa79f1181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612763b586f527bd3a1a49aaa79f1181">&#9670;&#160;</a></span>add_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::add_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae08870cd4cffc684cc33a9e7e10337ca" name="ae08870cd4cffc684cc33a9e7e10337ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08870cd4cffc684cc33a9e7e10337ca">&#9670;&#160;</a></span>add_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::add_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5a2ce6e3d09fda4054a7436ecef0125" name="ac5a2ce6e3d09fda4054a7436ecef0125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a2ce6e3d09fda4054a7436ecef0125">&#9670;&#160;</a></span>add_to_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::add_to_diag </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f1f1ae04a884160da0907bea4cd7ae3" name="a3f1f1ae04a884160da0907bea4cd7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1f1ae04a884160da0907bea4cd7ae3">&#9670;&#160;</a></span>add_to_diag_tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::add_to_diag_tile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::Tile&lt; <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4274f32c42d2775f692e9a70157563af" name="a4274f32c42d2775f692e9a70157563af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4274f32c42d2775f692e9a70157563af">&#9670;&#160;</a></span>add_to_diag_tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Tensor , std::enable_if_t&lt; TA::detail::is_contiguous_tensor_v&lt; Tensor &gt; &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::add_to_diag_tile </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor &amp;&#160;</td>
          <td class="paramname"><em>tile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5b2222cb6ddaf591d8b2056908179af" name="aa5b2222cb6ddaf591d8b2056908179af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b2222cb6ddaf591d8b2056908179af">&#9670;&#160;</a></span>add_to_order2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::add_to_order2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa80b51befcfd34b9ff9c36a42923fd7b" name="aa80b51befcfd34b9ff9c36a42923fd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80b51befcfd34b9ff9c36a42923fd7b">&#9670;&#160;</a></span>antihermitian_matrix_strictupper_to_full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename RealT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; mpqc::math::antihermitian_matrix_strictupper_to_full </td>
          <td>(</td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealT *&#160;</td>
          <td class="paramname"><em>uptri_real</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adecdfb5b97ed5ba504e56aa9cfbe6fe4" name="adecdfb5b97ed5ba504e56aa9cfbe6fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecdfb5b97ed5ba504e56aa9cfbe6fe4">&#9670;&#160;</a></span>array_to_eigen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int EigenStorageOrder = Eigen::RowMajor, typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::array_to_eigen </td>
          <td>(</td>
          <td class="paramtype">TA::DistArray&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a TA::DistArray to an Eigen::Matrix, replicating the input matrix if needed </p>
<dl class="section note"><dt>Note</dt><dd>Unlike TA::array_to_eigen this replicates the input, if needed </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EigenStorageOrder</td><td>either Eigen::RowMajor (default) or Eigen::ColMajor </td></tr>
    <tr><td class="paramname">Tile</td><td>a TA tile type </td></tr>
    <tr><td class="paramname">Policy</td><td>a TA policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>an order-2 TA::DistArray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Matrix representation of <code>A</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this is a collective operation over the World object returned by <code>A.world()</code> </dd></dl>

</div>
</div>
<a id="a0c2110a15aceb826940596c8ac6a80a1" name="a0c2110a15aceb826940596c8ac6a80a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2110a15aceb826940596c8ac6a80a1">&#9670;&#160;</a></span>array_to_eigen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int EigenStorageOrder = Eigen::RowMajor, typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::array_to_eigen </td>
          <td>(</td>
          <td class="paramtype">TA::DistArrayVector&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a TA::DistArrayVector to an Eigen::Matrix </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EigenStorageOrder</td><td>either Eigen::RowMajor (default) or Eigen::ColMajor </td></tr>
    <tr><td class="paramname">Tile</td><td>a TA tile type </td></tr>
    <tr><td class="paramname">Policy</td><td>a TA policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>an order-2 TA::DistArrayVector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::vector of Eigen::Matrix objects containing data of <code>A</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this is a collective operation over the World object returned by <code>A.world()</code> </dd></dl>

</div>
</div>
<a id="aedffc767918748a2201ed2c953c5ad48" name="aedffc767918748a2201ed2c953c5ad48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedffc767918748a2201ed2c953c5ad48">&#9670;&#160;</a></span>array_to_eigen_tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EigenTensor , typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EigenTensor mpqc::math::array_to_eigen_tensor </td>
          <td>(</td>
          <td class="paramtype">TA::DistArray&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a TA::DistArray to an Eigen::Tensor </p>
<dl class="section note"><dt>Note</dt><dd>Unlike TA::array_to_eigen_tensor this replicates the input, if needed </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EigenTensor</td><td>a Eigen::Tensor type </td></tr>
    <tr><td class="paramname">Tile</td><td>a TA tile type </td></tr>
    <tr><td class="paramname">Policy</td><td>a TA policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>a TA::DistArray of same order as EigenTensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Tensor representation of <code>A</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this is a collective operation over the World object returned by <code>A.world()</code> </dd></dl>

</div>
</div>
<a id="a08d22b534e33a880c9983def797b0928" name="a08d22b534e33a880c9983def797b0928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d22b534e33a880c9983def797b0928">&#9670;&#160;</a></span>array_to_eigen_tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EigenTensor , typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; EigenTensor &gt; mpqc::math::array_to_eigen_tensor </td>
          <td>(</td>
          <td class="paramtype">TA::DistArrayVector&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a TA::DistArrayVector to a vector of Eigen::Tensor objects </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EigenTensor</td><td>a Eigen::Tensor type </td></tr>
    <tr><td class="paramname">Tile</td><td>a TA tile type </td></tr>
    <tr><td class="paramname">Policy</td><td>a TA policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>a TA::DistArrayVector of same order as EigenTensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::vector of Eigen::Tensor objects containing data of <code>A</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this is a collective operation over the World object returned by <code>A.world()</code> </dd></dl>

</div>
</div>
<a id="ad7613e2c8947d8b92aca648551d3a081" name="ad7613e2c8947d8b92aca648551d3a081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7613e2c8947d8b92aca648551d3a081">&#9670;&#160;</a></span>as_real() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename U  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr boost::container::small_vector&lt; T, N &gt; mpqc::math::as_real </td>
          <td>(</td>
          <td class="paramtype">const boost::container::small_vector&lt; std::complex&lt; T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>imag_threshold</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Casts vector <code>vec</code> to a real type using as_real </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>a vector </td></tr>
    <tr><td class="paramname">imag_threshold</td><td>threshold for the imaginary part of the complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>vec</code>, if <code>T</code> is real, else a vector of elements of <code>vec</code> cast to T </dd></dl>

</div>
</div>
<a id="a94e610035b2b0eca64175fa064ca053d" name="a94e610035b2b0eca64175fa064ca053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e610035b2b0eca64175fa064ca053d">&#9670;&#160;</a></span>as_real() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename  = std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const boost::container::small_vector&lt; T, N &gt; &amp; mpqc::math::as_real </td>
          <td>(</td>
          <td class="paramtype">const boost::container::small_vector&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6910b0bd23347a1374688634e7f3c9e" name="af6910b0bd23347a1374688634e7f3c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6910b0bd23347a1374688634e7f3c9e">&#9670;&#160;</a></span>as_real() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows, int Cols, int Options, int MaxRows, int MaxCols, typename U  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Eigen::Matrix&lt; T, Rows, Cols, Options, MaxRows, MaxCols &gt; mpqc::math::as_real </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; std::complex&lt; T &gt;, Rows, Cols, Options, MaxRows, MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>imag_threshold</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Casts matrix <code>mat</code> to a real type using as_real </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>an Eigen matrix </td></tr>
    <tr><td class="paramname">imag_threshold</td><td>threshold for the imaginary part of the complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>mat</code>, if <code>T</code> is real, else a matrix of elements of <code>mat</code> cast to T </dd></dl>

</div>
</div>
<a id="ad49254eaf15ecc4877f273f7346398ea" name="ad49254eaf15ecc4877f273f7346398ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49254eaf15ecc4877f273f7346398ea">&#9670;&#160;</a></span>as_real() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows, int Cols, int Options, int MaxRows, int MaxCols, typename  = std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Eigen::Matrix&lt; T, Rows, Cols, Options, MaxRows, MaxCols &gt; mpqc::math::as_real </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, Cols, Options, MaxRows, MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6042e840c46df9a5ebff21fc30c3702f" name="a6042e840c46df9a5ebff21fc30c3702f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6042e840c46df9a5ebff21fc30c3702f">&#9670;&#160;</a></span>as_real() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T mpqc::math::as_real </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>imag_threshold</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Casts complex number <code>z</code> to a real type taking its real part while asserting that its imaginary part is below threshold </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the real part of <code>z</code> </dd></dl>

</div>
</div>
<a id="a3d63102d2134bd65b142b24584e66944" name="a3d63102d2134bd65b142b24584e66944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d63102d2134bd65b142b24584e66944">&#9670;&#160;</a></span>as_real() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::vector&lt; T &gt; mpqc::math::as_real </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>imag_threshold</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Casts vector <code>vec</code> to a real type using as_real </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>a vector </td></tr>
    <tr><td class="paramname">imag_threshold</td><td>threshold for the imaginary part of the complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>vec</code>, if <code>T</code> is real, else a vector of elements of <code>vec</code> cast to T </dd></dl>

</div>
</div>
<a id="a9df3dbfd3647f094d52af54757831678" name="a9df3dbfd3647f094d52af54757831678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df3dbfd3647f094d52af54757831678">&#9670;&#160;</a></span>as_real() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::vector&lt; T &gt; &amp; mpqc::math::as_real </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5688ed666bc219d14ea6bf773f71a481" name="a5688ed666bc219d14ea6bf773f71a481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5688ed666bc219d14ea6bf773f71a481">&#9670;&#160;</a></span>as_real() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T &amp; mpqc::math::as_real </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Casts <code>v</code> to a real type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the real part of <code>v</code> </dd></dl>

</div>
</div>
<a id="aa7dc595b553837a622ebc88b793291f6" name="aa7dc595b553837a622ebc88b793291f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc595b553837a622ebc88b793291f6">&#9670;&#160;</a></span>binary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d9d38ac0ba2f62898d4990cd5182fb" name="a77d9d38ac0ba2f62898d4990cd5182fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d9d38ac0ba2f62898d4990cd5182fb">&#9670;&#160;</a></span>binary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Op , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b512f3375465ad779a6b10121e1bcc" name="a48b512f3375465ad779a6b10121e1bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b512f3375465ad779a6b10121e1bcc">&#9670;&#160;</a></span>binary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Op , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6af63ecffee0bd450cc69213ce49b884" name="a6af63ecffee0bd450cc69213ce49b884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af63ecffee0bd450cc69213ce49b884">&#9670;&#160;</a></span>canonical_column_phase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Numeric &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, Policy &gt; mpqc::math::canonical_column_phase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a>&#160;</td>
          <td class="paramname"><em>CCPM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>A_element_comparison_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>column_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>column_attribute_comparison_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canonicalize_panel_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>version that takes a TA::DistArray and takes CanonicalColumnPhaseMethod as regular argument </p>
<p>Performs all work on rank 0 and broadcasts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CCPM</td><td>the canonicalization method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b2768700def100ce439bbfa5bc9bf9e" name="a1b2768700def100ce439bbfa5bc9bf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2768700def100ce439bbfa5bc9bf9e">&#9670;&#160;</a></span>canonical_column_phase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename T , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols, typename _Numeric &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; mpqc::math::canonical_column_phase </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; _Numeric &gt;&#160;</td>
          <td class="paramname"><em>A_element_comparison_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; _Numeric &gt;&#160;</td>
          <td class="paramname"><em>column_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; _Numeric &gt;&#160;</td>
          <td class="paramname"><em>column_attributes_comparison_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canonicalize_panel_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>version that takes an Eigen::Matrix </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CCPM</td><td>the canonicalization method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b10e4432be510341f8d0e90f179d67c" name="a6b10e4432be510341f8d0e90f179d67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b10e4432be510341f8d0e90f179d67c">&#9670;&#160;</a></span>canonical_column_phase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> CCPM, typename Tile , typename Policy , typename Numeric &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, Policy &gt; mpqc::math::canonical_column_phase </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>A_element_comparison_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>column_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>column_attribute_comparison_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canonicalize_panel_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>version that takes a TA::DistArray </p>
<p>Performs all work on rank 0 and broadcasts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CCPM</td><td>the canonicalization method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae739cec487a3f4ec2437a8b4dcf904ed" name="ae739cec487a3f4ec2437a8b4dcf904ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae739cec487a3f4ec2437a8b4dcf904ed">&#9670;&#160;</a></span>canonical_column_phase_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="structmpqc_1_1math_1_1_canonical_column_phase_control.html">CanonicalColumnPhaseControl</a> &gt; mpqc::math::canonical_column_phase_control </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>accesses the singleton object that controls canonical_column_phase functions </p>

</div>
</div>
<a id="abaa6f6297747c91120658e7426c3424f" name="abaa6f6297747c91120658e7426c3424f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa6f6297747c91120658e7426c3424f">&#9670;&#160;</a></span>canonical_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::canonical_greater </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rel_cmp_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>canonical greater-than comparison of 2 real numbers (orders first by magnitude, then by value) </p>
<p>To be used for ordering in decreasing order. Compares as follows:</p><ul>
<li>if <code>v1 ≈ v2</code> return false</li>
<li>if <code>|v1| ≈ |v2|</code>:<ul>
<li>if <code>v1</code> and <code>v2</code> are scalar: return <code>v1 &gt; v2</code></li>
<li>if <code>v1</code> and <code>v2</code> are complex: return <code>v1.real() &gt; v2.real()</code></li>
<li>else return false</li>
</ul>
</li>
<li>if <code>|v1| ≉ |v2|</code> return <code>|v1| &gt; |v2|</code> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td></td></tr>
    <tr><td class="paramname">v2</td><td></td></tr>
    <tr><td class="paramname">rel_cmp_thresh</td><td>comtrols soft equality comparison, namely <code>v1 ≈ v2</code> if <code>|v1-v2|/max(|v1|,|v2|) &lt;= rel_cmp_thresh</code> </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="abe4fef27508593505e4cfaa3b1eb9f22" name="abe4fef27508593505e4cfaa3b1eb9f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4fef27508593505e4cfaa3b1eb9f22">&#9670;&#160;</a></span>canonical_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::canonical_less </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rel_cmp_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>canonical less-than comparison of 2 real numbers (orders first by magnitude, then by value) </p>
<p>To be used for ordering in increasing order. Compares as follows:</p><ul>
<li>if <code>v1 ≈ v2</code> return false</li>
<li>if <code>|v1| ≈ |v2|</code>:<ul>
<li>if <code>v1</code> and <code>v2</code> are scalar: return <code>v1 &lt; v2</code></li>
<li>if <code>v1</code> and <code>v2</code> are complex: return <code>v1.imag() &lt; v2.imag()</code> if <code>v1.real() == v2.real()</code> else return <code>v1.real() &lt; v2.real()</code></li>
<li>else return false</li>
</ul>
</li>
<li>if <code>|v1| ≉ |v2|</code> return <code>|v1| &lt; |v2|</code> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td></td></tr>
    <tr><td class="paramname">v2</td><td></td></tr>
    <tr><td class="paramname">rel_cmp_thresh</td><td>comtrols soft equality comparison, namely <code>v1 ≈ v2</code> if <code>|v1-v2|/max(|v1,|v2|) &lt;= rel_cmp_thresh</code> </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ab63c4b26d49f74c6b8c6dc56ae496dde" name="ab63c4b26d49f74c6b8c6dc56ae496dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63c4b26d49f74c6b8c6dc56ae496dde">&#9670;&#160;</a></span>canonical_phase_inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Numeric mpqc::math::canonical_phase_inverse </td>
          <td>(</td>
          <td class="paramtype">const Numeric &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the phase by which @value needs to be multiplied to become positive real number </dd></dl>

</div>
</div>
<a id="a9f5e1bbc021c37a113f71d50f3fb5b70" name="a9f5e1bbc021c37a113f71d50f3fb5b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5e1bbc021c37a113f71d50f3fb5b70">&#9670;&#160;</a></span>check_numeric_range_degeneracies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mpqc::math::check_numeric_range_degeneracies </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TiledArray::detail::scalar_t&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>rel_eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>proposed_degeneracies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>checks whether a (not-necessarily-sorted) numeric range's satisfy the proposed degeneracies within the comparison threshold; unlike numeric_range_degeneracies and match_numeric_range_degeneracies this does not deduce the contiguous degenerate subsets but simply checks if the proposed contiguous subsets are satisfied within <code>rel_eps</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Numeric</td><td>a numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>a range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_eps</td><td>a scalar used for <em>relative</em> comparison of 2 <code>Numeric</code> values; value <code>a</code> is considered less than <code>b</code> if <code>a + rel_eps*max(|a|,|b|)&lt;b</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proposed_degeneracies</td><td>vector of degeneracies to be check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the proposed contiguous subsets of the range are degenerate within <code>rel_eps</code> </dd></dl>

</div>
</div>
<a id="a0aaa169f663b592bda15a383ea916097" name="a0aaa169f663b592bda15a383ea916097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aaa169f663b592bda15a383ea916097">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93a90afdbee5f7409d3327e6103c434f" name="a93a90afdbee5f7409d3327e6103c434f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a90afdbee5f7409d3327e6103c434f">&#9670;&#160;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TiledArray::Tensor&lt; double &gt; mpqc::math::combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade5ef59d447b0f973556fc53ca721029" name="ade5ef59d447b0f973556fc53ca721029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5ef59d447b0f973556fc53ca721029">&#9670;&#160;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; <a class="el" href="structmpqc_1_1math_1_1compress.html">mpqc::math::compress</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6143c4ac50641147a75a9309f9ed9f3f" name="a6143c4ac50641147a75a9309f9ed9f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6143c4ac50641147a75a9309f9ed9f3f">&#9670;&#160;</a></span>compute_cp3_df_int_decomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; TiledArray::DistArray&lt; Tile, Policy &gt; &gt;, std::vector&lt; TiledArray::DistArray&lt; Tile, Policy &gt; &gt;, std::vector&lt; TiledArray::DistArray&lt; Tile, Policy &gt; &gt; &gt; mpqc::math::compute_cp3_df_int_decomp </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>Xab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_block_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>uocc_tile_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cp_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cp_precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>Had_reblock_matrix</em> = <code>TA::DistArray&lt;Tile,&#160;Policy&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cp_ps</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cp_robust</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta_cp3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>Xai</em> = <code>TA::DistArray&lt;Tile,&#160;Policy&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classmpqc_1_1math_1_1_function.html" title="Function maps Parameters to a Value.">Function</a> to compute the <a class="el" href="classmpqc_1_1math_1_1_c_p3.html" title="Computes 3-way CP decomposition of a order-3 tensor.">CP3</a> decomposition of DF integrals in any method can use PS ( \( Xab_{cp} Xab \)), DF ( \( Xab_{cp} Xab_{cp}\)), or rCP (robust) ( \( Xab_{cp} (2.0 Xab - Xab_{cp} \)) </p><dl class="section return"><dt>Returns</dt><dd>a tuple first the CP factor matrices for a Xab tensor, then tensor (X * T) where X is the factor matrix of the DF mode and T is the correct Xab depending on if using PS, DF or rCP and, finally, a contraction of (X * Xai) if Xai is provided. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Xab</td><td>The reference DF like tensor being decomposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank_block_factor</td><td>blocking info for the rank mode block size is determined by <code>unnoc_block_size</code> * <code>rank_block_factor</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp_rank</td><td>rank of the cp decomposition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp_precision</td><td>ALS precision for the CP decomposition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Had_reblock_matrix</td><td><a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray&lt;Tile, Policy&gt;()</a> A matrix to reblock the unnoc dimensions for the mixed contraction in CC methods.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp_ps</td><td>false Using the CP PS approach?</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp_robust</td><td>false Using the rCP-DF approach?</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>false Print CP information</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ta_cp3</td><td>false Currently unavailable using TA to compute CP decomposition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Xai</td><td><a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray&lt;Tile, Policy&gt;()</a> A second DF tensor, used in a full <a class="el" href="classmpqc_1_1math_1_1_c_p3.html" title="Computes 3-way CP decomposition of a order-3 tensor.">CP3</a> + CP4 implementation of CC methods. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7c06c722b38faf0be334e1163292db3" name="ad7c06c722b38faf0be334e1163292db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c06c722b38faf0be334e1163292db3">&#9670;&#160;</a></span>compute_pd_element_rowidx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Index &gt; mpqc::math::compute_pd_element_rowidx </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; _Numeric &gt;&#160;</td>
          <td class="paramname"><em>rel_eps</em> = <code>1e-4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the <em>phase-defining</em> element of each column. </p>
<p>The phase-defining element of a column is the largest element; if several elements are (softly) equal then the first such element is deemed to be the phase defining element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Numeric</td><td></td></tr>
    <tr><td class="paramname">_Rows</td><td></td></tr>
    <tr><td class="paramname">_Cols</td><td></td></tr>
    <tr><td class="paramname">_Options</td><td></td></tr>
    <tr><td class="paramname">_MaxRows</td><td></td></tr>
    <tr><td class="paramname">_MaxCols</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>an Eigen::Matrix object each column of which will be analyzed to determine the phase-defining elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_eps</td><td>comparison threshold that controls when two elements are deemed sufficiently different; namely, elements \( a,b \) are equal if \( ||a|-|b||/max(|a|,|b|) \leq \epsilon \) where \( \epsilon \) is <code>rel_eps</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the row index of the phase-defining element for each column, namely the row index of the largest (by absolute magnitude) element in each column; soft comparison is controlled by <code>rel_eps</code> </dd></dl>

</div>
</div>
<a id="a08f913f164081976ad6f145171117c1f" name="a08f913f164081976ad6f145171117c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f913f164081976ad6f145171117c1f">&#9670;&#160;</a></span>concat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N1, std::size_t N2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; T, std::max(N1, N2)&gt; mpqc::math::concat </td>
          <td>(</td>
          <td class="paramtype">const boost::container::small_vector&lt; T, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::container::small_vector&lt; T, N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfeb0b6fbdba23fd1f97431eb0955c98" name="adfeb0b6fbdba23fd1f97431eb0955c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfeb0b6fbdba23fd1f97431eb0955c98">&#9670;&#160;</a></span>concat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; mpqc::math::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc649ac3ad6f64658c13c790a97fa7b6" name="acc649ac3ad6f64658c13c790a97fa7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc649ac3ad6f64658c13c790a97fa7b6">&#9670;&#160;</a></span>conditioned_orthogonalizer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">OrthogOutput</a> Output = OrthogOutput::X, typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc_1_1math.html#acfb508667c4e7e2b919b52d35adf107b">ConditionalOrthogOutput</a>&lt; Output, Tile, Policy &gt; mpqc::math::conditioned_orthogonalizer </td>
          <td>(</td>
          <td class="paramtype">TA::DistArray&lt; Tile, Policy &gt;&#160;</td>
          <td class="paramname"><em>S_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>S_condition_number_threshold</em> = <code>1&#160;/&#160;std::sqrt(std::numeric_limits&lt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;typename&#160;TA::detail::scalar_type&lt;Tile&gt;::type&gt;::epsilon())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canonicalize_phase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function follows Lowdin's orthogonalization procedure to compute inverse square root of a metric <code>S</code> and/or the square root of <code>S</code> based on the given condition number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>The type of output to return. It can be one of the following:<ul>
<li><a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15a02129bb861061d1a052c592e2dc6b383">OrthogOutput::X</a>: Returns the inverse square root <code>X</code>.</li>
<li><a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15a86f780010dd9309712d1dd4d9886647d">OrthogOutput::XAndXInverse</a>: Returns a tuple containing the inverse square root <code>X</code> and its inverse.</li>
<li>OrthogOutput::EigenvaluesAndEigenvectors: Returns a tuple containing the eigenvalues and eigenvectors of <code>S</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S_array</td><td>The input metric </td></tr>
    <tr><td class="paramname">symmetric</td><td>if false, compute canonical generalized inverse (i.e., # of columns of <code>X</code> &lt;= # of rows of <code>X</code>), else symmetric (i.e., # of columns of <code>X</code> == # of rows of <code>X</code>) </td></tr>
    <tr><td class="paramname">S_condition_number_threshold</td><td>max condition number of the reconstructed metric (&lsquo;S&rsquo;=adjoint(Xinv).Xinv<code>) or its inverse (</code>S'^{-1}=X.adjoint(X)<code>) \return returns based on what @Output is set to \throws <a class="el" href="classmpqc_1_1_tolerance_exceeded.html">ToleranceExceeded</a> If the input metric</code>S` exceeds the threshold for negative eigenvalues. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61e7a62d038c06d4dd4b9c918944dd11" name="a61e7a62d038c06d4dd4b9c918944dd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e7a62d038c06d4dd4b9c918944dd11">&#9670;&#160;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) mpqc::math::conj </td>
          <td>(</td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>ω</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadc642265d827a61bfffe3b30ef1d269" name="aadc642265d827a61bfffe3b30ef1d269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc642265d827a61bfffe3b30ef1d269">&#9670;&#160;</a></span>coupled_cp_als()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::coupled_cp_als </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>referenceL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>referenceR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>factor_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_ALS</em> = <code>5e3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tcutALS</em> = <code>5e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SVD_initial_guess</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SVD_rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>REQUIRES BTAS Calculates the canonical product (CP) decomposition of two reference tensors where the first factor of both tensors are eqiuvalent and minimize both loss functions at a specific rank using alternating least squares (ALS) method in BTAS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">referenceL</td><td>In: First reference tensor to be decomposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">referenceR</td><td>In: Second reference tensor to be decomposed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factor_matrices</td><td>In: empty vector. Out: Set of \( N_{left} +
*N_{right} - 1 \) CP-factor matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conv</td><td>convergence test used to determine if ALS optmization is finished </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symm</td><td>A list which tells solver which modes are equivalent should be ordered such that later modes equal earlier modes. If empty all modes will be optimized independently </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>1 Block size of the rank dimension for the factor matrices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>0 what is the CP decomposition rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>1 if SVD_rank &lt; rank how many columns to build rank per optimization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a897e3118c62183307f83e06c61696784" name="a897e3118c62183307f83e06c61696784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897e3118c62183307f83e06c61696784">&#9670;&#160;</a></span>cp_als_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , class conv_class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array mpqc::math::cp_als_rank </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>factor_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>symmetries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">conv_class &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_ALS</em> = <code>5e3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_pI</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direct</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recompose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>REQUIRES BTAS Calculates the canonical product (CP) decomposition of /c reference to a specific rank using alternating least squares (ALS) method in BTAS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>In: tensor to be decomposed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factor_matrices</td><td>In: empty vector. Out: Set of N CP-factor matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetries</td><td>A list which tells solver which modes are equivalent should be ordered such that later modes equal earlier modes. If empty all modes will be optimized independently </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conv</td><td>convergence test used to determine if ALS optmization is finished </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>1 Block size of the rank dimension for the factor matrices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>0 what is the CP decomposition rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_als</td><td>1e3 max number of iterations to optimize rank r factors using ALS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fast_pI</td><td>true Should ALS use a fast pseudo inverse scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direct</td><td>true Should the method compute the ALS without the Khatri-Rao product </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recompose</td><td>false Return the CP approximation of tensor <code>reference</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CP reference approximate tensor. </dd></dl>

</div>
</div>
<a id="a71238d9f94c56148031cef5db5ed38ae" name="a71238d9f94c56148031cef5db5ed38ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71238d9f94c56148031cef5db5ed38ae">&#9670;&#160;</a></span>cp_decomp_for_LT_T()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::cp_decomp_for_LT_T </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Xab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Xai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>factor_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_ALS</em> = <code>5e3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tcutALS</em> = <code>1e-2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_pI</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>REQUIRES BTAS Specialized version of cp_df_als_rank for LT (T)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Xab</td><td>In: Left side of reference tensor product to be decomposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Xai</td><td>In: Right side of reference tensor product to be decomposed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factor_matrices</td><td>In: empty vector. Out: Set of N CP-factor matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>1 Block size of the rank dimension for the factor matrices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>0 what is the CP decomposition rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_als</td><td>5e3 max number of iterations to optimize rank r factors using ALS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcutALS</td><td>1e-2 ALS stopping parameter using BTAS FitCheck </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fast_pI</td><td>true Should ALS use a fast pseudo inverse scheme </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5da6384adde9d6994093613bab62c2c" name="ab5da6384adde9d6994093613bab62c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5da6384adde9d6994093613bab62c2c">&#9670;&#160;</a></span>cp_df_als_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , class conv_class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::cp_df_als_rank </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>referenceL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>referenceR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>ref_full</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>factor_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">conv_class &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>symm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_ALS</em> = <code>5e3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_pI</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>REQUIRES BTAS Calculates the canonical product (CP) decomposition of a reference ( created via a tensor contraction of <code>referenceL</code> and <code>referenceLR</code> over the 2 references first mode) ata specific rank using alternating least squares (ALS) method in BTAS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">referenceL</td><td>In: Left side of reference tensor product to be decomposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">referenceR</td><td>In: Right side of reference tensor product to be decomposed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factor_matrices</td><td>In: empty vector. Out: Set of N CP-factor matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conv</td><td>convergence test used to determine if ALS optmization is finished </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symm</td><td>A list which tells solver which modes are equivalent should be ordered such that later modes equal earlier modes. If empty all modes will be optimized independently </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>1 Block size of the rank dimension for the factor matrices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>0 what is the CP decomposition rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_als</td><td>1e3 max number of iterations to optimize rank r factors using ALS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fast_pI</td><td>true Should ALS use a fast pseudo inverse scheme </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b4b962a6ffd3534d25786e0754fa998" name="a9b4b962a6ffd3534d25786e0754fa998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4b962a6ffd3534d25786e0754fa998">&#9670;&#160;</a></span>cp_exchange_formation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::cp_exchange_formation </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>referenceL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>referenceR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>factor_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_ALS</em> = <code>5e3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tcutALS</em> = <code>1e-2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_pI</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>REQUIRES BTAS Specialized version of cp_df_als_rank Assumes one is using 2 order-3 reference tensors after decomposition forms order-3 factors in the order (<code>referenceL\iline</code>  482 \( \in \mathbf{R}^{X
*\times a \times i} \) <code>referenceR\iline</code>  483 \( \in \mathbf{R}^{X \times b \times j}
*\)) \( f_1 \in \mathbf{R}^{a\times b \times r}\) \( f_2 \in
*\mathbf{R}^{a\times j \times r}\) \( f_3 \in \mathbf{R}^{i\times b \times
*r}\) \( f_4 \in \mathbf{R}^{i\times j \times r}\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">referenceL</td><td>In: Left side of reference tensor product to be decomposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">referenceR</td><td>In: Right side of reference tensor product to be decomposed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factor_matrices</td><td>In: empty vector. Out: Set of N CP-factor matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>1 Block size of the rank dimension for the factor matrices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>0 what is the CP decomposition rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_als</td><td>5e3 max number of iterations to optimize rank r factors using ALS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcutALS</td><td>1e-2 ALS stopping parameter using BTAS FitCheck </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fast_pI</td><td>true Should ALS use a fast pseudo inverse scheme </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a120b57d0bb436815d10efee45407bc78" name="a120b57d0bb436815d10efee45407bc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120b57d0bb436815d10efee45407bc78">&#9670;&#160;</a></span>cp_rals_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , class conv_class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array mpqc::math::cp_rals_rank </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>factor_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>symmetries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">conv_class &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_ALS</em> = <code>5e3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_pI</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direct</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recompose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>REQUIRES BTAS Calculates the canonical product (CP) decomposition of /c reference to a specific rank using a regularized alternating least squares (RALS) method in BTAS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>In: tensor to be decomposed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factor_matrices</td><td>In: empty vector. Out: Set of N CP-factor matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetries</td><td>A list which tells solver which modes are equivalent should be ordered such that later modes equal earlier modes. If empty all modes will be optimized independently </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conv</td><td>convergence test used to determine if ALS optmization is finished </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>1 Block size of the rank dimension for the factor matrices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>0 what is the CP decomposition rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_als</td><td>1e3 max number of iterations to optimize rank r factors using ALS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fast_pI</td><td>true Should ALS use a fast pseudo inverse scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direct</td><td>true Should the method compute the ALS without the Khatri-Rao product </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recompose</td><td>false Return the CP approximation of tensor <code>reference</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CP reference approximate tensor. </dd></dl>

</div>
</div>
<a id="a661e50c8b8d2539452ba34478dc5846e" name="a661e50c8b8d2539452ba34478dc5846e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661e50c8b8d2539452ba34478dc5846e">&#9670;&#160;</a></span>create_diagonal_array_from_eigen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, Policy &gt; mpqc::math::create_diagonal_array_from_eigen </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::TiledRange1 &amp;&#160;</td>
          <td class="paramname"><em>trange1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::TiledRange1 &amp;&#160;</td>
          <td class="paramname"><em>trange2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Tile::numeric_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac97dc93fc3e75497ea1a49440f8d1fa1" name="ac97dc93fc3e75497ea1a49440f8d1fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97dc93fc3e75497ea1a49440f8d1fa1">&#9670;&#160;</a></span>eigen_estimator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , std::enable_if_t&lt; TiledArray::detail::is_contiguous_tensor_v&lt; Tile &gt; &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::eigen_estimator </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; TA::detail::real_t&lt; Tile &gt;, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tile const &amp;&#160;</td>
          <td class="paramname"><em>tile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67e58c3d48bb9f9135f02a85fc3efaeb" name="a67e58c3d48bb9f9135f02a85fc3efaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e58c3d48bb9f9135f02a85fc3efaeb">&#9670;&#160;</a></span>eigen_to_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt;::type &gt; mpqc::math::eigen_to_array </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a>&lt; typename Tile::numeric_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::TiledRange1&#160;</td>
          <td class="paramname"><em>tr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::TiledRange1&#160;</td>
          <td class="paramname"><em>tr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cut</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert eigen(replicated) to sparse TA::DistArray </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tile</td><td></td></tr>
    <tr><td class="paramname">Policy</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td></td></tr>
    <tr><td class="paramname">M</td><td>Eigen matrix, must be replicated on all nodes </td></tr>
    <tr><td class="paramname">tr0</td><td>the TiledArray::TiledRange1 object for the row dimension of the result </td></tr>
    <tr><td class="paramname">tr1</td><td>the TiledArray::TiledRange1 object for the column dimension of the result </td></tr>
    <tr><td class="paramname">cut</td><td>compression parameter, only used for some <code>Tile</code> types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3725bcfb4af1fb6e934aee66f1a850ff" name="a3725bcfb4af1fb6e934aee66f1a850ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3725bcfb4af1fb6e934aee66f1a850ff">&#9670;&#160;</a></span>eigen_to_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::DensePolicy &gt;::type &gt; mpqc::math::eigen_to_array </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a>&lt; typename Tile::numeric_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::TiledRange1&#160;</td>
          <td class="paramname"><em>tr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::TiledRange1&#160;</td>
          <td class="paramname"><em>tr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cut</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert eigen(replicated) to dense TA::DistArray </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tile</td><td></td></tr>
    <tr><td class="paramname">Policy</td><td>TA::DensePolicy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td></td></tr>
    <tr><td class="paramname">M</td><td>Eigen matrix, must be replicated on all nodes </td></tr>
    <tr><td class="paramname">tr0</td><td>the TiledArray::TiledRange1 object for the row dimension of the result </td></tr>
    <tr><td class="paramname">tr1</td><td>the TiledArray::TiledRange1 object for the column dimension of the result </td></tr>
    <tr><td class="paramname">cut</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="afb4a7f2760bcf71de9f3fe3417a9d765" name="afb4a7f2760bcf71de9f3fe3417a9d765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4a7f2760bcf71de9f3fe3417a9d765">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mpqc::math::empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ca9771481c0cbee06ce4cf34e69c13e" name="a0ca9771481c0cbee06ce4cf34e69c13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca9771481c0cbee06ce4cf34e69c13e">&#9670;&#160;</a></span>eval_guess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; typename Array::scalar_type, 2 &gt; mpqc::math::eval_guess </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes {min,max} eigenvalue bounds for a square matrix <code>A</code> using Gerschgorin circle theorem </p>
<dl class="section note"><dt>Note</dt><dd><a href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">https://en.wikipedia.org/wiki/Gershgorin_circle_theorem</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>a DistArray type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>a square matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>{min,max} eigenvalue bounds </dd></dl>

</div>
</div>
<a id="af36abffc93af1514a989f45f298e9535" name="af36abffc93af1514a989f45f298e9535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36abffc93af1514a989f45f298e9535">&#9670;&#160;</a></span>gauss_legendre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt; mpqc::math::gauss_legendre </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function uses orthogonal polynomial approach for obtaining quadrature roots and weights. Taken from paper: Gaussian Quadrature and the Eigenvalue Problem by John A. Gubner. <a href="http://gubner.ece.wisc.edu/gaussquad.pdf">http://gubner.ece.wisc.edu/gaussquad.pdf</a> The code is outlined at Example 15: Legendre polynomials </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>the number of quadrature points</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the left end of the quadrature interval </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the right end of the quadrature interval, <code>b</code> &gt;= <b>a</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>{x,w}</code> = the {roots,weights} of Gauss-Legendre quadrature on [a,b], in the order of increasing <code>x</code> </dd></dl>

</div>
</div>
<a id="a222a9e0202d4e8d84e2c8f52a48607aa" name="a222a9e0202d4e8d84e2c8f52a48607aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222a9e0202d4e8d84e2c8f52a48607aa">&#9670;&#160;</a></span>gemm() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::math::GemmHelper const &amp;&#160;</td>
          <td class="paramname"><em>gh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5701fb7809f62251ec565822cf04b0e9" name="a5701fb7809f62251ec565822cf04b0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5701fb7809f62251ec565822cf04b0e9">&#9670;&#160;</a></span>gemm() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::math::GemmHelper const &amp;&#160;</td>
          <td class="paramname"><em>gh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab977cbde2e8c2793562f7a6a405715eb" name="ab977cbde2e8c2793562f7a6a405715eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab977cbde2e8c2793562f7a6a405715eb">&#9670;&#160;</a></span>gemm() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::TensorD mpqc::math::gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::TensorD const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::math::GemmHelper const &amp;&#160;</td>
          <td class="paramname"><em>gh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eb79c0f1088481f835ae1c0dd24930f" name="a2eb79c0f1088481f835ae1c0dd24930f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb79c0f1088481f835ae1c0dd24930f">&#9670;&#160;</a></span>gemm() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::TensorD mpqc::math::gemm </td>
          <td>(</td>
          <td class="paramtype">TA::TensorD &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::TensorD const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::math::GemmHelper const &amp;&#160;</td>
          <td class="paramname"><em>gh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafdf899e26d1bb277ee714b79dc8a317" name="aafdf899e26d1bb277ee714b79dc8a317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdf899e26d1bb277ee714b79dc8a317">&#9670;&#160;</a></span>generalized_inverse_sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, Policy &gt; mpqc::math::generalized_inverse_sqrt </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>target_condition_number</em> = <code>1e8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>try_cholesky</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes (generalized) inverse square root of a hermitian positive definite matrix, namely for matrix <code>A</code> it computes <code>B</code> such that <code>B * A * adjoint(B)</code> is identity </p><dl class="section note"><dt>Note</dt><dd>tries TA::cholesky_linv, if that fails uses conditioned_orthogonalizer(symmetric=false,target_condition_number) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a positive definite matrix </td></tr>
    <tr><td class="paramname">target_condition_number</td><td>the target condition number to use if cholesky_linv failed </td></tr>
    <tr><td class="paramname">try_cholesky</td><td>if false, will not try Cholesky-based generalized inv sqrt and instead immediately compute canonical generalized square root; if true, will try Cholesky-based route first; set to false if Cholesky generates illegal instruction signals instead of returning errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generalized inverse square root of <code>A</code> </dd></dl>

</div>
</div>
<a id="a29fc3080f46a77a1296a675b4866556a" name="a29fc3080f46a77a1296a675b4866556a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fc3080f46a77a1296a675b4866556a">&#9670;&#160;</a></span>generate_cc_cp3_decomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename integral , typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::generate_cc_cp3_decomp </td>
          <td>(</td>
          <td class="paramtype">integral &amp;&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>had_block_size_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cp3_rank_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reduced_abcd_memory_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_block_factor_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vir_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cp3_precision_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta_als_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates all necessary integrals for cc cp3 currently used in CCSD and CCSDT</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ints</td><td>In: CC integrals will access Xab and possibly Xai Out: Will compute X * T (as described above) and will compute cp factor matrices</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">had_block_size_</td><td>size of the unocc blocking for mixed contraction</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp3_rank_</td><td>rank of the CP decomposition of Xab </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reduced_abcd_memory_</td><td>If reduced_abcd_memory_ = false will also need Xai contraction</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank_block_factor_</td><td>Used to compute the block size for rank mode rank block = <code>rank_block_factor_</code> * <code>vir_block_size</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp3_precision_</td><td>ALS optimization stopping condition parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ta_als_</td><td>using TA to compute CP decomposition ** currently disabled ** </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e64267f3e8b8e17c90cedfbb2f1f506" name="a6e64267f3e8b8e17c90cedfbb2f1f506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e64267f3e8b8e17c90cedfbb2f1f506">&#9670;&#160;</a></span>generate_cc_cp4_decomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename integral , typename TArray , typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::generate_cc_cp4_decomp </td>
          <td>(</td>
          <td class="paramtype">integral &amp;&#160;</td>
          <td class="paramname"><em>ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&#160;</td>
          <td class="paramname"><em>Xma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&#160;</td>
          <td class="paramname"><em>Cma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&#160;</td>
          <td class="paramname"><em>Cmi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>had_block_size_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cp3_rank_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cp4_rank_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_block_factor_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vir_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cp3_precision_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cp4_precision_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates all necessary integrals for cc cp3 + cp4 implementation currently used in CCSD and CCSDT approximation computes the <a class="el" href="classmpqc_1_1math_1_1_c_p3.html" title="Computes 3-way CP decomposition of a order-3 tensor.">CP3</a> decomposition of Xab and the CP4 decomposition of \( G^{a
\mu}_{ib} \)</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ints</td><td>In: CC integrals will access Xab Out: Will compute X * T (as described above) and will compute cp factor matrices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">had_block_size_</td><td>size of the unocc blocking for mixed contraction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp3_rank_</td><td>rank of the CP decomposition of Xab </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reduced_abcd_memory_</td><td>If reduced_abcd_memory_ = false will also need Xai contraction</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank_block_factor_</td><td>Used to compute the block size for rank mode rank block = <code>rank_block_factor_</code> * <code>vir_block_size</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp3_precision_</td><td>ALS optimization stopping condition parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ta_als_</td><td>using TA to compute CP decomposition ** currently disabled ** </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41a7a3925d4acc87e66d5c0c1d837c87" name="a41a7a3925d4acc87e66d5c0c1d837c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a7a3925d4acc87e66d5c0c1d837c87">&#9670;&#160;</a></span>gensqrtinv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15">OrthogOutput</a> Output = OrthogOutput::X, typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc_1_1math.html#acfb508667c4e7e2b919b52d35adf107b">ConditionalOrthogOutput</a>&lt; Output, Tile, Policy &gt; mpqc::math::gensqrtinv </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_condition_number</em> = <code>1e8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canonicalize_phase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given hermitian nonnegative metric <code>S</code> computes its generalized square root <code>X</code> such that <code>adjoint(X).S.X = I</code> Hence columns of <code>X</code> define an orthonormal (possibly near-linearly-dependent, if <code>symmetric</code> is true) basis in a vector space with metric <code>S</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>if <code>Output==<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15a02129bb861061d1a052c592e2dc6b383">OrthogOutput::X</a></code> will produce X only, else will produce <code>X</code> and its pseudoinverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>hermitian non-negative matrix (typically a basis metric/Gramian) </td></tr>
    <tr><td class="paramname">symmetric</td><td>if false, compute canonical generalized inverse (i.e., # of columns of <code>X</code> &lt;= # of rows of <code>X</code>), else symmetric (i.e., # of columns of <code>X</code> == # of rows of <code>X</code>) </td></tr>
    <tr><td class="paramname">max_condition_number</td><td>max condition number of the reconstructed metric (&lsquo;S&rsquo;=adjoint(Xinv).Xinv<code>) or its inverse (</code>S'^{-1}=X.adjoint(X)<code>) \param canonicalize_phase if true, canonicalizes the phase eigenvectors of</code>S<code>using math::canonical_column_phase \return</code>Output==<a class="el" href="namespacempqc_1_1math.html#aaae50adb8d3490b303e6d1fc7846ff15a02129bb861061d1a052c592e2dc6b383">OrthogOutput::X</a> ? {X,spectral_range} : {X, Xinv, spectral_range}<code> where: -</code>X<code>is the generalized inverse square root of</code>S<code> -</code>Xinv<code>is the inverse of</code>X<code>such that</code>Xinv.X = 1<code> -</code>spectral_range<code>=</code>{smax, xtxmin, smin}` are the largest eigenvalue of S, smallest eigenvalue of reconditioned S (=Xinv^+ Xinv) and smallest eigenvalue of S </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18894bcfa7762d1ae608063cbf8bc5b6" name="a18894bcfa7762d1ae608063cbf8bc5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18894bcfa7762d1ae608063cbf8bc5b6">&#9670;&#160;</a></span>gram_schmidt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24681b119cb56ce3b4f02d27ac81d5a2" name="a24681b119cb56ce3b4f02d27ac81d5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24681b119cb56ce3b4f02d27ac81d5a2">&#9670;&#160;</a></span>gram_schmidt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D1 , typename D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gram-Schmidt orthonormalization</p>
<p><a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Algorithm">https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Algorithm</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>an orthonormal basis </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V2</td><td>input: a basis to be made orthonormal and orthogonal to <code>V1</code> ; output: orthonormal basis </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">threshold</td><td>neglects a deflated vector if its norm is less than this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd34283d2a717f729d32e0ae006fde05" name="abd34283d2a717f729d32e0ae006fde05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd34283d2a717f729d32e0ae006fde05">&#9670;&#160;</a></span>gram_schmidt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gram-Schmidt orthonormalization of a basis against another</p>
<p><a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Algorithm">https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Algorithm</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>input: a basis to be orthonormalized; output: orthonormal basis </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">threshold</td><td>neglects a deflated vector if its norm is less than this </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>if nonzero, only orthonormalize <code>[start,V.size())</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accf270c27528fa0288cc72ded598bc33" name="accf270c27528fa0288cc72ded598bc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf270c27528fa0288cc72ded598bc33">&#9670;&#160;</a></span>gram_schmidt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gram-Schmidt orthonormalization of a basis</p>
<p><a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Algorithm">https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Algorithm</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>input: a basis to be orthonormalized; output: orthonormal basis </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">threshold</td><td>neglects a deflated vector if its norm is less than this </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>if nonzero, only orthonormalize <code>[start,V.size())</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33cd9ad5a778d060ed187cba804794a1" name="a33cd9ad5a778d060ed187cba804794a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33cd9ad5a778d060ed187cba804794a1">&#9670;&#160;</a></span>heig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; typename TA::detail::scalar_t&lt; Tile &gt; &gt;, TA::DistArray&lt; Tile, Policy &gt; &gt; mpqc::math::heig </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>try_cholesky</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>B_target_condition_number</em> = <code>1e8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solves generalized hermitian eigenproblem </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a hermitian matrix </td></tr>
    <tr><td class="paramname">B</td><td>a hermitian positive-definite matrix </td></tr>
    <tr><td class="paramname">try_cholesky</td><td>if false, will not try Cholesky-based generalized inv sqrt and instead immediately compute eigen-based generalized inv sqrt; if true, will try Cholesky-based route first; set to false if Cholesky generates illegal instruction signals instead of returning errors </td></tr>
    <tr><td class="paramname">B_target_condition_number</td><td>if using eigen-based generalized inv sqrt <code>B_isqrt</code> (such that <code>B_isqrt * B * adjoint(B_isqrt)</code> is identity), use this to control the max condition number of <code>B_isqrt * adjoint(B_isqrt)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple composed of a <code>std::vector&lt;real&gt;</code> containing the eigenvalues and the corresponding eigenvectors </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this exists when <code>TA::heig(A, B)</code> is not usable directly, e.g. due to problem with zhegv in Apple Accelerate </dd></dl>

</div>
</div>
<a id="a9d53fb82cbab16761b698f2df43eafdc" name="a9d53fb82cbab16761b698f2df43eafdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d53fb82cbab16761b698f2df43eafdc">&#9670;&#160;</a></span>init_X()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array mpqc::math::init_X </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6763f49fbc5df118acb0e70f0d13220" name="ac6763f49fbc5df118acb0e70f0d13220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6763f49fbc5df118acb0e70f0d13220">&#9670;&#160;</a></span>inplace_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::inplace_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4449512dd98cecbb6de4b4b5b5af693" name="ae4449512dd98cecbb6de4b4b5b5af693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4449512dd98cecbb6de4b4b5b5af693">&#9670;&#160;</a></span>inplace_unary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::inplace_unary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a674388c45ca8c48f95e5e13fd64ca0e0" name="a674388c45ca8c48f95e5e13fd64ca0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674388c45ca8c48f95e5e13fd64ca0e0">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, Policy &gt; mpqc::math::inverse </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>try_cholesky</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes inverse of a hermitian positive-definite matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a hermitian positive-definite matrix </td></tr>
    <tr><td class="paramname">try_cholesky</td><td>if false, will not try Cholesky-based generalized inv sqrt and instead immediately compute via Eigen's fully-pivoted LU; if true, will try Cholesky-based route first; set to false if Cholesky generates illegal instruction signals instead of returning errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverse of <code>A</code> </dd></dl>

</div>
</div>
<a id="ab82da456aeca60d90c5ca5013324d8fb" name="ab82da456aeca60d90c5ca5013324d8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82da456aeca60d90c5ca5013324d8fb">&#9670;&#160;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array mpqc::math::invert </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcb1eba8e99835dd279b064a14c4c378" name="abcb1eba8e99835dd279b064a14c4c378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb1eba8e99835dd279b064a14c4c378">&#9670;&#160;</a></span>iterative_inverse_sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array mpqc::math::iterative_inverse_sqrt </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>iterative evaluation of inverse square root using 3-rd order method described in J. Chem. Phys. 126. 124104 (2007) </p>

</div>
</div>
<a id="a57a3a0eb7a0a10ea4c0bd4a56a8f8340" name="a57a3a0eb7a0a10ea4c0bd4a56a8f8340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t npts, std::size_t variant = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; mpqc::math::make_ahrens_beylkin_quadrature </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>make Ahrens-Beylkin quadrature for a sphere of radius <code>r</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">npts</td><td>number of (off-center) points per icosahedron face; the total number of points is <code>60*npts+12</code>. </td></tr>
    <tr><td class="paramname">variant</td><td>quadrature variant, for <code>npts&gt;1</code> there exist multiple solutions </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the sphere radius </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of quadrature points and their weights </dd></dl>

</div>
</div>
<a id="a61b8724a742955b64a2e05aaf16c3186" name="a61b8724a742955b64a2e05aaf16c3186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b8724a742955b64a2e05aaf16c3186">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; mpqc::math::make_ahrens_beylkin_quadrature </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>npts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>variant</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>make Ahrens-Beylkin quadrature for a sphere of radius <code>r</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the sphere radius </td></tr>
    <tr><td class="paramname">npts</td><td>number of (off-center) points per icosahedron face; the total number of points is <code>60*npts+12</code>. </td></tr>
    <tr><td class="paramname">variant</td><td>quadrature variant, for <code>npts&gt;1</code> there exist multiple solutions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of quadrature points and their weights </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmpqc_1_1_programming_error.html">ProgrammingError</a></td><td>if this combination of <code>npts</code> and <code>variant</code> is not available </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97b948bc27e54817c4f77b7ed399c90a" name="a97b948bc27e54817c4f77b7ed399c90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b948bc27e54817c4f77b7ed399c90a">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 1, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 1, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97b948bc27e54817c4f77b7ed399c90a" name="a97b948bc27e54817c4f77b7ed399c90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b948bc27e54817c4f77b7ed399c90a">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 1, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 1, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77426741a6b2dd116f83d365f79d047f" name="a77426741a6b2dd116f83d365f79d047f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77426741a6b2dd116f83d365f79d047f">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 10, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 10, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77426741a6b2dd116f83d365f79d047f" name="a77426741a6b2dd116f83d365f79d047f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77426741a6b2dd116f83d365f79d047f">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 10, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 10, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab99aa556daa7b865b3ec0d3b7f789b28" name="ab99aa556daa7b865b3ec0d3b7f789b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99aa556daa7b865b3ec0d3b7f789b28">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 10, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 10, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab99aa556daa7b865b3ec0d3b7f789b28" name="ab99aa556daa7b865b3ec0d3b7f789b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99aa556daa7b865b3ec0d3b7f789b28">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 10, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 10, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81c1eb6fbe831346575cb15b35e7cd2e" name="a81c1eb6fbe831346575cb15b35e7cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c1eb6fbe831346575cb15b35e7cd2e">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 11, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 11, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81c1eb6fbe831346575cb15b35e7cd2e" name="a81c1eb6fbe831346575cb15b35e7cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c1eb6fbe831346575cb15b35e7cd2e">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 11, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 11, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70235d60235c026551843bc194080eff" name="a70235d60235c026551843bc194080eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70235d60235c026551843bc194080eff">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 11, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 11, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70235d60235c026551843bc194080eff" name="a70235d60235c026551843bc194080eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70235d60235c026551843bc194080eff">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 11, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 11, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dcd7d2fe60b1c3c7f9751055615c673" name="a3dcd7d2fe60b1c3c7f9751055615c673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd7d2fe60b1c3c7f9751055615c673">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 11, 2 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 11, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dcd7d2fe60b1c3c7f9751055615c673" name="a3dcd7d2fe60b1c3c7f9751055615c673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd7d2fe60b1c3c7f9751055615c673">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 11, 2 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 11, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0166013ca801782b3b19e5c780fe6a6" name="af0166013ca801782b3b19e5c780fe6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0166013ca801782b3b19e5c780fe6a6">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 12, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 12, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0166013ca801782b3b19e5c780fe6a6" name="af0166013ca801782b3b19e5c780fe6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0166013ca801782b3b19e5c780fe6a6">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 12, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 12, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a794e4d61c1d6afc66145124995bcf6ab" name="a794e4d61c1d6afc66145124995bcf6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794e4d61c1d6afc66145124995bcf6ab">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 13, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 13, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a794e4d61c1d6afc66145124995bcf6ab" name="a794e4d61c1d6afc66145124995bcf6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794e4d61c1d6afc66145124995bcf6ab">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 13, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 13, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28827c6e371022f07dca6bd26b529de5" name="a28827c6e371022f07dca6bd26b529de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28827c6e371022f07dca6bd26b529de5">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 13, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 13, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28827c6e371022f07dca6bd26b529de5" name="a28827c6e371022f07dca6bd26b529de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28827c6e371022f07dca6bd26b529de5">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 13, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 13, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadd0a133b038fcbd85fdc6895f0a62e8" name="aadd0a133b038fcbd85fdc6895f0a62e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd0a133b038fcbd85fdc6895f0a62e8">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 15, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 15, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadd0a133b038fcbd85fdc6895f0a62e8" name="aadd0a133b038fcbd85fdc6895f0a62e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd0a133b038fcbd85fdc6895f0a62e8">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 15, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 15, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8109a498476b264c6a47b507de7bc239" name="a8109a498476b264c6a47b507de7bc239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8109a498476b264c6a47b507de7bc239">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 15, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 15, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8109a498476b264c6a47b507de7bc239" name="a8109a498476b264c6a47b507de7bc239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8109a498476b264c6a47b507de7bc239">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 15, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 15, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa86202afd7aefe37642118b5ea7b0c2e" name="aa86202afd7aefe37642118b5ea7b0c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86202afd7aefe37642118b5ea7b0c2e">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 16, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 16, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa86202afd7aefe37642118b5ea7b0c2e" name="aa86202afd7aefe37642118b5ea7b0c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86202afd7aefe37642118b5ea7b0c2e">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 16, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 16, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8eca616347adbd746018d208a3929004" name="a8eca616347adbd746018d208a3929004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eca616347adbd746018d208a3929004">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 16, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 16, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8eca616347adbd746018d208a3929004" name="a8eca616347adbd746018d208a3929004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eca616347adbd746018d208a3929004">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 16, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 16, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af66735561c4852148e9a98a960a7c5f9" name="af66735561c4852148e9a98a960a7c5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66735561c4852148e9a98a960a7c5f9">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af66735561c4852148e9a98a960a7c5f9" name="af66735561c4852148e9a98a960a7c5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66735561c4852148e9a98a960a7c5f9">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace7595902a76f8f83bdfff003cf5015d" name="ace7595902a76f8f83bdfff003cf5015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7595902a76f8f83bdfff003cf5015d">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace7595902a76f8f83bdfff003cf5015d" name="ace7595902a76f8f83bdfff003cf5015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7595902a76f8f83bdfff003cf5015d">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1418c5950a39359917965b53edf06e94" name="a1418c5950a39359917965b53edf06e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1418c5950a39359917965b53edf06e94">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 2 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1418c5950a39359917965b53edf06e94" name="a1418c5950a39359917965b53edf06e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1418c5950a39359917965b53edf06e94">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 2 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f885d449ababbac758b1f7dd9f5b582" name="a6f885d449ababbac758b1f7dd9f5b582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f885d449ababbac758b1f7dd9f5b582">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 3 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 3 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f885d449ababbac758b1f7dd9f5b582" name="a6f885d449ababbac758b1f7dd9f5b582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f885d449ababbac758b1f7dd9f5b582">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 3 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 3 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30294d12dd1054fec2caf73d9e7db600" name="a30294d12dd1054fec2caf73d9e7db600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30294d12dd1054fec2caf73d9e7db600">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 4 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30294d12dd1054fec2caf73d9e7db600" name="a30294d12dd1054fec2caf73d9e7db600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30294d12dd1054fec2caf73d9e7db600">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 2, 4 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 2, 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acac9f83924bbb9d00190dbedb81f8f3a" name="acac9f83924bbb9d00190dbedb81f8f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac9f83924bbb9d00190dbedb81f8f3a">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 3, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 3, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acac9f83924bbb9d00190dbedb81f8f3a" name="acac9f83924bbb9d00190dbedb81f8f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac9f83924bbb9d00190dbedb81f8f3a">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 3, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 3, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76646641e2c64e167173f20a63c69918" name="a76646641e2c64e167173f20a63c69918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76646641e2c64e167173f20a63c69918">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 3, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 3, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76646641e2c64e167173f20a63c69918" name="a76646641e2c64e167173f20a63c69918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76646641e2c64e167173f20a63c69918">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 3, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 3, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6b3a9d07e23193561cc36de24f4c170" name="aa6b3a9d07e23193561cc36de24f4c170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b3a9d07e23193561cc36de24f4c170">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 3, 2 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 3, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6b3a9d07e23193561cc36de24f4c170" name="aa6b3a9d07e23193561cc36de24f4c170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b3a9d07e23193561cc36de24f4c170">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 3, 2 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 3, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a0ee26785a3bc761076d8facccd829b" name="a8a0ee26785a3bc761076d8facccd829b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0ee26785a3bc761076d8facccd829b">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 3, 3 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 3, 3 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a0ee26785a3bc761076d8facccd829b" name="a8a0ee26785a3bc761076d8facccd829b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0ee26785a3bc761076d8facccd829b">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 3, 3 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 3, 3 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cd8281f1316e2815d0aead25f7998fc" name="a5cd8281f1316e2815d0aead25f7998fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd8281f1316e2815d0aead25f7998fc">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 5, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 5, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cd8281f1316e2815d0aead25f7998fc" name="a5cd8281f1316e2815d0aead25f7998fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd8281f1316e2815d0aead25f7998fc">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 5, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 5, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4ada44b1af94c90bd16f5985b723b17" name="ad4ada44b1af94c90bd16f5985b723b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ada44b1af94c90bd16f5985b723b17">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 5, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 5, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4ada44b1af94c90bd16f5985b723b17" name="ad4ada44b1af94c90bd16f5985b723b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ada44b1af94c90bd16f5985b723b17">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 5, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 5, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add8c3d48ee7d5724475292f1d04033d9" name="add8c3d48ee7d5724475292f1d04033d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8c3d48ee7d5724475292f1d04033d9">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 5, 2 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 5, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add8c3d48ee7d5724475292f1d04033d9" name="add8c3d48ee7d5724475292f1d04033d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8c3d48ee7d5724475292f1d04033d9">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 5, 2 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 5, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af38045c346476fdd7f12b9c9c9693bde" name="af38045c346476fdd7f12b9c9c9693bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38045c346476fdd7f12b9c9c9693bde">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 6, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 6, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af38045c346476fdd7f12b9c9c9693bde" name="af38045c346476fdd7f12b9c9c9693bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38045c346476fdd7f12b9c9c9693bde">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 6, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 6, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af315d9743fbf39bb3eb7f35e6a5379ca" name="af315d9743fbf39bb3eb7f35e6a5379ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af315d9743fbf39bb3eb7f35e6a5379ca">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 6, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 6, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af315d9743fbf39bb3eb7f35e6a5379ca" name="af315d9743fbf39bb3eb7f35e6a5379ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af315d9743fbf39bb3eb7f35e6a5379ca">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 6, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 6, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa915356477be794f08fa59a5355f107d" name="aa915356477be794f08fa59a5355f107d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa915356477be794f08fa59a5355f107d">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 6, 2 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 6, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa915356477be794f08fa59a5355f107d" name="aa915356477be794f08fa59a5355f107d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa915356477be794f08fa59a5355f107d">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 6, 2 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 6, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ef45947cebf88f221189e34b816e114" name="a3ef45947cebf88f221189e34b816e114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef45947cebf88f221189e34b816e114">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 7, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 7, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ef45947cebf88f221189e34b816e114" name="a3ef45947cebf88f221189e34b816e114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef45947cebf88f221189e34b816e114">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 7, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 7, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf5d4f24cf4c14d2fa679656856c1df7" name="aaf5d4f24cf4c14d2fa679656856c1df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5d4f24cf4c14d2fa679656856c1df7">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 7, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 7, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf5d4f24cf4c14d2fa679656856c1df7" name="aaf5d4f24cf4c14d2fa679656856c1df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5d4f24cf4c14d2fa679656856c1df7">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 7, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 7, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a559624947dea945cceae6bd26332ee16" name="a559624947dea945cceae6bd26332ee16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559624947dea945cceae6bd26332ee16">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 7, 2 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 7, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a559624947dea945cceae6bd26332ee16" name="a559624947dea945cceae6bd26332ee16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559624947dea945cceae6bd26332ee16">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 7, 2 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 7, 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8205ae1721ee304e708b0bd91b9fb3fa" name="a8205ae1721ee304e708b0bd91b9fb3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8205ae1721ee304e708b0bd91b9fb3fa">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 8, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 8, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8205ae1721ee304e708b0bd91b9fb3fa" name="a8205ae1721ee304e708b0bd91b9fb3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8205ae1721ee304e708b0bd91b9fb3fa">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 8, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 8, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45f51bde6789e74f3872948c0d5689d4" name="a45f51bde6789e74f3872948c0d5689d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f51bde6789e74f3872948c0d5689d4">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 8, 1 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 8, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45f51bde6789e74f3872948c0d5689d4" name="a45f51bde6789e74f3872948c0d5689d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f51bde6789e74f3872948c0d5689d4">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 8, 1 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 8, 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89ae222c074784c764febf0defaa4bbe" name="a89ae222c074784c764febf0defaa4bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ae222c074784c764febf0defaa4bbe">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 9, 0 &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 9, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89ae222c074784c764febf0defaa4bbe" name="a89ae222c074784c764febf0defaa4bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ae222c074784c764febf0defaa4bbe">&#9670;&#160;</a></span>make_ahrens_beylkin_quadrature&lt; 9, 0 &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, double &gt; &gt; <a class="el" href="namespacempqc_1_1math.html#a57a3a0eb7a0a10ea4c0bd4a56a8f8340">mpqc::math::make_ahrens_beylkin_quadrature</a>&lt; 9, 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a79a4f34ce13e36d2f3262e8cb9fdc0" name="a9a79a4f34ce13e36d2f3262e8cb9fdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a79a4f34ce13e36d2f3262e8cb9fdc0">&#9670;&#160;</a></span>make_clustering_method_string2type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto mpqc::math::make_clustering_method_string2type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5716b7e21b52c0e42fbb4ecc252a3fea" name="a5716b7e21b52c0e42fbb4ecc252a3fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5716b7e21b52c0e42fbb4ecc252a3fea">&#9670;&#160;</a></span>make_clustering_method_type2string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto mpqc::math::make_clustering_method_type2string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42c5cc9ff270f29c7ea311dcf6165d83" name="a42c5cc9ff270f29c7ea311dcf6165d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c5cc9ff270f29c7ea311dcf6165d83">&#9670;&#160;</a></span>match_numeric_range_degeneracies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, std::vector&lt; std::size_t &gt; &gt; mpqc::math::match_numeric_range_degeneracies </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference_degeneracies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::detail::scalar_t&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>rel_eps_upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes sizes of contiguous degenerate sets in a (not-necessarily-sorted) numeric range while adaptively refining the comparison threshold to match the reference degeneracies </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Numeric</td><td>a numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>a range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reference_degeneracies</td><td>vector of degeneracies to be matched </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_eps_upper_bound</td><td>max value of the relative comparison threshold (<code>rel_eps</code>) to consider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair or values, first of which is a boolean that indicates whether <code>rel_eps</code> could be determined such that the degenerate set sizes matched those in reference_degeneracies; if the flag is true the second value is a vector of containing the size of degenerate subsets in <code>range</code> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>rel_eps_upper_bound&gt;0 &amp;&amp; rel_eps_upper_bound&lt;=2</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacempqc_1_1math.html#a9f5e1bbc021c37a113f71d50f3fb5b70">check_numeric_range_degeneracies</a> </dd></dl>

</div>
</div>
<a id="aa81e7a4a6cbfebe5b799ef5d68800682" name="aa81e7a4a6cbfebe5b799ef5d68800682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81e7a4a6cbfebe5b799ef5d68800682">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max of a decomposed tensor tile Currently not recommended due to implementation details. </p>

</div>
</div>
<a id="a7cc91636eb2d39c979d0b0eeadc29e50" name="a7cc91636eb2d39c979d0b0eeadc29e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc91636eb2d39c979d0b0eeadc29e50">&#9670;&#160;</a></span>max_eval_est()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mpqc::math::max_eval_est </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acada6b831f29eff14383b95ef70b139d" name="acada6b831f29eff14383b95ef70b139d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acada6b831f29eff14383b95ef70b139d">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the min of a decomposed tensor tile Currently not recommended due to implementation details. </p>

</div>
</div>
<a id="ae6a97cbe6ee465c79280f5f804fdd9ee" name="ae6a97cbe6ee465c79280f5f804fdd9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a97cbe6ee465c79280f5f804fdd9ee">&#9670;&#160;</a></span>min_eval_est()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mpqc::math::min_eval_est </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1da828bcd8f09edb5650a2090ed8f459" name="a1da828bcd8f09edb5650a2090ed8f459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da828bcd8f09edb5650a2090ed8f459">&#9670;&#160;</a></span>min_eval_guess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mpqc::math::min_eval_guess </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa10d576dae7c565485694ff942d8b80f" name="aa10d576dae7c565485694ff942d8b80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10d576dae7c565485694ff942d8b80f">&#9670;&#160;</a></span>mult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a822900574da2e99a826a68c6426084a8" name="a822900574da2e99a826a68c6426084a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822900574da2e99a826a68c6426084a8">&#9670;&#160;</a></span>mult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cb888a534b96627bb7871d47e94cce9" name="a3cb888a534b96627bb7871d47e94cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb888a534b96627bb7871d47e94cce9">&#9670;&#160;</a></span>mult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad41f77a7faf67dff56e494d30d341127" name="ad41f77a7faf67dff56e494d30d341127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41f77a7faf67dff56e494d30d341127">&#9670;&#160;</a></span>mult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d6e3d336a7a1e4ec9415e23d13ee275" name="a5d6e3d336a7a1e4ec9415e23d13ee275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6e3d336a7a1e4ec9415e23d13ee275">&#9670;&#160;</a></span>mult_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::mult_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16b274fa8bb4dab60d8ae2ac65e427cc" name="a16b274fa8bb4dab60d8ae2ac65e427cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b274fa8bb4dab60d8ae2ac65e427cc">&#9670;&#160;</a></span>mult_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::mult_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad875575ffa8e3a601eb672889bd177e3" name="ad875575ffa8e3a601eb672889bd177e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad875575ffa8e3a601eb672889bd177e3">&#9670;&#160;</a></span>nderiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t mpqc::math::nderiv </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nparam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>deriv_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nparam</td><td>number of function parameters </td></tr>
    <tr><td class="paramname">deriv_order</td><td>order of the derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of derivatives of order <code>deriv_order</code> of a multivariate function with <code>nparam</code> parameters </dd></dl>

</div>
</div>
<a id="a7357cfcdf5baa03d9c5653213e2f539d" name="a7357cfcdf5baa03d9c5653213e2f539d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7357cfcdf5baa03d9c5653213e2f539d">&#9670;&#160;</a></span>neg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::neg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae313f038e6c0631123fbbc40b18d8c7" name="aae313f038e6c0631123fbbc40b18d8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae313f038e6c0631123fbbc40b18d8c7">&#9670;&#160;</a></span>neg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::neg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fbf517f32d776fd6016b7ea222d6302" name="a6fbf517f32d776fd6016b7ea222d6302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbf517f32d776fd6016b7ea222d6302">&#9670;&#160;</a></span>neg_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::neg_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b137756d0c22a809987f46d1c583259" name="a0b137756d0c22a809987f46d1c583259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b137756d0c22a809987f46d1c583259">&#9670;&#160;</a></span>neg_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::neg_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22dbd6d3c89024c21af4c1e6b13075e4" name="a22dbd6d3c89024c21af4c1e6b13075e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dbd6d3c89024c21af4c1e6b13075e4">&#9670;&#160;</a></span>nnheig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; double &gt;, TA::DistArray&lt; Tile, Policy &gt; &gt; mpqc::math::nnheig </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>evd_max_condition_number</em> = <code>1e8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canonicalize_phase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes eigenvalues and eigenvectors of non-negative hermitian matrix A </p>
<p>This function will first try Hermitian EVD (<code>TA::heig</code>); if the resulting condition number exceeds <code>evd_max_condition_number</code> SVD is used instead (which seems to be numerically more stable). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input Hermitian matrix </td></tr>
    <tr><td class="paramname">evd_max_condition_number</td><td>If the condition number obtained by EVD exceeds this value, SVD is used instead. </td></tr>
    <tr><td class="paramname">canonicalize_phase</td><td>If true, canonicalizes the eigenvectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>{eigenvalues, eigenvectors}, in the ascending order </dd></dl>

</div>
</div>
<a id="a707064a27f36933c153e53aad7a31096" name="a707064a27f36933c153e53aad7a31096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707064a27f36933c153e53aad7a31096">&#9670;&#160;</a></span>norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81770c4f45043cd8b38c1993fa865b13" name="a81770c4f45043cd8b38c1993fa865b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81770c4f45043cd8b38c1993fa865b13">&#9670;&#160;</a></span>norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1aee62e3221832775773127bf5462aa" name="aa1aee62e3221832775773127bf5462aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1aee62e3221832775773127bf5462aa">&#9670;&#160;</a></span>numeric_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) mpqc::math::numeric_cast </td>
          <td>(</td>
          <td class="paramtype">Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>a numeric type </td></tr>
    <tr><td class="paramname">T2</td><td>a numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">re</td><td>the real part of the result </td></tr>
    <tr><td class="paramname">im</td><td>the imaginary part of the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double-precision complex number with {real,imaginary} parts given by { <code>re</code> , <code>im</code> } </dd></dl>

</div>
</div>
<a id="af4e991210a817b5facda479edd24b523" name="af4e991210a817b5facda479edd24b523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e991210a817b5facda479edd24b523">&#9670;&#160;</a></span>numeric_range_degeneracies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric , typename NumericFromTExtracter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; mpqc::math::numeric_range_degeneracies </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rel_eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericFromTExtracter&#160;</td>
          <td class="paramname"><em>numeric_from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes sizes of contiguous degenerate sets in a (not-necessarily-sorted) numeric range </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Numeric</td><td>a numeric type </td></tr>
    <tr><td class="paramname">NumericFromTExtracter</td><td>a callable type that can convert (const ref to) an object of type T to Numeric </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>a range of objects of type T </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_eps</td><td>a scalar used for <em>relative</em> comparison of 2 <code>Numeric</code> values; value <code>a</code> is considered less than <code>b</code> if <code>a + rel_eps * max(|a|, |b|) &lt; b</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numeric_from</td><td>a read-only reference to an object of type NumericFromTExtracter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of containing the size of degenerate subsets in <code>range</code> </dd></dl>

</div>
</div>
<a id="a2ee9336a8084375c301af7e1a21ab291" name="a2ee9336a8084375c301af7e1a21ab291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee9336a8084375c301af7e1a21ab291">&#9670;&#160;</a></span>numeric_range_degeneracies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric , typename Proj  = mpqc::identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; mpqc::math::numeric_range_degeneracies </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; Numeric &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rel_eps</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj&#160;</td>
          <td class="paramname"><em>numeric_from</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1dc7fcc318ed5ef50064e79f9823049" name="aa1dc7fcc318ed5ef50064e79f9823049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dc7fcc318ed5ef50064e79f9823049">&#9670;&#160;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real1 , typename Real2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real2 &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a270f15f1b891fb7a5a25b6d6c05a3415" name="a270f15f1b891fb7a5a25b6d6c05a3415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270f15f1b891fb7a5a25b6d6c05a3415">&#9670;&#160;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real1 , typename Real2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real2&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac32b9efeceaa3fa3a905c55d9bcd7c04" name="ac32b9efeceaa3fa3a905c55d9bcd7c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32b9efeceaa3fa3a905c55d9bcd7c04">&#9670;&#160;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real1 , typename Real2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">Real2&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06981702fc122962d4d4fa9da093ddf9" name="a06981702fc122962d4d4fa9da093ddf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06981702fc122962d4d4fa9da093ddf9">&#9670;&#160;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real1 , typename Real2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real2 &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5c52511d0da0fcf91a55802ed6ae7a7" name="ac5c52511d0da0fcf91a55802ed6ae7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c52511d0da0fcf91a55802ed6ae7a7">&#9670;&#160;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real1 , typename Real2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real2&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adce3ed06769a5968a25a2754efd73d50" name="adce3ed06769a5968a25a2754efd73d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce3ed06769a5968a25a2754efd73d50">&#9670;&#160;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real1 , typename Real2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::operator- </td>
          <td>(</td>
          <td class="paramtype">Real2&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real1 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a018f56eab0ce54995d179096ecf1b074" name="a018f56eab0ce54995d179096ecf1b074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018f56eab0ce54995d179096ecf1b074">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Char &gt; &amp; mpqc::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmpqc_1_1math_1_1_kahan_accumulator.html">KahanAccumulator</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a779163b5fa06e9912b6b9b6efc2a465a" name="a779163b5fa06e9912b6b9b6efc2a465a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779163b5fa06e9912b6b9b6efc2a465a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; mpqc::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1math_1_1_taylor_expansion_coefficients.html">TaylorExpansionCoefficients</a>&lt; Value &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0fefc7e931dbb2c94c9702b7b36d86c" name="af0fefc7e931dbb2c94c9702b7b36d86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fefc7e931dbb2c94c9702b7b36d86c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; mpqc::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfd1fd58bfb5187e546aa723548df236" name="abfd1fd58bfb5187e546aa723548df236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd1fd58bfb5187e546aa723548df236">&#9670;&#160;</a></span>permutation_to_canonical_column_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Numeric , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Index &gt; mpqc::math::permutation_to_canonical_column_order </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; _Numeric, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>pd_element_rowidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>degenerate_panel_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::detail::scalar_t&lt; _Numeric &gt;&#160;</td>
          <td class="paramname"><em>A_element_comparison_tolerance</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reorder_panels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders columns (or degenerate panels) into canonical order. </p>
<p>Columns are canonically ordered if the (row) indices of their phase-defining elements are in the canonical (increasing/lexical) order. Ties are resolved by using canonical_greater to compare the values of phase defining elements: the first column will have phase-defining element with the greatest magnitude (or value, if the magnitudes are identical). The same notion applies to the panels; the phase defining element of a panel is the smallest index of the phase-defining element of any of its columns. Thus panels are ordered relative to each other, and the columns within each panel are also ordered.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Numeric</td><td></td></tr>
    <tr><td class="paramname">_Rows</td><td></td></tr>
    <tr><td class="paramname">_Cols</td><td></td></tr>
    <tr><td class="paramname">_Options</td><td></td></tr>
    <tr><td class="paramname">_MaxRows</td><td></td></tr>
    <tr><td class="paramname">_MaxCols</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>an Eigen::Matrix object to be canonicalized </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pd_element_rowidx</td><td>the vector containing the row index of the phase-defining element for each column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degenerate_panel_sizes</td><td>sizes of degenerate panels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_element_comparison_tolerance</td><td>the soft comparison threshold used for determining canonical order of columns whose phase-defining elements are located in the same row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder_panels</td><td>if false, will not reorder panels, only the columns within the panels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector encoding the permutation that will reorder the columns to the canonical order; the permutation is in the <em>to</em>"convention, i.e. <code>result[c]</code> is the index in the canonical order of the original column <code>c</code> . </dd></dl>

</div>
</div>
<a id="a8172076f2311a110904e3be3cbba6de2" name="a8172076f2311a110904e3be3cbba6de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8172076f2311a110904e3be3cbba6de2">&#9670;&#160;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::permute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae821586386728dfef606d69fc81a2d75" name="ae821586386728dfef606d69fc81a2d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae821586386728dfef606d69fc81a2d75">&#9670;&#160;</a></span>piv_cholesky() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::piv_cholesky </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the pivoted Cholesky decomposition </p>
<p>This function will take a matrix that is symmetric semi-positive definite and over write it with the permuted and truncated Cholesky vectors corresponding to the matrix. </p>

</div>
</div>
<a id="adb1a19cd96e43a1619f5d8c1b5a090b2" name="adb1a19cd96e43a1619f5d8c1b5a090b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1a19cd96e43a1619f5d8c1b5a090b2">&#9670;&#160;</a></span>piv_cholesky() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::piv_cholesky </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the pivoted Cholesky decomposition </p>
<p>This function will take a matrix that is Hermitian semi-positive definite and over write it with the permuted and truncated Cholesky vectors corresponding to the matrix. </p>

</div>
</div>
<a id="abaf1607661b44ab7ab5cd8e6899c5ca7" name="abaf1607661b44ab7ab5cd8e6899c5ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf1607661b44ab7ab5cd8e6899c5ca7">&#9670;&#160;</a></span>piv_cholesky_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::piv_cholesky_impl </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf438ea6cc7c6dc1cd78856f9ce606f2" name="aaf438ea6cc7c6dc1cd78856f9ce606f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf438ea6cc7c6dc1cd78856f9ce606f2">&#9670;&#160;</a></span>pop_canonical_column_phase_control() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::pop_canonical_column_phase_control </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pops the last control object from the stack </p>

</div>
</div>
<a id="a7caa8e219636efd0bab2d143ac55d27a" name="a7caa8e219636efd0bab2d143ac55d27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7caa8e219636efd0bab2d143ac55d27a">&#9670;&#160;</a></span>pop_canonical_column_phase_control() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::pop_canonical_column_phase_control </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="structmpqc_1_1math_1_1_canonical_column_phase_control.html">CanonicalColumnPhaseControl</a> &gt;&#160;</td>
          <td class="paramname"><em>ctl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pops the last control object from the stack, ensures that it equals <code>ctl</code> </p>

</div>
</div>
<a id="a261da1b1dcd43fa1de0ec547028ae44c" name="a261da1b1dcd43fa1de0ec547028ae44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261da1b1dcd43fa1de0ec547028ae44c">&#9670;&#160;</a></span>print_cis_dominant_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Idx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_cis_dominant_elements </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dominants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print dominant index and element in cis vector, with index ordered as i,a </p>

</div>
</div>
<a id="a11c64914ec64b3e06403130b1680913a" name="a11c64914ec64b3e06403130b1680913a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c64914ec64b3e06403130b1680913a">&#9670;&#160;</a></span>print_davidson_energy_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TReal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_davidson_energy_iteration </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#a3da9a3fb456dd9f37bdcd05455b8cffe">EigenVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta_e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#a3da9a3fb456dd9f37bdcd05455b8cffe">EigenVector</a>&lt; TReal &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#a3da9a3fb456dd9f37bdcd05455b8cffe">EigenVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print excitation energy at each iteration </p>

</div>
</div>
<a id="a750912b6fc64da0bcd60bd0d7d611d36" name="a750912b6fc64da0bcd60bd0d7d611d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750912b6fc64da0bcd60bd0d7d611d36">&#9670;&#160;</a></span>print_dominant_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Idx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_dominant_elements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dominants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print dominant index and element in vector with indices ordered as vir, occ </p>

</div>
</div>
<a id="a01ba0b10abafcc2418c343758652ca13" name="a01ba0b10abafcc2418c343758652ca13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ba0b10abafcc2418c343758652ca13">&#9670;&#160;</a></span>print_excitation_energy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_excitation_energy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#a3da9a3fb456dd9f37bdcd05455b8cffe">EigenVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print excitation energy with different units </p>

</div>
</div>
<a id="a4e138deca4ad919292d6e9b6b6adf560" name="a4e138deca4ad919292d6e9b6b6adf560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e138deca4ad919292d6e9b6b6adf560">&#9670;&#160;</a></span>print_single_state_davidson_energy_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TReal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_single_state_davidson_energy_iteration </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>delta_e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>eig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print excitation energy and other stats at given iteration for 1 state </p>

</div>
</div>
<a id="a285291bb1383a9dbce1f1c1bc183430f" name="a285291bb1383a9dbce1f1c1bc183430f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285291bb1383a9dbce1f1c1bc183430f">&#9670;&#160;</a></span>print_t1_dominant_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Idx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_t1_dominant_elements </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dominants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print dominant index and element in t1, with index ordered as a, i </p>

</div>
</div>
<a id="ab3e1907ca7da7f7659ece0e7d79d791d" name="ab3e1907ca7da7f7659ece0e7d79d791d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e1907ca7da7f7659ece0e7d79d791d">&#9670;&#160;</a></span>print_t1_for_ea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Idx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_t1_for_ea </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dominants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print dominant index and element in t1 </p>

</div>
</div>
<a id="aa488ca12f9d49f2e762ce5eb9da1a9e2" name="aa488ca12f9d49f2e762ce5eb9da1a9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa488ca12f9d49f2e762ce5eb9da1a9e2">&#9670;&#160;</a></span>print_t1_for_ip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Idx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_t1_for_ip </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dominants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print dominant index and element in t1 </p>

</div>
</div>
<a id="ab38b29ae9b7c74a7604022c8e5eecd50" name="ab38b29ae9b7c74a7604022c8e5eecd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38b29ae9b7c74a7604022c8e5eecd50">&#9670;&#160;</a></span>print_t2_dominant_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Idx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::print_t2_dominant_elements </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T, Idx &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dominants</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print dominant index and element in t2, with index ordered as a,b,i,j </p>

</div>
</div>
<a id="a6095b7c5088dc95df5bd4df9ffe35d5a" name="a6095b7c5088dc95df5bd4df9ffe35d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6095b7c5088dc95df5bd4df9ffe35d5a">&#9670;&#160;</a></span>product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the product of a decomposed tensor tile Currently not recommended due to implementation details. </p>

</div>
</div>
<a id="aae137646b4e9b5ebd4773238e62e212c" name="aae137646b4e9b5ebd4773238e62e212c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae137646b4e9b5ebd4773238e62e212c">&#9670;&#160;</a></span>pseudoinverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, Policy &gt; mpqc::math::pseudoinverse </td>
          <td>(</td>
          <td class="paramtype">TA::DistArray&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>HPSD</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5bf185f29d6891f31f3f26d78ad122e" name="ab5bf185f29d6891f31f3f26d78ad122e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bf185f29d6891f31f3f26d78ad122e">&#9670;&#160;</a></span>push_canonical_column_phase_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structmpqc_1_1math_1_1_canonical_column_phase_control.html">CanonicalColumnPhaseControl</a> &gt; mpqc::math::push_canonical_column_phase_control </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a new control object on the stack as a copy of last object </p>

</div>
</div>
<a id="ae79dcd2593c8ef516ef3106153143e50" name="ae79dcd2593c8ef516ef3106153143e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79dcd2593c8ef516ef3106153143e50">&#9670;&#160;</a></span>random_unitary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc.html#af7d62eef9a57009197611dc94bf57393">RowMatrix</a>&lt; T &gt; mpqc::math::random_unitary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seed</em> = <code>42.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>real or complex ring </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the matrix size </td></tr>
    <tr><td class="paramname">seed</td><td>the seed value for the <code>std::mt19937</code> random number generator; if given zero, will use <code>std::time(NULL)</code> as the seed </td></tr>
    <tr><td class="paramname">a</td><td>the lower bound for the elements of the matrix </td></tr>
    <tr><td class="paramname">b</td><td>the upper bound for the elements of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random unitary matrix </dd></dl>

</div>
</div>
<a id="a1a658571742bd129fe131af7b2284b1b" name="a1a658571742bd129fe131af7b2284b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a658571742bd129fe131af7b2284b1b">&#9670;&#160;</a></span>range_degeneracies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; mpqc::math::range_degeneracies </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes sizes of contiguous degenerate sets in a (not-necessarily-sorted) range </p><dl class="section note"><dt>Note</dt><dd>refer to std::equal_range for the definition of degenerate sets </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>a range type </td></tr>
    <tr><td class="paramname">Compare</td><td>a callable type implementing a less-than comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>a range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>a less-than comparer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of containing the size of degenerate subsets in <code>range</code> </dd></dl>

</div>
</div>
<a id="a8ae9e3e14bd0c3b64846a9ca5f7c740d" name="a8ae9e3e14bd0c3b64846a9ca5f7c740d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae9e3e14bd0c3b64846a9ca5f7c740d">&#9670;&#160;</a></span>recompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::recompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently modifies input data regardless could cause some loss of accuracy. </p>

</div>
</div>
<a id="a440bc52caf01c0e690109178258cd1d5" name="a440bc52caf01c0e690109178258cd1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440bc52caf01c0e690109178258cd1d5">&#9670;&#160;</a></span>relative_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename NumericFromTExtracter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::math::relative_difference </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>_v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>_v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericFromTExtracter&#160;</td>
          <td class="paramname"><em>numeric_from</em> = <code>[](const&#160;T&amp;&#160;_v)&#160;{&#160;return&#160;_v;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8920d2da6639901c0e950d64fa60593" name="ad8920d2da6639901c0e950d64fa60593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8920d2da6639901c0e950d64fa60593">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ad0139d484ffa7058dc33efafcdd2da" name="a7ad0139d484ffa7058dc33efafcdd2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad0139d484ffa7058dc33efafcdd2da">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a682278b1856ce075dd891653e6efb64a" name="a682278b1856ce075dd891653e6efb64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682278b1856ce075dd891653e6efb64a">&#9670;&#160;</a></span>scale_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::scale_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0c834d1d31e48bd0f0343ace9895d7b" name="ae0c834d1d31e48bd0f0343ace9895d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c834d1d31e48bd0f0343ace9895d7b">&#9670;&#160;</a></span>scale_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::scale_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a211cd76971a4a199641f6c7048ad3741" name="a211cd76971a4a199641f6c7048ad3741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211cd76971a4a199641f6c7048ad3741">&#9670;&#160;</a></span>squared_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::squared_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c59203a7674df4a74bc03fe5924ff8a" name="a7c59203a7674df4a74bc03fe5924ff8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c59203a7674df4a74bc03fe5924ff8a">&#9670;&#160;</a></span>subt() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::subt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03a0503deb893c6525af47f73c18719f" name="a03a0503deb893c6525af47f73c18719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a0503deb893c6525af47f73c18719f">&#9670;&#160;</a></span>subt() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::subt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34293f57f3a722c20e97d155e58ff977" name="a34293f57f3a722c20e97d155e58ff977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34293f57f3a722c20e97d155e58ff977">&#9670;&#160;</a></span>subt() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::subt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15af7f616bc6e9dd606c590a719eb79a" name="a15af7f616bc6e9dd606c590a719eb79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15af7f616bc6e9dd606c590a719eb79a">&#9670;&#160;</a></span>subt() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::subt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a328a1a60f3bba646234ec5c7cb454bac" name="a328a1a60f3bba646234ec5c7cb454bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328a1a60f3bba646234ec5c7cb454bac">&#9670;&#160;</a></span>subt() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::subt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e3f44b2ee27cd01e7d99fb5654885e4" name="a3e3f44b2ee27cd01e7d99fb5654885e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3f44b2ee27cd01e7d99fb5654885e4">&#9670;&#160;</a></span>subt() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::subt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Perm const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab36919ca904005463640918e389f8045" name="ab36919ca904005463640918e389f8045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36919ca904005463640918e389f8045">&#9670;&#160;</a></span>subt_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::subt_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeedff73a4e29b5c25bfa4527f59651f1" name="aeedff73a4e29b5c25bfa4527f59651f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedff73a4e29b5c25bfa4527f59651f1">&#9670;&#160;</a></span>subt_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::subt_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a541dfc1e7c9e2bbff00ef26b27a7efd4" name="a541dfc1e7c9e2bbff00ef26b27a7efd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541dfc1e7c9e2bbff00ef26b27a7efd4">&#9670;&#160;</a></span>subt_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp; mpqc::math::subt_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfb0a75c1f0d66f6492c11dd9abb42da" name="adfb0a75c1f0d66f6492c11dd9abb42da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb0a75c1f0d66f6492c11dd9abb42da">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sum of a decomposed tensor tile Currently not recommended due to implementation details. </p>

</div>
</div>
<a id="a46f00bda1ee2167d04edda6ffbb6a805" name="a46f00bda1ee2167d04edda6ffbb6a805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f00bda1ee2167d04edda6ffbb6a805">&#9670;&#160;</a></span>symmetric_min_max_evals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; mpqc::math::symmetric_min_max_evals </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57fef660c76c4e0c0306b5b27ee9c88d" name="a57fef660c76c4e0c0306b5b27ee9c88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fef660c76c4e0c0306b5b27ee9c88d">&#9670;&#160;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::symmetrize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>symmetrizes sets of equivalent tiled modes of a DistArray </p>
<p>finds sets of equivalent modes and symmetrizes tensor with respect to them. Best explained by example:</p><ul>
<li>for <code>t(i1)</code>: <code>cosymmetrize(t)</code> returns <code>t</code></li>
<li>for <code>t(i1,i2)</code>: <code>cosymmetrize(t)</code> returns <code>(t("i1,i2") + t("i2,i1"))/2</code></li>
<li>for <code>t(i1,i2,i3)</code>: <code>cosymmetrize(t)</code> returns <code>(t("i1,i2,i3") + t("i2,i1,i3") + t("i1,i3,i2") + t("i3,i2,i1") + t("i2,i3,i1") + t("i3,i1,i2"))/6</code></li>
<li>for <code>t(i1,i2,a1,a2)</code>: <code>cosymmetrize(t)</code> returns <code>(t("i1,i2,a1,a2") + t("i2,i1,a2,a1"))/2</code> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">t</td><td>on input: a tensor, on output: the symmetrized form of <code>t</code> </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a3e455bc3c1ac77c8177657d8bd22d77d" name="a3e455bc3c1ac77c8177657d8bd22d77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e455bc3c1ac77c8177657d8bd22d77d">&#9670;&#160;</a></span>third_order_update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::math::third_order_update </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e1dc8a634d38ea36f095ff65628a8d1" name="a1e1dc8a634d38ea36f095ff65628a8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1dc8a634d38ea36f095ff65628a8d1">&#9670;&#160;</a></span>tile_clr_storage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned long mpqc::math::tile_clr_storage </td>
          <td>(</td>
          <td class="paramtype">TiledArray::Tile&lt; math::DecomposedTensor&lt; T &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f7278fd754ee906264b5dad58173688" name="a5f7278fd754ee906264b5dad58173688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7278fd754ee906264b5dad58173688">&#9670;&#160;</a></span>tile_to_eigen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a>&lt; T &gt; mpqc::math::tile_to_eigen </td>
          <td>(</td>
          <td class="paramtype">TA::Tensor&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ad09d001540cb6ed7bc4978a4c376ce" name="a0ad09d001540cb6ed7bc4978a4c376ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad09d001540cb6ed7bc4978a4c376ce">&#9670;&#160;</a></span>tile_to_eigen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc_1_1math.html#aa82709d31afb8b917c53f177c664c73f">Matrix</a>&lt; T &gt; mpqc::math::tile_to_eigen </td>
          <td>(</td>
          <td class="paramtype">TA::Tile&lt; <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a509c1f3cafb5a39df41561b6f0e6ce2a" name="a509c1f3cafb5a39df41561b6f0e6ce2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509c1f3cafb5a39df41561b6f0e6ce2a">&#9670;&#160;</a></span>to_canonical_column_phase_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a> mpqc::math::to_canonical_column_phase_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert std::string to CanonicalColumnPhaseMethod </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e27a6b13adf482be354cd6d90daa76e" name="a5e27a6b13adf482be354cd6d90daa76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e27a6b13adf482be354cd6d90daa76e">&#9670;&#160;</a></span>to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mpqc::math::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert CanonicalColumnPhaseMethod to std::string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>CanonicalColumnPhaseMethod </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of these values: <ul>
<li>
<code>default</code>: if <code>method==<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88ea7a1920d61156abc05a60135aefe8bc67" title="use canonical_column_phase_control()-&gt;method">math::CanonicalColumnPhaseMethod::Default</a></code> </li>
<li>
<code>align</code>: if <code>method==<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88ead12fbc9a2ba3b0b91a4190959b4c966b" title="Align with standard basis (non-iterative)">math::CanonicalColumnPhaseMethod::Align</a></code> </li>
<li>
<code>l4</code>: if <code>method==<a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88ea4aa0f8a9fd5a5c0f77d1aabb6c58b0a2">math::CanonicalColumnPhaseMethod::L4</a></code> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8f81f037771f9805a07dde53c8c1d5aa" name="a8f81f037771f9805a07dde53c8c1d5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f81f037771f9805a07dde53c8c1d5aa">&#9670;&#160;</a></span>to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mpqc::math::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a6fd2e3aaa379968daec8b9a5e0559410">PetiteList::Symmetry</a>&#160;</td>
          <td class="paramname"><em>symmetry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>converts <a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a6fd2e3aaa379968daec8b9a5e0559410" title="permutation groups implemented by SymmPetiteList">PetiteList::Symmetry</a> to <code>std::string</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symmetry</td><td>a <a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a6fd2e3aaa379968daec8b9a5e0559410" title="permutation groups implemented by SymmPetiteList">PetiteList::Symmetry</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representation of symmetry </dd></dl>

</div>
</div>
<a id="ab2255fa0428166d1f037d6d3a3fd73d6" name="ab2255fa0428166d1f037d6d3a3fd73d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2255fa0428166d1f037d6d3a3fd73d6">&#9670;&#160;</a></span>to_wstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring mpqc::math::to_wstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a6fd2e3aaa379968daec8b9a5e0559410">PetiteList::Symmetry</a>&#160;</td>
          <td class="paramname"><em>symmetry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>converts <a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a6fd2e3aaa379968daec8b9a5e0559410" title="permutation groups implemented by SymmPetiteList">PetiteList::Symmetry</a> to <code>std::wstring</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symmetry</td><td>a <a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a6fd2e3aaa379968daec8b9a5e0559410" title="permutation groups implemented by SymmPetiteList">PetiteList::Symmetry</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representation of symmetry </dd></dl>

</div>
</div>
<a id="a6375b84e55fed80731686d5155136702" name="a6375b84e55fed80731686d5155136702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6375b84e55fed80731686d5155136702">&#9670;&#160;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trace of a decompose tensor Currently not recommended due to implementation details. </p>

</div>
</div>
<a id="a7ee6fbfc9b98b223f3148940a1fdbb6a" name="a7ee6fbfc9b98b223f3148940a1fdbb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee6fbfc9b98b223f3148940a1fdbb6a">&#9670;&#160;</a></span>two_way_decomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; mpqc::math::two_way_decomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an empty <a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a> if the compression rank was to large. </p>

</div>
</div>
<a id="a5c9c9ea6474e427180da37e6cd081dca" name="a5c9c9ea6474e427180da37e6cd081dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9c9ea6474e427180da37e6cd081dca">&#9670;&#160;</a></span>unary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; mpqc::math::unary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1math_1_1_decomposed_tensor.html">DecomposedTensor</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad141437494c402b64a9965cc624b81d9" name="ad141437494c402b64a9965cc624b81d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad141437494c402b64a9965cc624b81d9">&#9670;&#160;</a></span>Z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::complex&lt; double &gt; mpqc::math::Z </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>im</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>a numeric type </td></tr>
    <tr><td class="paramname">T2</td><td>a numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">re</td><td>the real part of the result </td></tr>
    <tr><td class="paramname">im</td><td>the imaginary part of the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double-precision complex number with {real,imaginary} parts given by { <code>re</code> , <code>im</code> } </dd></dl>

</div>
</div>
<a id="a8e429e41dd3e7239fbf526a6665b75fe" name="a8e429e41dd3e7239fbf526a6665b75fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e429e41dd3e7239fbf526a6665b75fe">&#9670;&#160;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mpqc::math::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1a6dab682dd58a2f68cf0a88bebba1f" name="ad1a6dab682dd58a2f68cf0a88bebba1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a6dab682dd58a2f68cf0a88bebba1f">&#9670;&#160;</a></span>zero&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mpqc::math::zero&lt; double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e1a241df7b750a2b1bc31f37566fd3" name="a51e1a241df7b750a2b1bc31f37566fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e1a241df7b750a2b1bc31f37566fd3">&#9670;&#160;</a></span>zero&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float mpqc::math::zero&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c58350987c6761c67fc07352c867d06" name="a8c58350987c6761c67fc07352c867d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c58350987c6761c67fc07352c867d06">&#9670;&#160;</a></span>zero&lt; long double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double mpqc::math::zero&lt; long double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44bd91a878b892080cb0fe62719728f1" name="a44bd91a878b892080cb0fe62719728f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bd91a878b892080cb0fe62719728f1">&#9670;&#160;</a></span>zip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , std::size_t N1, typename T2 , std::size_t N2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; std::pair&lt; T1, T2 &gt;, std::min(N1, N2)&gt; mpqc::math::zip </td>
          <td>(</td>
          <td class="paramtype">const boost::container::small_vector&lt; T1, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::container::small_vector&lt; T2, N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e733360ff20c11ea71066839608c7a7" name="a6e733360ff20c11ea71066839608c7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e733360ff20c11ea71066839608c7a7">&#9670;&#160;</a></span>zip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; T, T &gt; &gt; mpqc::math::zip </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab81dc2e9a385ac3a5deb4e690c3f17d6" name="ab81dc2e9a385ac3a5deb4e690c3f17d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81dc2e9a385ac3a5deb4e690c3f17d6">&#9670;&#160;</a></span>CanonicalColumnPhaseMethod_to_string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto mpqc::math::CanonicalColumnPhaseMethod_to_string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    ranges::views::zip(</div>
<div class="line">        ranges::views::values(string_to_CanonicalColumnPhaseMethod),</div>
<div class="line">        ranges::views::keys(string_to_CanonicalColumnPhaseMethod)) |</div>
<div class="line">    ranges::to&lt;std::map&lt;CanonicalColumnPhaseMethod, std::string&gt;&gt;()</div>
</div><!-- fragment -->
</div>
</div>
<a id="a599a6bfcbe3a562318dbf89b0eb287b6" name="a599a6bfcbe3a562318dbf89b0eb287b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599a6bfcbe3a562318dbf89b0eb287b6">&#9670;&#160;</a></span>clustering_method_string2type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739">ClusteringMethod</a>&gt; mpqc::math::clustering_method_string2type = <a class="el" href="namespacempqc_1_1math.html#a9a79a4f34ce13e36d2f3262e8cb9fdc0">make_clustering_method_string2type</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c7c153eee3c8f698297e933286afa18" name="a1c7c153eee3c8f698297e933286afa18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7c153eee3c8f698297e933286afa18">&#9670;&#160;</a></span>clustering_method_type2string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;<a class="el" href="namespacempqc_1_1math.html#a4edc461603cdd44dbd70281e40567739">ClusteringMethod</a>, std::string&gt; mpqc::math::clustering_method_type2string = <a class="el" href="namespacempqc_1_1math.html#a5716b7e21b52c0e42fbb4ecc252a3fea">make_clustering_method_type2string</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5de0b9a238a8bf0adb0e61919b5020e" name="ae5de0b9a238a8bf0adb0e61919b5020e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5de0b9a238a8bf0adb0e61919b5020e">&#9670;&#160;</a></span>math_linalg_davidson_force_link</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_force_link.html">ForceLink</a>&lt;<a class="el" href="classmpqc_1_1math_1_1_davidson_eigensolver_factory.html">DavidsonEigensolverFactory</a>&gt; mpqc::math::math_linalg_davidson_force_link</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c86572368c1d2d7d66baad63bdf3ff8" name="a9c86572368c1d2d7d66baad63bdf3ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c86572368c1d2d7d66baad63bdf3ff8">&#9670;&#160;</a></span>string_to_CanonicalColumnPhaseMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="namespacempqc_1_1math.html#ab889c32f48707ecbe045597b6bb7a88e">CanonicalColumnPhaseMethod</a>&gt; mpqc::math::string_to_CanonicalColumnPhaseMethod</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        {<span class="stringliteral">&quot;default&quot;</span>, CanonicalColumnPhaseMethod::Default},</div>
<div class="line">        {<span class="stringliteral">&quot;align&quot;</span>, CanonicalColumnPhaseMethod::Align},</div>
<div class="line">        {<span class="stringliteral">&quot;l4&quot;</span>, CanonicalColumnPhaseMethod::L4},</div>
<div class="line">        {<span class="stringliteral">&quot;entropy&quot;</span>, CanonicalColumnPhaseMethod::Entropy},</div>
<div class="line">        {<span class="stringliteral">&quot;align_l4&quot;</span>, CanonicalColumnPhaseMethod::Align_L4},</div>
<div class="line">        {<span class="stringliteral">&quot;align_entropy&quot;</span>, CanonicalColumnPhaseMethod::Align_Entropy}}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 13 2025 23:43:47 for MPQC-Docs by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
