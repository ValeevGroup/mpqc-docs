<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC-Docs: mpqc::lcao::gaussian Namespace Reference</title>
<!--BEGIN PROJECT_ICON-->
<link rel="icon" href="$projecticon" type="image/x-icon" />
<!--END PROJECT_ICON-->
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--BEGIN COPY_CLIPBOARD-->
<script type="text/javascript" src="clipboard.js"></script>
<!--END COPY_CLIPBOARD-->
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init();
        DoxygenAwesomeParagraphLink.init();
    </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"$logosize/></td>
  <td id="projectalign">
   <div id="projectname">MPQC-Docs<span id="projectnumber">&#160;4.0.0-beta.1</span>
   </div>
   <div id="projectbrief">Massively Parallel Electronic Structure platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempqc.html">mpqc</a></li><li class="navelem"><a class="el" href="namespacempqc_1_1lcao.html">lcao</a></li><li class="navelem"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html">gaussian</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mpqc::lcao::gaussian Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacempqc_1_1lcao_1_1gaussian_1_1detail" id="r_namespacempqc_1_1lcao_1_1gaussian_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacempqc_1_1lcao_1_1gaussian_1_1precomputed" id="r_namespacempqc_1_1lcao_1_1gaussian_1_1precomputed"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1precomputed.html">precomputed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacempqc_1_1lcao_1_1gaussian_1_1utility" id="r_namespacempqc_1_1lcao_1_1gaussian_1_1utility"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html">utility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian AO integral factory using ab initio Hamiltonians.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_atomic_basis.html">AtomicBasis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_data.html">BasisData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_pair_data.html">BasisPairData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_registry.html">BasisRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_d_f_task_gemm.html">DFTaskGemm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_contract.html">DirectContract</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_d_f_integral_builder.html">DirectDFIntegralBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_d_f_integral_builder.html" title="DirectDFIntegralBuilder is a class that builds direct df tiles on the fly which can be composed by pr...">DirectDFIntegralBuilder</a> is a class that builds direct df tiles on the fly which can be composed by providing an expression. For example, the builder for the closed-shell canonical <a class="el" href="classmpqc_1_1lcao_1_1_m_p2.html" title="Computed the MP2 energy.">MP2</a> energy numerator can be computed by the following:  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_d_f_integral_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_data.html">FMMShellData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds shell-specific data relevant to FMM and related methods.  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_pair_data.html">FMMShellPairData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds shell-pair-specific data relevant to FMM and related methods.  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_pair_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_geom_deriv_sink.html">GeomDerivSink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html">IntegralBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds integrals from an array of bases and an integral engine pool.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_m_a_d_f.html">MADF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which holds shell set information for screening.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html">QQRScreen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements QQR screener for shell-sets of integrals.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for Schwarz based screening.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_shell_data.html">ShellData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">aggregate of the Libint2 and SQVl shell data  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_shell_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_shell_pair_data.html">ShellPairData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">aggregate of the Libint2 and SQVl shell-pair data  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_shell_pair_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html">SQVlScreen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html" title="Implements SQVlScreen screener for shell-sets of (0|12) integrals.">SQVlScreen</a> screener for shell-sets of (0|12) integrals.  <a href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_data.html">SQVlShellData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds shell-specific data relevant to the SVQ(l) integral estimator described in DOI 10.1063/1.4917519.  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_pair_data.html">SQVlShellPairData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds shell-specific data relevant to the SVQ(l) integral estimator described in DOI 10.1063/1.4917519.  <a href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_pair_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aded59e8a710ae55d49de715671f144c4" id="r_aded59e8a710ae55d49de715671f144c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">Shell</a> = libint2::Shell</td></tr>
<tr class="separator:aded59e8a710ae55d49de715671f144c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867b676d97f85013d7c64e693923168" id="r_ae867b676d97f85013d7c64e693923168"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> = std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">Shell</a> &gt;</td></tr>
<tr class="separator:ae867b676d97f85013d7c64e693923168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f638764dba43a9aefbe5c529e766d9" id="r_a98f638764dba43a9aefbe5c529e766d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a98f638764dba43a9aefbe5c529e766d9">OrbitalBasisRegistry</a> = <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_registry.html">BasisRegistry</a></td></tr>
<tr class="separator:a98f638764dba43a9aefbe5c529e766d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f3517e0399a3e6a4966e7a1e6df29a" id="r_a45f3517e0399a3e6a4966e7a1e6df29a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a> = std::function&lt; const libint2::ShellPair *(std::size_t, std::size_t)&gt;</td></tr>
<tr class="separator:a45f3517e0399a3e6a4966e7a1e6df29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ce89182bb6ac2b31aa54f71352597d" id="r_ad1ce89182bb6ac2b31aa54f71352597d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ad1ce89182bb6ac2b31aa54f71352597d">fmm_shell_data_accessor_t</a> = std::function&lt; const <a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_data.html">FMMShellData</a> &amp;(std::size_t)&gt;</td></tr>
<tr class="separator:ad1ce89182bb6ac2b31aa54f71352597d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd97e64da2aa2c316e9b6824d7b0606e" id="r_acd97e64da2aa2c316e9b6824d7b0606e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#acd97e64da2aa2c316e9b6824d7b0606e">fmm_shellpair_data_accessor_t</a> = std::function&lt; const <a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_pair_data.html">FMMShellPairData</a> &amp;(std::size_t, std::size_t)&gt;</td></tr>
<tr class="separator:acd97e64da2aa2c316e9b6824d7b0606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae162936cb74b41bc13595e3dd2af3f" id="r_a1ae162936cb74b41bc13595e3dd2af3f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a1ae162936cb74b41bc13595e3dd2af3f">sqvl_shell_data_accessor_t</a> = std::function&lt; const <a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_data.html">SQVlShellData</a> &amp;(std::size_t)&gt;</td></tr>
<tr class="separator:a1ae162936cb74b41bc13595e3dd2af3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb05e569ac77137911929a78192cdb4f" id="r_aeb05e569ac77137911929a78192cdb4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aeb05e569ac77137911929a78192cdb4f">sqvl_shellpair_data_accessor_t</a> = std::function&lt; const <a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_pair_data.html">SQVlShellPairData</a> &amp;(std::size_t, std::size_t)&gt;</td></tr>
<tr class="separator:aeb05e569ac77137911929a78192cdb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f910069d8c33df99ad2e1cd19c1caaa" id="r_a9f910069d8c33df99ad2e1cd19c1caaa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9f910069d8c33df99ad2e1cd19c1caaa">norm_op_t</a> = double(Eigen::Map&lt; const <a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a> &gt; const &amp;)</td></tr>
<tr class="separator:a9f910069d8c33df99ad2e1cd19c1caaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c5b3980c43882e8ed5e1e1ca84d42c" id="r_a25c5b3980c43882e8ed5e1e1ca84d42c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a25c5b3980c43882e8ed5e1e1ca84d42c">basis_Q_matrix_accessor_t</a> = std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9f910069d8c33df99ad2e1cd19c1caaa">norm_op_t</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt;</td></tr>
<tr class="separator:a25c5b3980c43882e8ed5e1e1ca84d42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9130eb5a36983dca4b6483abe1bde61b" id="r_a9130eb5a36983dca4b6483abe1bde61b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9130eb5a36983dca4b6483abe1bde61b">basispair_Q_matrix_accessor_t</a> = std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9f910069d8c33df99ad2e1cd19c1caaa">norm_op_t</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt;</td></tr>
<tr class="separator:a9130eb5a36983dca4b6483abe1bde61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73c76898429468a8a0d96b64d47c883" id="r_ae73c76898429468a8a0d96b64d47c883"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#ae73c76898429468a8a0d96b64d47c883">Shell</a> = <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html#a12190b7d3d8f90effd29483c67b3cdf6">Basis::Shell</a></td></tr>
<tr class="separator:ae73c76898429468a8a0d96b64d47c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ec309c8eeefe1f5bc2e120ae85f20" id="r_a566ec309c8eeefe1f5bc2e120ae85f20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a566ec309c8eeefe1f5bc2e120ae85f20">ShellVec</a> = std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">Shell</a> &gt;</td></tr>
<tr class="separator:a566ec309c8eeefe1f5bc2e120ae85f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051e5b4d60cbe779182d6a9502a1f1c3" id="r_a051e5b4d60cbe779182d6a9502a1f1c3"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a051e5b4d60cbe779182d6a9502a1f1c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a> = std::shared_ptr&lt; TA::detail::TSPool&lt; E &gt; &gt;</td></tr>
<tr class="separator:a051e5b4d60cbe779182d6a9502a1f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0093954514a5fe80500fe52e3627a7" id="r_a4f0093954514a5fe80500fe52e3627a7"><td class="memTemplParams" colspan="2">template&lt;unsigned long N&gt; </td></tr>
<tr class="memitem:a4f0093954514a5fe80500fe52e3627a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a4f0093954514a5fe80500fe52e3627a7">BasisRefArray</a> = std::array&lt; std::reference_wrapper&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;, N &gt;</td></tr>
<tr class="separator:a4f0093954514a5fe80500fe52e3627a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dee262f551ab481b1d19fa1744c2b7" id="r_a69dee262f551ab481b1d19fa1744c2b7"><td class="memTemplParams" colspan="2">template&lt;unsigned long N&gt; </td></tr>
<tr class="memitem:a69dee262f551ab481b1d19fa1744c2b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a69dee262f551ab481b1d19fa1744c2b7">BasisShrArray</a> = std::array&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;, N &gt;</td></tr>
<tr class="separator:a69dee262f551ab481b1d19fa1744c2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e1df2244ae775566f28b9e358b5b9" id="r_a9e4e1df2244ae775566f28b9e358b5b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a9e4e1df2244ae775566f28b9e358b5b9">BasisRefVector</a> = std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; &gt;</td></tr>
<tr class="separator:a9e4e1df2244ae775566f28b9e358b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc1d22947aef467a30a88973291a9fb" id="r_a2bc1d22947aef467a30a88973291a9fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> = std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; &gt;</td></tr>
<tr class="separator:a2bc1d22947aef467a30a88973291a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f200f35a2419ebf17bec11186d1f797" id="r_a7f200f35a2419ebf17bec11186d1f797"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f200f35a2419ebf17bec11186d1f797"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a7f200f35a2419ebf17bec11186d1f797">OrdTileVec</a> = std::vector&lt; std::pair&lt; unsigned long, T &gt; &gt;</td></tr>
<tr class="separator:a7f200f35a2419ebf17bec11186d1f797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfbe0eb9b925b3f25b546fe6442c32e" id="r_aebfbe0eb9b925b3f25b546fe6442c32e"><td class="memTemplParams" colspan="2">template&lt;unsigned long N&gt; </td></tr>
<tr class="memitem:aebfbe0eb9b925b3f25b546fe6442c32e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#aebfbe0eb9b925b3f25b546fe6442c32e">ShellVecPtrArray</a> = std::array&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const *, N &gt;</td></tr>
<tr class="separator:aebfbe0eb9b925b3f25b546fe6442c32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4d9799486007f292ac8c597553dce604" id="r_a4d9799486007f292ac8c597553dce604"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a4d9799486007f292ac8c597553dce604">max_am</a> (<a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;)</td></tr>
<tr class="memdesc:a4d9799486007f292ac8c597553dce604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum angular momentum of any shell in the vector.  <br /></td></tr>
<tr class="separator:a4d9799486007f292ac8c597553dce604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87356cfd768c7a7e880cfccbaff41af0" id="r_a87356cfd768c7a7e880cfccbaff41af0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a87356cfd768c7a7e880cfccbaff41af0">max_am</a> (std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; const &amp;)</td></tr>
<tr class="memdesc:a87356cfd768c7a7e880cfccbaff41af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum angular momentum of any shell in the cluster of shells.  <br /></td></tr>
<tr class="separator:a87356cfd768c7a7e880cfccbaff41af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae463540711e7a5718ff6f313ac0d84fb" id="r_ae463540711e7a5718ff6f313ac0d84fb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae463540711e7a5718ff6f313ac0d84fb">max_nprim</a> (<a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;)</td></tr>
<tr class="memdesc:ae463540711e7a5718ff6f313ac0d84fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of primitives of any shell in the vector.  <br /></td></tr>
<tr class="separator:ae463540711e7a5718ff6f313ac0d84fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc401f93b3cf3989932e8749bd51eee" id="r_a0cc401f93b3cf3989932e8749bd51eee"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0cc401f93b3cf3989932e8749bd51eee">nfunctions</a> (<a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;)</td></tr>
<tr class="memdesc:a0cc401f93b3cf3989932e8749bd51eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of primitives of any shell in the vector.  <br /></td></tr>
<tr class="separator:a0cc401f93b3cf3989932e8749bd51eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8175706c202c8102a6b9e063180a7be3" id="r_a8175706c202c8102a6b9e063180a7be3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; libint2::Shell &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a8175706c202c8102a6b9e063180a7be3">make_shell_clusters</a> (std::vector&lt; libint2::Shell &gt; shells, std::size_t blocksize)</td></tr>
<tr class="separator:a8175706c202c8102a6b9e063180a7be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c702195651def7f9156e01a8b429f3b" id="r_a0c702195651def7f9156e01a8b429f3b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0c702195651def7f9156e01a8b429f3b">split_by_am</a> (const std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; &amp;clusters)</td></tr>
<tr class="separator:a0c702195651def7f9156e01a8b429f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eab76800c2eb2a8c34db5346ffefcf" id="r_ab7eab76800c2eb2a8c34db5346ffefcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab7eab76800c2eb2a8c34db5346ffefcf">print_in_gaussian</a> (const std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:ab7eab76800c2eb2a8c34db5346ffefcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a7d64e96194afd83934d4f16e44c03" id="r_a64a7d64e96194afd83934d4f16e44c03"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a64a7d64e96194afd83934d4f16e44c03">cluster_composition</a> (const std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:a64a7d64e96194afd83934d4f16e44c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ca7c1d50c5fee6a5c40601433e2794" id="r_a31ca7c1d50c5fee6a5c40601433e2794"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libint2::Shell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a31ca7c1d50c5fee6a5c40601433e2794">recenter_shells</a> (const std::vector&lt; libint2::Shell &gt; &amp;shells, const <a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> &amp;<a class="el" href="namespacempqc.html#aac225015bfae4758bdeda59f8d458bf2">center</a>)</td></tr>
<tr class="separator:a31ca7c1d50c5fee6a5c40601433e2794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b7233f3f1617b95869c9c07d78111c" id="r_a36b7233f3f1617b95869c9c07d78111c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; libint2::Shell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a36b7233f3f1617b95869c9c07d78111c">recenter_cluster</a> (const std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; &amp;cluster, const <a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> &amp;<a class="el" href="namespacempqc.html#aac225015bfae4758bdeda59f8d458bf2">center</a>)</td></tr>
<tr class="separator:a36b7233f3f1617b95869c9c07d78111c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcd976886feaeb7d161824c36ecbb5a" id="r_abdcd976886feaeb7d161824c36ecbb5a"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:abdcd976886feaeb7d161824c36ecbb5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt; Tile, Policy &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#abdcd976886feaeb7d161824c36ecbb5a">to_ao_factory</a> (<a class="el" href="classmpqc_1_1lcao_1_1_a_o_factory.html">lcao::AOFactory</a>&lt; Tile, Policy &gt; &amp;factory)</td></tr>
<tr class="separator:abdcd976886feaeb7d161824c36ecbb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b8c088e51da32c6410c2aa431bd817" id="r_af9b8c088e51da32c6410c2aa431bd817"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:af9b8c088e51da32c6410c2aa431bd817"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt; Tile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#af9b8c088e51da32c6410c2aa431bd817">to_ao_factory</a> (const std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_a_o_factory.html">lcao::AOFactory</a>&lt; Tile, Policy &gt; &gt; &amp;factory)</td></tr>
<tr class="separator:af9b8c088e51da32c6410c2aa431bd817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaf034e3d03f7ebf9d308bbb15fd7c7" id="r_adfaf034e3d03f7ebf9d308bbb15fd7c7"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:adfaf034e3d03f7ebf9d308bbb15fd7c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#adfaf034e3d03f7ebf9d308bbb15fd7c7">compute_Xmat</a> (<a class="el" href="namespacempqc.html#a5d7bc8f0ed3636e5287fd8333e1f915e">H1eType</a> h1e_type, madness::World &amp;world, const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;S, const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;T, const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;V, const TA::DistArrayVector&lt; Tile, Policy &gt; &amp;W)</td></tr>
<tr class="separator:adfaf034e3d03f7ebf9d308bbb15fd7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d2c23098746cde07fefd7f4bcca02" id="r_a5a6d2c23098746cde07fefd7f4bcca02"><td class="memTemplParams" colspan="2">template&lt;typename RealTile , typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a5a6d2c23098746cde07fefd7f4bcca02"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt;, <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt;, <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5a6d2c23098746cde07fefd7f4bcca02">compute_x2c_coreH</a> (std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &gt; wfn_world, const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; RealTile, Policy &gt; &amp;S, const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; RealTile, Policy &gt; &amp;T, const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; RealTile, Policy &gt; &amp;V1c, const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;W, double target_cond_number=1e8)</td></tr>
<tr class="separator:a5a6d2c23098746cde07fefd7f4bcca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade0cff827d164f6eb0aeb54b8129299" id="r_aade0cff827d164f6eb0aeb54b8129299"><td class="memItemLeft" align="right" valign="top">libint2::Operator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aade0cff827d164f6eb0aeb54b8129299">to_libint2_operator</a> (<a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_oper)</td></tr>
<tr class="separator:aade0cff827d164f6eb0aeb54b8129299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cc61b0f4ad28acd3040acd3d471c7e" id="r_a07cc61b0f4ad28acd3040acd3d471c7e"><td class="memItemLeft" align="right" valign="top">libint2::any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a07cc61b0f4ad28acd3040acd3d471c7e">to_libint2_operator_params</a> (<a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_oper, const <a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> &amp;molecule, const std::map&lt; <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>, libint2::any &gt; *oper_params, const std::optional&lt; <a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> &gt; &amp;multipole_origin)</td></tr>
<tr class="separator:a07cc61b0f4ad28acd3040acd3d471c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07479e80d39fec6897ee99c6f59e6667" id="r_a07479e80d39fec6897ee99c6f59e6667"><td class="memItemLeft" align="right" valign="top">libint2::scalar_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a07479e80d39fec6897ee99c6f59e6667">to_libint2_scale_factor</a> (<a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_oper, const std::map&lt; <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>, libint2::any &gt; *oper_params)</td></tr>
<tr class="separator:a07479e80d39fec6897ee99c6f59e6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1e98d2feb096d950421b339aa5aec9" id="r_adf1e98d2feb096d950421b339aa5aec9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#adf1e98d2feb096d950421b339aa5aec9">make_schwarz_screener</a> (std::tuple&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp; &gt; bra, std::tuple&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp; &gt; ket, double threshold)</td></tr>
<tr class="separator:adf1e98d2feb096d950421b339aa5aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf31eee268163d90a39cd316c46a724" id="r_a0bf31eee268163d90a39cd316c46a724"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a0bf31eee268163d90a39cd316c46a724"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0bf31eee268163d90a39cd316c46a724">make_schwarz_screener</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a> &amp;gaussian_ao_factory, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_oper, Bases &amp;&amp;bases, double threshold, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="separator:a0bf31eee268163d90a39cd316c46a724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5078887f903c12dc8cbbea425d4d44e2" id="r_a5078887f903c12dc8cbbea425d4d44e2"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a5078887f903c12dc8cbbea425d4d44e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html">QQRScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5078887f903c12dc8cbbea425d4d44e2">make_qqr_screener</a> (madness::World &amp;world, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; &amp;engs, Bases &amp;&amp;bases, double threshold, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="separator:a5078887f903c12dc8cbbea425d4d44e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afc904ff353145ce6a469402b97bf08" id="r_a2afc904ff353145ce6a469402b97bf08"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a2afc904ff353145ce6a469402b97bf08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html">QQRScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a2afc904ff353145ce6a469402b97bf08">make_qqr_screener</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a> &amp;gaussian_ao_factory, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_oper, Bases &amp;&amp;bases, double threshold, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="separator:a2afc904ff353145ce6a469402b97bf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb825b90f27472339962f0cb0dbbbbc3" id="r_acb825b90f27472339962f0cb0dbbbbc3"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Bases &gt; </td></tr>
<tr class="memitem:acb825b90f27472339962f0cb0dbbbbc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html">SQVlScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#acb825b90f27472339962f0cb0dbbbbc3">make_sqvl_screener</a> (madness::World &amp;world, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; &amp;engs, Bases &amp;&amp;bases, double threshold, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="separator:acb825b90f27472339962f0cb0dbbbbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70c779c4b9824d32f03c91e2b2f5ad2" id="r_ae70c779c4b9824d32f03c91e2b2f5ad2"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:ae70c779c4b9824d32f03c91e2b2f5ad2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html">SQVlScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae70c779c4b9824d32f03c91e2b2f5ad2">make_sqvl_screener</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a> &amp;gaussian_ao_factory, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_op, Bases &amp;&amp;bases, double threshold, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="separator:ae70c779c4b9824d32f03c91e2b2f5ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9324b9390c81a5391ad96e05b510118" id="r_ab9324b9390c81a5391ad96e05b510118"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:ab9324b9390c81a5391ad96e05b510118"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab9324b9390c81a5391ad96e05b510118">make_screener</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">gaussian::GaussianFactory</a> &amp;gaussian_ao_factory, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_op, Bases &amp;&amp;bases, const std::string &amp;screen, double screen_threshold)</td></tr>
<tr class="memdesc:ab9324b9390c81a5391ad96e05b510118"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory for <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html" title="ThresholdedScreener is a Screener equipped with a (mutable) real threshold.">ThresholdedScreener</a> objects  <br /></td></tr>
<tr class="separator:ab9324b9390c81a5391ad96e05b510118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2013d56ba5fc3bdba0c329c04d747522" id="r_a2013d56ba5fc3bdba0c329c04d747522"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a2013d56ba5fc3bdba0c329c04d747522"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a2013d56ba5fc3bdba0c329c04d747522">make_screener</a> (<a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;wfn_world, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc_op, Bases &amp;&amp;bases, const std::string &amp;screen, double screen_threshold)</td></tr>
<tr class="separator:a2013d56ba5fc3bdba0c329c04d747522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd5ecbd8edb0049e27b109f14f82b94" id="r_a5cd5ecbd8edb0049e27b109f14f82b94"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5cd5ecbd8edb0049e27b109f14f82b94">index_to_basis</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_registry.html">BasisRegistry</a> &amp;basis_registry, const <a class="el" href="namespacempqc_1_1lcao.html#ad97913bcf53f7be621e417add34acfb5">OrbitalIndex</a> &amp;<a class="el" href="group___math_fock_space.html#ga18712c18418d5b42ee4fd88a5bb9f556">index</a>)</td></tr>
<tr class="memdesc:a5cd5ecbd8edb0049e27b109f14f82b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">given OrbitalIndex, find the corresponding basis  <br /></td></tr>
<tr class="separator:a5cd5ecbd8edb0049e27b109f14f82b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace25fc31194c5c92a23c5faf3a5bdc7" id="r_aace25fc31194c5c92a23c5faf3a5bdc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aace25fc31194c5c92a23c5faf3a5bdc7">parallel_compute_shellpair_list</a> (madness::World &amp;world, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis1, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis2, double threshold=1e-12, double engine_precision=0.0)</td></tr>
<tr class="memdesc:aace25fc31194c5c92a23c5faf3a5bdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes non-negligible shell pair list; shells <code>i</code> and <code>j</code> form a non-negligible pair if they share a center or the Frobenius norm of their overlap is greater than threshold.  <br /></td></tr>
<tr class="separator:aace25fc31194c5c92a23c5faf3a5bdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9b7c4f2213466b2cac67291bc97e29" id="r_a1b9b7c4f2213466b2cac67291bc97e29"><td class="memTemplParams" colspan="2">template&lt;typename Policy , bool is_real = true&gt; </td></tr>
<tr class="memitem:a1b9b7c4f2213466b2cac67291bc97e29"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; TA::TensorD, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a1b9b7c4f2213466b2cac67291bc97e29">tensorZ_to_tensorD</a> (const TA::DistArray&lt; TA::TensorZ, Policy &gt; &amp;complex_array)</td></tr>
<tr class="memdesc:a1b9b7c4f2213466b2cac67291bc97e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes real or imaginary part from a complex array.  <br /></td></tr>
<tr class="separator:a1b9b7c4f2213466b2cac67291bc97e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5890ea4285e42b4439da58bd637177c7" id="r_a5890ea4285e42b4439da58bd637177c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5890ea4285e42b4439da58bd637177c7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5890ea4285e42b4439da58bd637177c7">l2_norm</a> (Eigen::Map&lt; const <a class="el" href="namespacempqc.html#af7d62eef9a57009197611dc94bf57393">RowMatrix</a>&lt; T &gt; &gt; const &amp;map)</td></tr>
<tr class="separator:a5890ea4285e42b4439da58bd637177c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47085b65da4b31ada41f7613ae39fa0" id="r_ab47085b65da4b31ada41f7613ae39fa0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab47085b65da4b31ada41f7613ae39fa0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab47085b65da4b31ada41f7613ae39fa0">inf_norm</a> (Eigen::Map&lt; const <a class="el" href="namespacempqc.html#af7d62eef9a57009197611dc94bf57393">RowMatrix</a>&lt; T &gt; &gt; const &amp;map)</td></tr>
<tr class="separator:ab47085b65da4b31ada41f7613ae39fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2814e6bcedeb919f0343b9ae089382e" id="r_ad2814e6bcedeb919f0343b9ae089382e"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:ad2814e6bcedeb919f0343b9ae089382e"><td class="memTemplItemLeft" align="right" valign="top">TA::detail::real_t&lt; TA::DistArray&lt; Tile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ad2814e6bcedeb919f0343b9ae089382e">compute_shellblock_norm</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;bs0, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;bs1, const TA::DistArray&lt; Tile, Policy &gt; &amp;D, const std::string &amp;screen=&quot;dist_inf&quot;)</td></tr>
<tr class="memdesc:ad2814e6bcedeb919f0343b9ae089382e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calculates shell block norms of density matrix.  <br /></td></tr>
<tr class="separator:ad2814e6bcedeb919f0343b9ae089382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0ea66df0f12ca1c23210bdbbd4e3ae" id="r_aaa0ea66df0f12ca1c23210bdbbd4e3ae"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:aaa0ea66df0f12ca1c23210bdbbd4e3ae"><td class="memTemplItemLeft" align="right" valign="top">TA::detail::real_t&lt; TA::DistArray&lt; Tile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aaa0ea66df0f12ca1c23210bdbbd4e3ae">compute_shellblock_norm</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;bs0, const TA::DistArray&lt; Tile, Policy &gt; &amp;D)</td></tr>
<tr class="separator:aaa0ea66df0f12ca1c23210bdbbd4e3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92beac907f517f3e088b5d1064a132cf" id="r_a92beac907f517f3e088b5d1064a132cf"><td class="memTemplParams" colspan="2">template&lt;typename OrbSpace &gt; </td></tr>
<tr class="memitem:a92beac907f517f3e088b5d1064a132cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a92beac907f517f3e088b5d1064a132cf">to_molden</a> (std::string_view fname_prefix, const OrbSpace &amp;orbspace, const <a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;wfn_world)</td></tr>
<tr class="memdesc:a92beac907f517f3e088b5d1064a132cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints an orbital space to a Molden file  <br /></td></tr>
<tr class="separator:a92beac907f517f3e088b5d1064a132cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e29bfd654bb561f89ad695f648a7c6" id="r_ad8e29bfd654bb561f89ad695f648a7c6"><td class="memTemplParams" colspan="2">template&lt;typename OrbSpace &gt; </td></tr>
<tr class="memitem:ad8e29bfd654bb561f89ad695f648a7c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ad8e29bfd654bb561f89ad695f648a7c6">to_molden</a> (std::string_view fname_prefix, const std::shared_ptr&lt; const OrbSpace &gt; &amp;orbspace_ptr, const <a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;wfn_world)</td></tr>
<tr class="memdesc:ad8e29bfd654bb561f89ad695f648a7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints an orbital space to a Molden file  <br /></td></tr>
<tr class="separator:ad8e29bfd654bb561f89ad695f648a7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17b1deae133bba061abcaa15502e003" id="r_ac17b1deae133bba061abcaa15502e003"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine  = libint2::Engine, typename Bases &gt; </td></tr>
<tr class="memitem:ac17b1deae133bba061abcaa15502e003"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ac17b1deae133bba061abcaa15502e003">direct_sparse_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;(), std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:ac17b1deae133bba061abcaa15502e003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct direct integral tensors in parallel with screening.  <br /></td></tr>
<tr class="separator:ac17b1deae133bba061abcaa15502e003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de17af4022d89ed64736f73adc1c4c6" id="r_a7de17af4022d89ed64736f73adc1c4c6"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Idx , typename Bases &gt; </td></tr>
<tr class="memitem:a7de17af4022d89ed64736f73adc1c4c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a7de17af4022d89ed64736f73adc1c4c6">direct_sparse_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt; shr_pool, Bases &amp;&amp;bases, std::vector&lt; std::pair&lt; Idx, float &gt; &gt; const &amp;user_provided_norms, bool user_provided_norms_perelem, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;(), std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a7de17af4022d89ed64736f73adc1c4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct direct integral tensors in parallel with screening.  <br /></td></tr>
<tr class="separator:a7de17af4022d89ed64736f73adc1c4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813d472178204ffe2463c580159ee36c" id="r_a813d472178204ffe2463c580159ee36c"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Bases &gt; </td></tr>
<tr class="memitem:a813d472178204ffe2463c580159ee36c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy, Engine &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a813d472178204ffe2463c580159ee36c">untruncated_direct_sparse_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;(), std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a813d472178204ffe2463c580159ee36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct direct integral tensors in parallel with screening.  <br /></td></tr>
<tr class="separator:a813d472178204ffe2463c580159ee36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221e6b861a67a79d0769849114c057ba" id="r_a221e6b861a67a79d0769849114c057ba"><td class="memTemplParams" colspan="2">template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Bases &gt; </td></tr>
<tr class="memitem:a221e6b861a67a79d0769849114c057ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::DensePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a221e6b861a67a79d0769849114c057ba">direct_dense_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;(), std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a221e6b861a67a79d0769849114c057ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct direct dense integral tensors in parallel with screening.  <br /></td></tr>
<tr class="separator:a221e6b861a67a79d0769849114c057ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50554f4ce3490587e489ca762a0e304" id="r_ae50554f4ce3490587e489ca762a0e304"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:ae50554f4ce3490587e489ca762a0e304"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::DensePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae50554f4ce3490587e489ca762a0e304">df_direct_integrals</a> (const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;bra, const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;ket, <a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3">Formula::Notation</a> notation=<a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3af5b28c5994e6d7ab604ddcd503be7fc0">Formula::Notation::Chemical</a>)</td></tr>
<tr class="separator:ae50554f4ce3490587e489ca762a0e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab817a456daf038ea1b1a5a08816a4e25" id="r_ab817a456daf038ea1b1a5a08816a4e25"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:ab817a456daf038ea1b1a5a08816a4e25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab817a456daf038ea1b1a5a08816a4e25">df_direct_integrals</a> (const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;bra, const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;ket, const std::wstring &amp;int_expr, const std::wstring &amp;bra_3c=L&quot;&quot;, const std::wstring &amp;ket_3c=L&quot;&quot;)</td></tr>
<tr class="separator:ab817a456daf038ea1b1a5a08816a4e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6c3711078ce5c9eb6ba242dc52f80d" id="r_acc6c3711078ce5c9eb6ba242dc52f80d"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile  = Tile, typename Engine  = libint2::Engine&gt; </td></tr>
<tr class="memitem:acc6c3711078ce5c9eb6ba242dc52f80d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html">IntegralBuilder</a>&lt; Tile, ComputeTile, Engine &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#acc6c3711078ce5c9eb6ba242dc52f80d">make_integral_builder</a> (<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt; shr_epool, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> &amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; shr_screen, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:acc6c3711078ce5c9eb6ba242dc52f80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make detection of template parameters easier, see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html" title="Builds integrals from an array of bases and an integral engine pool.">IntegralBuilder</a> for details.  <br /></td></tr>
<tr class="separator:acc6c3711078ce5c9eb6ba242dc52f80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213fce77f9c4ddab1712c376a3f4bd2e" id="r_a213fce77f9c4ddab1712c376a3f4bd2e"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile  = Tile, typename Engine  = libint2::Engine&gt; </td></tr>
<tr class="memitem:a213fce77f9c4ddab1712c376a3f4bd2e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a>&lt; Tile, ComputeTile, Engine &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a213fce77f9c4ddab1712c376a3f4bd2e">make_direct_integral_builder</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt; shr_epool, const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> &amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; shr_screen, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a213fce77f9c4ddab1712c376a3f4bd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make detection of template parameters easier, see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a> for details.  <br /></td></tr>
<tr class="separator:a213fce77f9c4ddab1712c376a3f4bd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a50ef6535d77e03707e4cd94908460" id="r_ae5a50ef6535d77e03707e4cd94908460"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:ae5a50ef6535d77e03707e4cd94908460"><td class="memTemplItemLeft" align="right" valign="top">libint2::Engine&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae5a50ef6535d77e03707e4cd94908460">make_engine</a> (const libint2::Operator &amp;oper, Bases &amp;&amp;bases, libint2::BraKet braket=libint2::BraKet::invalid, libint2::any oper_params=libint2::any(), int deriv_order=0, double engine_precision=std::numeric_limits&lt; double &gt;::epsilon(), const libint2::scalar_type &amp;scalar=libint2::scalar_type(1.0), int <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a4d9799486007f292ac8c597553dce604">max_am</a>=0, size_t <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae463540711e7a5718ff6f313ac0d84fb">max_nprim</a>=0)</td></tr>
<tr class="separator:ae5a50ef6535d77e03707e4cd94908460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bd4904817812737f26c01083e9bd20" id="r_a14bd4904817812737f26c01083e9bd20"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a14bd4904817812737f26c01083e9bd20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; libint2::Engine &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a14bd4904817812737f26c01083e9bd20">make_engine_pool</a> (const libint2::Operator &amp;oper, Bases &amp;&amp;bases, libint2::BraKet braket=libint2::BraKet::invalid, libint2::any oper_params=libint2::any(), const libint2::scalar_type &amp;scalar=libint2::scalar_type(1.0), double engine_precision=std::numeric_limits&lt; double &gt;::epsilon(), <a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22c">mpqc::DerivOrder</a> deriv_order=<a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22ca334c4a4c42fdb79d7ebc3e73b517e6f8">mpqc::DerivOrder::none</a>, int <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a4d9799486007f292ac8c597553dce604">max_am</a>=0, size_t <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae463540711e7a5718ff6f313ac0d84fb">max_nprim</a>=0)</td></tr>
<tr class="memdesc:a14bd4904817812737f26c01083e9bd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an pool of Engine objects.  <br /></td></tr>
<tr class="separator:a14bd4904817812737f26c01083e9bd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa037266c1937ea7d9b1d7cb4441245" id="r_affa037266c1937ea7d9b1d7cb4441245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#affa037266c1937ea7d9b1d7cb4441245">operator==</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &amp;<a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22ca8b04d5e3775d298e78455efc5ca404d5">first</a>, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &amp;<a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22caa9f0e61a137d86aa9db53465e0801612">second</a>)</td></tr>
<tr class="separator:affa037266c1937ea7d9b1d7cb4441245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520529051bc687b7eb3dabe709d0c497" id="r_a520529051bc687b7eb3dabe709d0c497"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a520529051bc687b7eb3dabe709d0c497"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a520529051bc687b7eb3dabe709d0c497">create_schwarz_screener</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; const &amp;eng, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> op, Bases &amp;&amp;bs_array, double thresh, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>, std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#ae6ab1c6c4c276ee9dc56ac7bc516d2f3">Q2Matrix::norm_op_type</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt; bs_Q_matrix_accessor={}, std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#ae6ab1c6c4c276ee9dc56ac7bc516d2f3">Q2Matrix::norm_op_type</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt; bspair_Q_matrix_accessor={})</td></tr>
<tr class="memdesc:a520529051bc687b7eb3dabe709d0c497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Schwarz <a class="el" href="classmpqc_1_1lcao_1_1_screener.html" title="Base class for screeners will never skip any integrals.">Screener</a>.  <br /></td></tr>
<tr class="separator:a520529051bc687b7eb3dabe709d0c497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ebb6b9f817aee252946d0e8bc6cc2a" id="r_a05ebb6b9f817aee252946d0e8bc6cc2a"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a05ebb6b9f817aee252946d0e8bc6cc2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a05ebb6b9f817aee252946d0e8bc6cc2a">create_schwarz_screener</a> (madness::World &amp;world, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> op, Bases &amp;&amp;bs_array, double thresh, std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#ae6ab1c6c4c276ee9dc56ac7bc516d2f3">Q2Matrix::norm_op_type</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt; bs_Q_matrix_accessor, std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#ae6ab1c6c4c276ee9dc56ac7bc516d2f3">Q2Matrix::norm_op_type</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt; bspair_Q_matrix_accessor, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a> norm_func=<a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a>)</td></tr>
<tr class="memdesc:a05ebb6b9f817aee252946d0e8bc6cc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Schwarz <a class="el" href="classmpqc_1_1lcao_1_1_screener.html" title="Base class for screeners will never skip any integrals.">Screener</a> using Q matrix accessors only.  <br /></td></tr>
<tr class="separator:a05ebb6b9f817aee252946d0e8bc6cc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad982d1881c84975870beeb160db6d049" id="r_ad982d1881c84975870beeb160db6d049"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile &gt; </td></tr>
<tr class="memitem:ad982d1881c84975870beeb160db6d049"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ad982d1881c84975870beeb160db6d049">map_W_sap_tensors</a> (E &amp;eng, const std::array&lt; libint2::Shell, 3 &gt; &amp;s, const std::array&lt; std::int64_t, 3 &gt; &amp;lb, const std::array&lt; std::int64_t, 3 &gt; &amp;ub, std::vector&lt; Tile &gt; &amp;t_w)</td></tr>
<tr class="memdesc:ad982d1881c84975870beeb160db6d049"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps the buffer computed by libint engine into vector of 4 tensors with W{0,x,y,z} tensors.  <br /></td></tr>
<tr class="separator:ad982d1881c84975870beeb160db6d049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8523fb921743b6bd1186c9f04c7e536" id="r_ab8523fb921743b6bd1186c9f04c7e536"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile &gt; </td></tr>
<tr class="memitem:ab8523fb921743b6bd1186c9f04c7e536"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab8523fb921743b6bd1186c9f04c7e536">map_W_tensors</a> (E &amp;eng, const std::array&lt; libint2::Shell, 2 &gt; &amp;s, const std::array&lt; std::int64_t, 2 &gt; &amp;lb, const std::array&lt; std::int64_t, 2 &gt; &amp;ub, std::vector&lt; Tile &gt; &amp;t_w)</td></tr>
<tr class="memdesc:ab8523fb921743b6bd1186c9f04c7e536"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps the buffer computed by libint engine into vector of 4 tensors with W{0,x,y,z} tensors.  <br /></td></tr>
<tr class="separator:ab8523fb921743b6bd1186c9f04c7e536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8751eea9571113dc8c6b133e22e1fae8" id="r_a8751eea9571113dc8c6b133e22e1fae8"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile &gt; </td></tr>
<tr class="memitem:a8751eea9571113dc8c6b133e22e1fae8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a8751eea9571113dc8c6b133e22e1fae8">map_xyz_tensors</a> (E &amp;eng, const std::array&lt; libint2::Shell, 2 &gt; &amp;s, const std::array&lt; std::int64_t, 2 &gt; &amp;lb, const std::array&lt; std::int64_t, 2 &gt; &amp;ub, std::vector&lt; Tile &gt; &amp;t_xyz)</td></tr>
<tr class="memdesc:a8751eea9571113dc8c6b133e22e1fae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps the buffer computed by libint engine into vector of 3 tensors with dipole moment integrals in order ux, uy, uz.  <br /></td></tr>
<tr class="separator:a8751eea9571113dc8c6b133e22e1fae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc375d8dc0a5b7cc60bff91945056192" id="r_adc375d8dc0a5b7cc60bff91945056192"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases , typename Mapper &gt; </td></tr>
<tr class="memitem:adc375d8dc0a5b7cc60bff91945056192"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#adc375d8dc0a5b7cc60bff91945056192">sparse_multi_integrals3</a> (const int num_ints, madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, const Mapper &amp;map_tensors, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="memdesc:adc375d8dc0a5b7cc60bff91945056192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct set of sparse multi tensor 3-center integrals in parallel.  <br /></td></tr>
<tr class="separator:adc375d8dc0a5b7cc60bff91945056192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8c813a8f68db9917b8a79702570140" id="r_a4f8c813a8f68db9917b8a79702570140"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases , typename Mapper &gt; </td></tr>
<tr class="memitem:a4f8c813a8f68db9917b8a79702570140"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a4f8c813a8f68db9917b8a79702570140">sparse_multi_integrals</a> (const int num_ints, madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, const Mapper &amp;map_tensors, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="memdesc:a4f8c813a8f68db9917b8a79702570140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct set of sparse multi tensor integrals in parallel.  <br /></td></tr>
<tr class="separator:a4f8c813a8f68db9917b8a79702570140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6132b68519a0b7c8886d78449580fafa" id="r_a6132b68519a0b7c8886d78449580fafa"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </td></tr>
<tr class="memitem:a6132b68519a0b7c8886d78449580fafa"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a6132b68519a0b7c8886d78449580fafa">sparse_W_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a6132b68519a0b7c8886d78449580fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d959b5f2c3c6892567bdf1e4b0744c" id="r_a45d959b5f2c3c6892567bdf1e4b0744c"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </td></tr>
<tr class="memitem:a45d959b5f2c3c6892567bdf1e4b0744c"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45d959b5f2c3c6892567bdf1e4b0744c">sparse_W_sap_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a45d959b5f2c3c6892567bdf1e4b0744c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a073a15bb99fd8c89824f911daeea65" id="r_a7a073a15bb99fd8c89824f911daeea65"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </td></tr>
<tr class="memitem:a7a073a15bb99fd8c89824f911daeea65"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a7a073a15bb99fd8c89824f911daeea65">sparse_xyz_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="memdesc:a7a073a15bb99fd8c89824f911daeea65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct set of sparse integral tensors in parallel.  <br /></td></tr>
<tr class="separator:a7a073a15bb99fd8c89824f911daeea65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13873184c31b1ab298cb8d7ea5bd75d" id="r_ae13873184c31b1ab298cb8d7ea5bd75d"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Bases , typename Tile  = TA::TensorD&gt; </td></tr>
<tr class="memitem:ae13873184c31b1ab298cb8d7ea5bd75d"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, TA::DensePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae13873184c31b1ab298cb8d7ea5bd75d">dense_xyz_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="memdesc:ae13873184c31b1ab298cb8d7ea5bd75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct dense integral tensors from sets in parallel.  <br /></td></tr>
<tr class="separator:ae13873184c31b1ab298cb8d7ea5bd75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d084b43e954e9dca1a628afccbdbd17" id="r_a9d084b43e954e9dca1a628afccbdbd17"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a9d084b43e954e9dca1a628afccbdbd17"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9d084b43e954e9dca1a628afccbdbd17">W_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="memdesc:a9d084b43e954e9dca1a628afccbdbd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct set of sparse W {0,x,y,z} integral tensors in parallel.  <br /></td></tr>
<tr class="separator:a9d084b43e954e9dca1a628afccbdbd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc21d1f2d7c377113965e26bb19135a" id="r_a3dc21d1f2d7c377113965e26bb19135a"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a3dc21d1f2d7c377113965e26bb19135a"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a3dc21d1f2d7c377113965e26bb19135a">W_sap_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a3dc21d1f2d7c377113965e26bb19135a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fe9cad4a734ee3dc01ac1bab2ebca5" id="r_a72fe9cad4a734ee3dc01ac1bab2ebca5"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </td></tr>
<tr class="memitem:a72fe9cad4a734ee3dc01ac1bab2ebca5"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::DensePolicy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a72fe9cad4a734ee3dc01ac1bab2ebca5">xyz_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a72fe9cad4a734ee3dc01ac1bab2ebca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23765e93d3338e61943c6f6189e76d9" id="r_ae23765e93d3338e61943c6f6189e76d9"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </td></tr>
<tr class="memitem:ae23765e93d3338e61943c6f6189e76d9"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae23765e93d3338e61943c6f6189e76d9">xyz_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:ae23765e93d3338e61943c6f6189e76d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5441f5d04156be1aa94e292b925c8c6f" id="r_a5441f5d04156be1aa94e292b925c8c6f"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </td></tr>
<tr class="memitem:a5441f5d04156be1aa94e292b925c8c6f"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, TA::SparsePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5441f5d04156be1aa94e292b925c8c6f">sparse_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{}, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:a5441f5d04156be1aa94e292b925c8c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct sparse integral tensors in parallel.  <br /></td></tr>
<tr class="separator:a5441f5d04156be1aa94e292b925c8c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a552683f3df1490488a1537bdaabf4" id="r_ae9a552683f3df1490488a1537bdaabf4"><td class="memTemplParams" colspan="2">template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </td></tr>
<tr class="memitem:ae9a552683f3df1490488a1537bdaabf4"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, TA::DensePolicy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae9a552683f3df1490488a1537bdaabf4">dense_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; shr_pool, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{}, std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt; make_shellpair_data_accessor={}, std::shared_ptr&lt; const math::PetiteList &gt; plist=<a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>())</td></tr>
<tr class="memdesc:ae9a552683f3df1490488a1537bdaabf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dense integral tensor in parallel.  <br /></td></tr>
<tr class="separator:ae9a552683f3df1490488a1537bdaabf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adede2cb460adba69d21b59fdfd6e10fc" id="r_adede2cb460adba69d21b59fdfd6e10fc"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Bases &gt; </td></tr>
<tr class="memitem:adede2cb460adba69d21b59fdfd6e10fc"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#adede2cb460adba69d21b59fdfd6e10fc">compute_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; libint2::Engine &gt; &amp;engine, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; p_screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:adede2cb460adba69d21b59fdfd6e10fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013f33a8624a1f1350be5b19e344db3e" id="r_a013f33a8624a1f1350be5b19e344db3e"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Bases &gt; </td></tr>
<tr class="memitem:a013f33a8624a1f1350be5b19e344db3e"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::DensePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a013f33a8624a1f1350be5b19e344db3e">compute_integrals</a> (madness::World &amp;world, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; libint2::Engine &gt; &amp;engine, Bases &amp;&amp;bases, std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt; p_screen=std::make_shared&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{}), std::function&lt; Tile(Tile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, Tile, true &gt;{})</td></tr>
<tr class="separator:a013f33a8624a1f1350be5b19e344db3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbd7917960a8685a05156509a261fca" id="r_a6bbd7917960a8685a05156509a261fca"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a6bbd7917960a8685a05156509a261fca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a6bbd7917960a8685a05156509a261fca">to_basis_shr_vector</a> (Bases &amp;&amp;bases)</td></tr>
<tr class="separator:a6bbd7917960a8685a05156509a261fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492cb6acdacebec0bdd36ea4cfcef333" id="r_a492cb6acdacebec0bdd36ea4cfcef333"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a492cb6acdacebec0bdd36ea4cfcef333"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a9e4e1df2244ae775566f28b9e358b5b9">BasisRefVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a492cb6acdacebec0bdd36ea4cfcef333">to_basis_ref_vector</a> (Bases &amp;&amp;bases)</td></tr>
<tr class="separator:a492cb6acdacebec0bdd36ea4cfcef333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28a9a19375763ee76844d2ca9bdb906" id="r_af28a9a19375763ee76844d2ca9bdb906"><td class="memTemplParams" colspan="2">template&lt;typename BS &gt; </td></tr>
<tr class="memitem:af28a9a19375763ee76844d2ca9bdb906"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#af28a9a19375763ee76844d2ca9bdb906">to_basis_ref</a> (BS &amp;&amp;bs)</td></tr>
<tr class="separator:af28a9a19375763ee76844d2ca9bdb906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4b4abad3a50bf2c3986c8ba27ae671" id="r_a3b4b4abad3a50bf2c3986c8ba27ae671"><td class="memTemplParams" colspan="2">template&lt;typename Bases &gt; </td></tr>
<tr class="memitem:a3b4b4abad3a50bf2c3986c8ba27ae671"><td class="memTemplItemLeft" align="right" valign="top">TA::TiledRange&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a3b4b4abad3a50bf2c3986c8ba27ae671">make_trange</a> (Bases &amp;&amp;bases)</td></tr>
<tr class="separator:a3b4b4abad3a50bf2c3986c8ba27ae671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624a2cfbd0e1f07915b4daa839a0504b" id="r_a624a2cfbd0e1f07915b4daa839a0504b"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Array &gt; </td></tr>
<tr class="memitem:a624a2cfbd0e1f07915b4daa839a0504b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a624a2cfbd0e1f07915b4daa839a0504b">set_array</a> (std::vector&lt; std::pair&lt; unsigned long, Tile &gt; &gt; &amp;tiles, Array &amp;a)</td></tr>
<tr class="separator:a624a2cfbd0e1f07915b4daa839a0504b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c8449dd834a77e511fc297a4b17f8a" id="r_a81c8449dd834a77e511fc297a4b17f8a"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a81c8449dd834a77e511fc297a4b17f8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a81c8449dd834a77e511fc297a4b17f8a">set_array</a> (std::vector&lt; std::pair&lt; unsigned long, Tile &gt; &gt; &amp;tiles, TiledArray::DistArrayVector&lt; Tile, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a81c8449dd834a77e511fc297a4b17f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16939087b32cef6ba81b605fb0ee7657" id="r_a16939087b32cef6ba81b605fb0ee7657"><td class="memTemplParams" colspan="2">template&lt;typename ShellIterator &gt; </td></tr>
<tr class="memitem:a16939087b32cef6ba81b605fb0ee7657"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a16939087b32cef6ba81b605fb0ee7657">min_ao_occupation_vector</a> (size_t Z, ShellIterator shell_begin, ShellIterator shell_end, std::int64_t Q=0)</td></tr>
<tr class="memdesc:a16939087b32cef6ba81b605fb0ee7657"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes average orbital occupancies in ground-state atom/ion  <br /></td></tr>
<tr class="separator:a16939087b32cef6ba81b605fb0ee7657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7181d4196807e3d4e075141e6ec47f5" id="r_af7181d4196807e3d4e075141e6ec47f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#af7181d4196807e3d4e075141e6ec47f5">soad_density_eig_matrix</a> (<a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;mol, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;minbs, std::vector&lt; double &gt; atomic_net_charges={})</td></tr>
<tr class="separator:af7181d4196807e3d4e075141e6ec47f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24f4ec89de556dfce536b5a9088cd60" id="r_ae24f4ec89de556dfce536b5a9088cd60"><td class="memTemplParams" colspan="2">template&lt;typename Engs , typename Tile , typename ComputeTile , typename Policy &gt; </td></tr>
<tr class="memitem:ae24f4ec89de556dfce536b5a9088cd60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae24f4ec89de556dfce536b5a9088cd60">soad_task</a> (Engs eng_pool, const std::array&lt; int64_t, 2 &gt; &amp;tile_idx, const std::array&lt; std::vector&lt; libint2::Shell &gt; const *, 2 &gt; &amp;obs_row_and_col_ptrs, std::vector&lt; libint2::Shell &gt; const *min_bs, const <a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a> *D, TA::DistArray&lt; Tile, Policy &gt; *F, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op, const std::array&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>, 3 &gt; *shellpair_data_accessors, const std::array&lt; std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt;, 2 &gt; *jk_screeners)</td></tr>
<tr class="separator:ae24f4ec89de556dfce536b5a9088cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32765e75d293dd704f0150a4c7a5c43" id="r_ae32765e75d293dd704f0150a4c7a5c43"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </td></tr>
<tr class="memitem:ae32765e75d293dd704f0150a4c7a5c43"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae32765e75d293dd704f0150a4c7a5c43">fock_from_soad_impl</a> (<a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;wfn_world, <a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a> const &amp;D, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;obs, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;minbs, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;())</td></tr>
<tr class="separator:ae32765e75d293dd704f0150a4c7a5c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587ae654bb62b6f25eadc29dfc5a2c02" id="r_a587ae654bb62b6f25eadc29dfc5a2c02"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </td></tr>
<tr class="memitem:a587ae654bb62b6f25eadc29dfc5a2c02"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a587ae654bb62b6f25eadc29dfc5a2c02">fock_from_soad</a> (<a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;wfn_world, <a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;clustered_mol, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;bs, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;minbs, TA::DistArrayVector&lt; Tile, Policy &gt; const &amp;H, bool use_uncontracted_bs=false, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;())</td></tr>
<tr class="separator:a587ae654bb62b6f25eadc29dfc5a2c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33946559704fecc6e74382925ab775e" id="r_ab33946559704fecc6e74382925ab775e"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </td></tr>
<tr class="memitem:ab33946559704fecc6e74382925ab775e"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArrayVector&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::DensePolicy &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab33946559704fecc6e74382925ab775e">fock_from_soad</a> (<a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;wfn_world, <a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;clustered_mol, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;obs, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;minbs, TA::DistArrayVector&lt; Tile, Policy &gt; const &amp;H, bool use_uncontracted_obs=false, std::function&lt; Tile(ComputeTile &amp;&amp;)&gt; op=TA::detail::Noop&lt; Tile, ComputeTile, true &gt;())</td></tr>
<tr class="separator:ab33946559704fecc6e74382925ab775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5bd9c684fc72526ba39a59078b49c1ac" id="r_a5bd9c684fc72526ba39a59078b49c1ac"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5bd9c684fc72526ba39a59078b49c1ac">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html">Basis::Factory</a> const &amp;f)</td></tr>
<tr class="separator:a5bd9c684fc72526ba39a59078b49c1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e9e89bdcfc1878433bdaf57f037006" id="r_ab8e9e89bdcfc1878433bdaf57f037006"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab8e9e89bdcfc1878433bdaf57f037006">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;b)</td></tr>
<tr class="separator:ab8e9e89bdcfc1878433bdaf57f037006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d324854ba6f208cda3f9bdce132d412" id="r_a3d324854ba6f208cda3f9bdce132d412"><td class="memItemLeft" align="right" valign="top">Eigen::RowVectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a3d324854ba6f208cda3f9bdce132d412">sub_basis_map</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;sub_basis)</td></tr>
<tr class="separator:a3d324854ba6f208cda3f9bdce132d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa553b885e80e63bf7bd89bda96a8038a" id="r_aa553b885e80e63bf7bd89bda96a8038a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aa553b885e80e63bf7bd89bda96a8038a">uncontract</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis1)</td></tr>
<tr class="separator:aa553b885e80e63bf7bd89bda96a8038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace13041b589f8efd497d89a7b95e2202" id="r_ace13041b589f8efd497d89a7b95e2202"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ace13041b589f8efd497d89a7b95e2202">concat</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis1, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis2)</td></tr>
<tr class="separator:ace13041b589f8efd497d89a7b95e2202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb719a19c245c80e6e57611008b6605a" id="r_afb719a19c245c80e6e57611008b6605a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#afb719a19c245c80e6e57611008b6605a">concat_unique</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis1, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis2)</td></tr>
<tr class="separator:afb719a19c245c80e6e57611008b6605a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14199c8577534e8be792a7103a124036" id="r_a14199c8577534e8be792a7103a124036"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a14199c8577534e8be792a7103a124036">merge</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis1, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;basis2, std::int64_t nclusters_target)</td></tr>
<tr class="separator:a14199c8577534e8be792a7103a124036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d921175ffc2f59e28f7322f23c1441e" id="r_a0d921175ffc2f59e28f7322f23c1441e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a0d921175ffc2f59e28f7322f23c1441e">parallel_make_basis</a> (madness::World &amp;world, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html">Basis::Factory</a> &amp;factory, const <a class="el" href="classmpqc_1_1_molecule.html">mpqc::Molecule</a> &amp;mol)</td></tr>
<tr class="separator:a0d921175ffc2f59e28f7322f23c1441e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14daf97f21a6466f9985c84b21333b6" id="r_ac14daf97f21a6466f9985c84b21333b6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ac14daf97f21a6466f9985c84b21333b6">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_atomic_basis.html">AtomicBasis</a> const &amp;b)</td></tr>
<tr class="separator:ac14daf97f21a6466f9985c84b21333b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f865ab572c9546cf53aa2dec681f305" id="r_a1f865ab572c9546cf53aa2dec681f305"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a1f865ab572c9546cf53aa2dec681f305"><td class="memTemplItemLeft" align="right" valign="top">TA::DistArray&lt; Tile, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a1f865ab572c9546cf53aa2dec681f305">contraction_matrix</a> (madness::World &amp;world, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">gaussian::Basis</a> &amp;primitive_basis, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">gaussian::Basis</a> &amp;contracted_basis)</td></tr>
<tr class="separator:a1f865ab572c9546cf53aa2dec681f305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755d72248fbad1639c6a94f42bf123a1" id="r_a755d72248fbad1639c6a94f42bf123a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a755d72248fbad1639c6a94f42bf123a1">operator==</a> (const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;one, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;two)</td></tr>
<tr class="separator:a755d72248fbad1639c6a94f42bf123a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7e99c5fa82162344fae7040cbc8e1f" id="r_a9a7e99c5fa82162344fae7040cbc8e1f"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename... Args&gt; </td></tr>
<tr class="memitem:a9a7e99c5fa82162344fae7040cbc8e1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9a7e99c5fa82162344fae7040cbc8e1f">retile</a> (<a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;basis, Op op, Args... args)</td></tr>
<tr class="memdesc:a9a7e99c5fa82162344fae7040cbc8e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">retiles a basis preserving shell structure  <br /></td></tr>
<tr class="separator:a9a7e99c5fa82162344fae7040cbc8e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace includes all functionality related to computing in a Gaussian AO representation. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a25c5b3980c43882e8ed5e1e1ca84d42c" name="a25c5b3980c43882e8ed5e1e1ca84d42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c5b3980c43882e8ed5e1e1ca84d42c">&#9670;&#160;</a></span>basis_Q_matrix_accessor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a25c5b3980c43882e8ed5e1e1ca84d42c">mpqc::lcao::gaussian::basis_Q_matrix_accessor_t</a> = typedef std::function&lt;std::shared_ptr&lt;const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a>&gt;( const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9f910069d8c33df99ad2e1cd19c1caaa">norm_op_t</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9130eb5a36983dca4b6483abe1bde61b" name="a9130eb5a36983dca4b6483abe1bde61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9130eb5a36983dca4b6483abe1bde61b">&#9670;&#160;</a></span>basispair_Q_matrix_accessor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9130eb5a36983dca4b6483abe1bde61b">mpqc::lcao::gaussian::basispair_Q_matrix_accessor_t</a> = typedef std::function&lt;std::shared_ptr&lt;const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a>&gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9f910069d8c33df99ad2e1cd19c1caaa">norm_op_t</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1ce89182bb6ac2b31aa54f71352597d" name="ad1ce89182bb6ac2b31aa54f71352597d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ce89182bb6ac2b31aa54f71352597d">&#9670;&#160;</a></span>fmm_shell_data_accessor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ad1ce89182bb6ac2b31aa54f71352597d">mpqc::lcao::gaussian::fmm_shell_data_accessor_t</a> = typedef std::function&lt;const <a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_data.html">FMMShellData</a> &amp;(std::size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd97e64da2aa2c316e9b6824d7b0606e" name="acd97e64da2aa2c316e9b6824d7b0606e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd97e64da2aa2c316e9b6824d7b0606e">&#9670;&#160;</a></span>fmm_shellpair_data_accessor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#acd97e64da2aa2c316e9b6824d7b0606e">mpqc::lcao::gaussian::fmm_shellpair_data_accessor_t</a> = typedef std::function&lt;const <a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_f_m_m_shell_pair_data.html">FMMShellPairData</a> &amp;(std::size_t, std::size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f910069d8c33df99ad2e1cd19c1caaa" name="a9f910069d8c33df99ad2e1cd19c1caaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f910069d8c33df99ad2e1cd19c1caaa">&#9670;&#160;</a></span>norm_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a9f910069d8c33df99ad2e1cd19c1caaa">mpqc::lcao::gaussian::norm_op_t</a> = typedef double(Eigen::Map&lt;const <a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a>&gt; const &amp;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98f638764dba43a9aefbe5c529e766d9" name="a98f638764dba43a9aefbe5c529e766d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f638764dba43a9aefbe5c529e766d9">&#9670;&#160;</a></span>OrbitalBasisRegistry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a98f638764dba43a9aefbe5c529e766d9">mpqc::lcao::gaussian::OrbitalBasisRegistry</a> = typedef <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_registry.html">BasisRegistry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aded59e8a710ae55d49de715671f144c4" name="aded59e8a710ae55d49de715671f144c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded59e8a710ae55d49de715671f144c4">&#9670;&#160;</a></span>Shell <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef libint2::Shell <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">mpqc::lcao::gaussian::Shell</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45f3517e0399a3e6a4966e7a1e6df29a" name="a45f3517e0399a3e6a4966e7a1e6df29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f3517e0399a3e6a4966e7a1e6df29a">&#9670;&#160;</a></span>shellpair_data_accessor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">mpqc::lcao::gaussian::shellpair_data_accessor_t</a> = typedef std::function&lt;const libint2::ShellPair *(std::size_t, std::size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae867b676d97f85013d7c64e693923168" name="ae867b676d97f85013d7c64e693923168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae867b676d97f85013d7c64e693923168">&#9670;&#160;</a></span>ShellVec <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aded59e8a710ae55d49de715671f144c4">Shell</a> &gt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">mpqc::lcao::gaussian::ShellVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ae162936cb74b41bc13595e3dd2af3f" name="a1ae162936cb74b41bc13595e3dd2af3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae162936cb74b41bc13595e3dd2af3f">&#9670;&#160;</a></span>sqvl_shell_data_accessor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a1ae162936cb74b41bc13595e3dd2af3f">mpqc::lcao::gaussian::sqvl_shell_data_accessor_t</a> = typedef std::function&lt;const <a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_data.html">SQVlShellData</a> &amp;(std::size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb05e569ac77137911929a78192cdb4f" name="aeb05e569ac77137911929a78192cdb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb05e569ac77137911929a78192cdb4f">&#9670;&#160;</a></span>sqvl_shellpair_data_accessor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#aeb05e569ac77137911929a78192cdb4f">mpqc::lcao::gaussian::sqvl_shellpair_data_accessor_t</a> = typedef std::function&lt;const <a class="el" href="structmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_shell_pair_data.html">SQVlShellPairData</a> &amp;(std::size_t, std::size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a64a7d64e96194afd83934d4f16e44c03" name="a64a7d64e96194afd83934d4f16e44c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a7d64e96194afd83934d4f16e44c03">&#9670;&#160;</a></span>cluster_composition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mpqc::lcao::gaussian::cluster_composition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>a string with L-wise shell composition of a cluster </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>a shell cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string showing number of shells with each angular momentum </dd></dl>

</div>
</div>
<a id="adede2cb460adba69d21b59fdfd6e10fc" name="adede2cb460adba69d21b59fdfd6e10fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adede2cb460adba69d21b59fdfd6e10fc">&#9670;&#160;</a></span>compute_integrals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt;::type &gt; mpqc::lcao::gaussian::compute_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; libint2::Engine &gt; &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>p_screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a013f33a8624a1f1350be5b19e344db3e" name="a013f33a8624a1f1350be5b19e344db3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013f33a8624a1f1350be5b19e344db3e">&#9670;&#160;</a></span>compute_integrals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::DensePolicy &gt;::type &gt; mpqc::lcao::gaussian::compute_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; libint2::Engine &gt; &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>p_screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2814e6bcedeb919f0343b9ae089382e" name="ad2814e6bcedeb919f0343b9ae089382e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2814e6bcedeb919f0343b9ae089382e">&#9670;&#160;</a></span>compute_shellblock_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::detail::real_t&lt; TA::DistArray&lt; Tile, Policy &gt; &gt; mpqc::lcao::gaussian::compute_shellblock_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>bs0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>bs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>&quot;dist_inf&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This calculates shell block norms of density matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tile</td><td>The tile type of <code>D</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy type of <code>D</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs0</td><td>is the basis along first dimension of <code>D</code> </td></tr>
    <tr><td class="paramname">bs1</td><td>is the basis along second dimension of <code>D</code> </td></tr>
    <tr><td class="paramname">D</td><td>is the density matrix as a <code>DistArray</code> </td></tr>
    <tr><td class="paramname">screen</td><td>is a string type that determines the norm used; for valid values see the argument of the same name in <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ab9324b9390c81a5391ad96e05b510118" title="factory for ThresholdedScreener objects">mpqc::lcao::gaussian::make_screener</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>DistArray</code> holding shell block norms of <code>D</code> </dd></dl>

</div>
</div>
<a id="aaa0ea66df0f12ca1c23210bdbbd4e3ae" name="aaa0ea66df0f12ca1c23210bdbbd4e3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0ea66df0f12ca1c23210bdbbd4e3ae">&#9670;&#160;</a></span>compute_shellblock_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::detail::real_t&lt; TA::DistArray&lt; Tile, Policy &gt; &gt; mpqc::lcao::gaussian::compute_shellblock_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>bs0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a6d2c23098746cde07fefd7f4bcca02" name="a5a6d2c23098746cde07fefd7f4bcca02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6d2c23098746cde07fefd7f4bcca02">&#9670;&#160;</a></span>compute_x2c_coreH()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealTile , typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt;, <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt;, <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &gt; mpqc::lcao::gaussian::compute_x2c_coreH </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &gt;&#160;</td>
          <td class="paramname"><em>wfn_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; RealTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; RealTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; RealTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_cond_number</em> = <code>1e8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfaf034e3d03f7ebf9d308bbb15fd7c7" name="adfaf034e3d03f7ebf9d308bbb15fd7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaf034e3d03f7ebf9d308bbb15fd7c7">&#9670;&#160;</a></span>compute_Xmat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; mpqc::lcao::gaussian::compute_Xmat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a5d7bc8f0ed3636e5287fd8333e1f915e">H1eType</a>&#160;</td>
          <td class="paramname"><em>h1e_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#ab9ba5f8aa68fa5999de8253abfe12351">DistArray</a>&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArrayVector&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace13041b589f8efd497d89a7b95e2202" name="ace13041b589f8efd497d89a7b95e2202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace13041b589f8efd497d89a7b95e2202">&#9670;&#160;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; mpqc::lcao::gaussian::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>merges two <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects by concatenating their shell cluster sequences </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basis1</td><td>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basis2</td><td>another <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a union of <code>basis1</code> and <code>basis2</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>clusters of the two bases are unchanged, and duplicates are not eliminated; see <code>concat_unique(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&amp;, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&amp;)</code> and <code>merge(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&amp;, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&amp;)</code> for an alternative </dd></dl>

</div>
</div>
<a id="afb719a19c245c80e6e57611008b6605a" name="afb719a19c245c80e6e57611008b6605a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb719a19c245c80e6e57611008b6605a">&#9670;&#160;</a></span>concat_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; mpqc::lcao::gaussian::concat_unique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>merges two <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects by concatenating their shell cluster sequences, and removing duplicate shells. Deduplication proceeds as follows:</p><ul>
<li>clusters in basis2 that are completely duplicated in basis1 are eliminated to produce basis2_uc</li>
<li>clusters in basis1 that are completely duplicated in basis2_uc are eliminated to produce basis1_uc</li>
<li>shells from basis2_uc that appear in basis1_uc are removed and the resulting clusters of unique shells are appended to basis1_uc <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basis1</td><td>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basis2</td><td>another <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a union of <code>basis1</code> and <code>basis2</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>unlike <code>merge(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&amp;, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>&amp;)</code>, clusters are preserved as much as possible </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1f865ab572c9546cf53aa2dec681f305" name="a1f865ab572c9546cf53aa2dec681f305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f865ab572c9546cf53aa2dec681f305">&#9670;&#160;</a></span>contraction_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, Policy &gt; mpqc::lcao::gaussian::contraction_matrix </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">gaussian::Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>primitive_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">gaussian::Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>contracted_basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes matrix transforming <code>primitive_basis</code> to <code>contracted_basis</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uncontracted_basis</td><td>a primitive vesion of <code>contracted_basis</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contracted_basis</td><td>a contracted basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix transforming primitive AOs to contracted AOs </dd></dl>

</div>
</div>
<a id="a05ebb6b9f817aee252946d0e8bc6cc2a" name="a05ebb6b9f817aee252946d0e8bc6cc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ebb6b9f817aee252946d0e8bc6cc2a">&#9670;&#160;</a></span>create_schwarz_screener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a> mpqc::lcao::gaussian::create_schwarz_screener </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bs_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#ae6ab1c6c4c276ee9dc56ac7bc516d2f3">Q2Matrix::norm_op_type</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt;&#160;</td>
          <td class="paramname"><em>bs_Q_matrix_accessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#ae6ab1c6c4c276ee9dc56ac7bc516d2f3">Q2Matrix::norm_op_type</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt;&#160;</td>
          <td class="paramname"><em>bspair_Q_matrix_accessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Schwarz <a class="el" href="classmpqc_1_1lcao_1_1_screener.html" title="Base class for screeners will never skip any integrals.">Screener</a> using Q matrix accessors only. </p>

</div>
</div>
<a id="a520529051bc687b7eb3dabe709d0c497" name="a520529051bc687b7eb3dabe709d0c497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520529051bc687b7eb3dabe709d0c497">&#9670;&#160;</a></span>create_schwarz_screener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a> mpqc::lcao::gaussian::create_schwarz_screener </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>eng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bs_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#ae6ab1c6c4c276ee9dc56ac7bc516d2f3">Q2Matrix::norm_op_type</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt;&#160;</td>
          <td class="paramname"><em>bs_Q_matrix_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &gt;(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html#ae6ab1c6c4c276ee9dc56ac7bc516d2f3">Q2Matrix::norm_op_type</a>, <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>)&gt;&#160;</td>
          <td class="paramname"><em>bspair_Q_matrix_accessor</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Schwarz <a class="el" href="classmpqc_1_1lcao_1_1_screener.html" title="Base class for screeners will never skip any integrals.">Screener</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>an engine type </td></tr>
    <tr><td class="paramname">Bases</td><td>a directly-addressable sequence of basis sets (or reference proxies, e.g. std::reference_wrapper)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>is a reference to the world in which the distributed screener data will be computed and stores</td></tr>
    <tr><td class="paramname">eng</td><td>is a reference to a ShrPool&lt;E&gt;</td></tr>
    <tr><td class="paramname">op</td><td>operator type</td></tr>
    <tr><td class="paramname">bs_array</td><td>is a reference to a directly-addressable sequence of basis sets, if the length is 3 then DF integrals are assumed and the first basis is assumed to be the auxiliary basis if the length is 4 then it is assumed that four center screening is desired. There is no requirement that any basis sets be the same.</td></tr>
    <tr><td class="paramname">thresh</td><td>is the Schwarz Screening threshold</td></tr>
    <tr><td class="paramname">norm_func</td><td>is the function pointer that returns a norm, it should have a signature double (Eigen::Map&lt;const RowMatrixXd&gt; const &amp;)</td></tr>
    <tr><td class="paramname">bs_Q_matrix_accessor</td><td>if nonnull, will use this to produce <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html" title="Class which holds shell set information for screening.">Q2Matrix</a> for a basis</td></tr>
    <tr><td class="paramname">bspair_Q_matrix_accessor</td><td>if nonnull, will use this to produce <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html" title="Class which holds shell set information for screening.">Q2Matrix</a> for a basis pair </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9a552683f3df1490488a1537bdaabf4" name="ae9a552683f3df1490488a1537bdaabf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a552683f3df1490488a1537bdaabf4">&#9670;&#160;</a></span>dense_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, TA::DensePolicy &gt; mpqc::lcao::gaussian::dense_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a dense integral tensor in parallel. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a5441f5d04156be1aa94e292b925c8c6f" title="Construct sparse integral tensors in parallel.">sparse_integrals</a> </dd></dl>

</div>
</div>
<a id="ae13873184c31b1ab298cb8d7ea5bd75d" name="ae13873184c31b1ab298cb8d7ea5bd75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13873184c31b1ab298cb8d7ea5bd75d">&#9670;&#160;</a></span>dense_xyz_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Bases , typename Tile  = TA::TensorD&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, TA::DensePolicy &gt; mpqc::lcao::gaussian::dense_xyz_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct dense integral tensors from sets in parallel. </p>
<p>This is needed for integrals such as the dipole integrals that come as a set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralEnginePool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes a TA::TensorD &amp;&amp; and returns any valid tile type. Op is copied so it can be moved. <div class="fragment"><div class="line"><span class="keyword">auto</span> t = [](TA::TensorD &amp;&amp;ten){<span class="keywordflow">return</span> std::move(ten);};</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae50554f4ce3490587e489ca762a0e304" name="ae50554f4ce3490587e489ca762a0e304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50554f4ce3490587e489ca762a0e304">&#9670;&#160;</a></span>df_direct_integrals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::DensePolicy &gt; mpqc::lcao::gaussian::df_direct_integrals </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3">Formula::Notation</a>&#160;</td>
          <td class="paramname"><em>notation</em> = <code><a class="el" href="classmpqc_1_1_formula.html#aec6c695225b1faf8e8851b04e62279e3af5b28c5994e6d7ab604ddcd503be7fc0">Formula::Notation::Chemical</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct direct dense LCAO integral from density fitting </p>

</div>
</div>
<a id="ab817a456daf038ea1b1a5a08816a4e25" name="ab817a456daf038ea1b1a5a08816a4e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab817a456daf038ea1b1a5a08816a4e25">&#9670;&#160;</a></span>df_direct_integrals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::df_direct_integrals </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>int_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>bra_3c</em> = <code>L&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>ket_3c</em> = <code>L&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct direct sparse LCAO integral from density fitting </p>

</div>
</div>
<a id="a221e6b861a67a79d0769849114c057ba" name="a221e6b861a67a79d0769849114c057ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221e6b861a67a79d0769849114c057ba">&#9670;&#160;</a></span>direct_dense_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::DensePolicy &gt; mpqc::lcao::gaussian::direct_dense_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct direct dense integral tensors in parallel with screening. </p>
<p>Same requirements on Op as those in Integral Builder </p>

</div>
</div>
<a id="ac17b1deae133bba061abcaa15502e003" name="ac17b1deae133bba061abcaa15502e003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17b1deae133bba061abcaa15502e003">&#9670;&#160;</a></span>direct_sparse_integrals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine  = libint2::Engine, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::direct_sparse_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct direct integral tensors in parallel with screening. </p>
<p>Same requirements on Op as those in Integral Builder </p>

</div>
</div>
<a id="a7de17af4022d89ed64736f73adc1c4c6" name="a7de17af4022d89ed64736f73adc1c4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de17af4022d89ed64736f73adc1c4c6">&#9670;&#160;</a></span>direct_sparse_integrals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Idx , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::direct_sparse_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; Idx, float &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>user_provided_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user_provided_norms_perelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct direct integral tensors in parallel with screening. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_provided_norms</td><td>is a user supplied replicated tensor with the norm estimates for the array. It is of type vector&lt;std::pair&lt;Idx, float&gt;&gt; where Idx is a type that provides random access via operator[] and the values are the indices of the tile. The float is then the norm estimate for that tile. </td></tr>
    <tr><td class="paramname">user_provided_norms_perelem</td><td>whether user_provided_norms are already scaled (per-element) or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a587ae654bb62b6f25eadc29dfc5a2c02" name="a587ae654bb62b6f25eadc29dfc5a2c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587ae654bb62b6f25eadc29dfc5a2c02">&#9670;&#160;</a></span>fock_from_soad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt;::type &gt; mpqc::lcao::gaussian::fock_from_soad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;&#160;</td>
          <td class="paramname"><em>wfn_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;&#160;</td>
          <td class="paramname"><em>clustered_mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>minbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::DistArrayVector&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_uncontracted_bs</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fock matrix computed from soad for SparsePolicy </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tile</td><td>a Tile type for the result </td></tr>
    <tr><td class="paramname">ComputeTile</td><td>the storage tile for integrals </td></tr>
    <tr><td class="paramname">Policy</td><td>TA::SparsePolicy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>world object </td></tr>
    <tr><td class="paramname">clustered_mol</td><td>molecule class </td></tr>
    <tr><td class="paramname">obs</td><td>basis object </td></tr>
    <tr><td class="paramname">minbs</td><td>minimal basis object </td></tr>
    <tr><td class="paramname">engs</td><td>engine </td></tr>
    <tr><td class="paramname">H</td><td>H matrix in Pauli representation </td></tr>
    <tr><td class="paramname">use_uncontracted_obs</td><td>specifies whether to use OBS in its uncontracted form </td></tr>
    <tr><td class="paramname">op</td><td>operator to convert ComputeTile to Tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAD Fock matrix in Pauli representation </dd></dl>

</div>
</div>
<a id="ab33946559704fecc6e74382925ab775e" name="ab33946559704fecc6e74382925ab775e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33946559704fecc6e74382925ab775e">&#9670;&#160;</a></span>fock_from_soad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::DensePolicy &gt;::type &gt; mpqc::lcao::gaussian::fock_from_soad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;&#160;</td>
          <td class="paramname"><em>wfn_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;&#160;</td>
          <td class="paramname"><em>clustered_mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>minbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::DistArrayVector&lt; Tile, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_uncontracted_obs</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fock matrix computed from soad for DensePolicy </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ShrPool</td><td></td></tr>
    <tr><td class="paramname">Tile</td><td>a Tile type for the result </td></tr>
    <tr><td class="paramname">ComputeTile</td><td>the storage tile for integrals </td></tr>
    <tr><td class="paramname">Policy</td><td>TA::DensePolicy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>world object </td></tr>
    <tr><td class="paramname">clustered_mol</td><td>molecule class </td></tr>
    <tr><td class="paramname">obs</td><td>basis object </td></tr>
    <tr><td class="paramname">minbs</td><td>minimal basis object </td></tr>
    <tr><td class="paramname">engs</td><td>engine </td></tr>
    <tr><td class="paramname">H</td><td>H matrix in Pauli representation </td></tr>
    <tr><td class="paramname">use_uncontracted_obs</td><td>if true, will compute the SOAD Fock matrix in the uncontracted form of the basis and then transforms the SOAD Fock back to the contracted basis, else will compute in contracted basis directly. If the basis is densly contracted, construction of SOAD Fock would be faster with uncontracted form of the basis. </td></tr>
    <tr><td class="paramname">op</td><td>operator to convert ComputeTile to Tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAD Fock matrix in Pauli representation </dd></dl>

</div>
</div>
<a id="ae32765e75d293dd704f0150a4c7a5c43" name="ae32765e75d293dd704f0150a4c7a5c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32765e75d293dd704f0150a4c7a5c43">&#9670;&#160;</a></span>fock_from_soad_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, typename std::enable_if&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt;::type &gt; mpqc::lcao::gaussian::fock_from_soad_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;&#160;</td>
          <td class="paramname"><em>wfn_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a> const &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>minbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cd5ecbd8edb0049e27b109f14f82b94" name="a5cd5ecbd8edb0049e27b109f14f82b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd5ecbd8edb0049e27b109f14f82b94">&#9670;&#160;</a></span>index_to_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; mpqc::lcao::gaussian::index_to_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_registry.html">BasisRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>basis_registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao.html#ad97913bcf53f7be621e417add34acfb5">OrbitalIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given OrbitalIndex, find the corresponding basis </p>

</div>
</div>
<a id="ab47085b65da4b31ada41f7613ae39fa0" name="ab47085b65da4b31ada41f7613ae39fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47085b65da4b31ada41f7613ae39fa0">&#9670;&#160;</a></span>inf_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mpqc::lcao::gaussian::inf_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::Map&lt; const <a class="el" href="namespacempqc.html#af7d62eef9a57009197611dc94bf57393">RowMatrix</a>&lt; T &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5890ea4285e42b4439da58bd637177c7" name="a5890ea4285e42b4439da58bd637177c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5890ea4285e42b4439da58bd637177c7">&#9670;&#160;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mpqc::lcao::gaussian::l2_norm </td>
          <td>(</td>
          <td class="paramtype">Eigen::Map&lt; const <a class="el" href="namespacempqc.html#af7d62eef9a57009197611dc94bf57393">RowMatrix</a>&lt; T &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a213fce77f9c4ddab1712c376a3f4bd2e" name="a213fce77f9c4ddab1712c376a3f4bd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213fce77f9c4ddab1712c376a3f4bd2e">&#9670;&#160;</a></span>make_direct_integral_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile  = Tile, typename Engine  = libint2::Engine&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a>&lt; Tile, ComputeTile, Engine &gt; &gt; mpqc::lcao::gaussian::make_direct_integral_builder </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_epool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>shr_screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make detection of template parameters easier, see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_direct_integral_builder.html">DirectIntegralBuilder</a> for details. </p>

</div>
</div>
<a id="ae5a50ef6535d77e03707e4cd94908460" name="ae5a50ef6535d77e03707e4cd94908460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a50ef6535d77e03707e4cd94908460">&#9670;&#160;</a></span>make_engine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libint2::Engine mpqc::lcao::gaussian::make_engine </td>
          <td>(</td>
          <td class="paramtype">const libint2::Operator &amp;&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libint2::BraKet&#160;</td>
          <td class="paramname"><em>braket</em> = <code>libint2::BraKet::invalid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libint2::any&#160;</td>
          <td class="paramname"><em>oper_params</em> = <code>libint2::any()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deriv_order</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>engine_precision</em> = <code>std::numeric_limits&lt;double&gt;::epsilon()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libint2::scalar_type &amp;&#160;</td>
          <td class="paramname"><em>scalar</em> = <code>libint2::scalar_type(1.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_am</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nprim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>makes an engine for computing integrals of operator <code>oper</code> over bases <code>bases</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oper</td><td>operator type, specified as a libint2::Operator value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bases</td><td>basis set sequence specifying the basis on each center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">braket</td><td>the libint2::BraKet describing the integral braket, e.g. xs_xx, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oper_params</td><td>the operator parameters (e.g. point charges, if <code>oper==nuclear</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriv_order</td><td>the order of geometrical derivatives </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">engine_precision</td><td>target absolute precision of the integrals; integrals smaller than this will likely be neglected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>a factor to scale the integrals by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_am</td><td>the maximum angular momentum of the basis functions, if non-zero will use this value instead of the maximum am of the basis functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_nprim</td><td>the maximum number of primitives in the basis functions, if non-zero will use this value instead of the maximum nprim of the basis functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14bd4904817812737f26c01083e9bd20" name="a14bd4904817812737f26c01083e9bd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bd4904817812737f26c01083e9bd20">&#9670;&#160;</a></span>make_engine_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; libint2::Engine &gt; mpqc::lcao::gaussian::make_engine_pool </td>
          <td>(</td>
          <td class="paramtype">const libint2::Operator &amp;&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libint2::BraKet&#160;</td>
          <td class="paramname"><em>braket</em> = <code>libint2::BraKet::invalid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libint2::any&#160;</td>
          <td class="paramname"><em>oper_params</em> = <code>libint2::any()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libint2::scalar_type &amp;&#160;</td>
          <td class="paramname"><em>scalar</em> = <code>libint2::scalar_type(1.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>engine_precision</em> = <code>std::numeric_limits&lt;double&gt;::epsilon()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22c">mpqc::DerivOrder</a>&#160;</td>
          <td class="paramname"><em>deriv_order</em> = <code><a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22ca334c4a4c42fdb79d7ebc3e73b517e6f8">mpqc::DerivOrder::none</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_am</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nprim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an pool of Engine objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Bases</td><td>a contiguous range of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects or std::reference_wrapper's to (const) <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oper</td><td>the operator type </td></tr>
    <tr><td class="paramname">bases</td><td>an object of Bases type </td></tr>
    <tr><td class="paramname">braket</td><td>the braket type; the default is to use the value returned by <code>libint2::default_braket(oper)</code> </td></tr>
    <tr><td class="paramname">oper_params</td><td>the operator parameters; the default is to use <code>libint2::default_params(oper)</code> </td></tr>
    <tr><td class="paramname">scalar</td><td>integrals will be scaled by this factor; the default value is 1 </td></tr>
    <tr><td class="paramname">engine_precision</td><td>the (absolute) precision target for the Engine </td></tr>
    <tr><td class="paramname">deriv_order</td><td>the order of geometrical derivatives </td></tr>
    <tr><td class="paramname">max_am</td><td>the maximum angular momentum of the basis functions </td></tr>
    <tr><td class="paramname">max_nprim</td><td>the maximum number of primitives in the basis functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::shared_ptr to the Engine pool </dd></dl>

</div>
</div>
<a id="acc6c3711078ce5c9eb6ba242dc52f80d" name="acc6c3711078ce5c9eb6ba242dc52f80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6c3711078ce5c9eb6ba242dc52f80d">&#9670;&#160;</a></span>make_integral_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ComputeTile  = Tile, typename Engine  = libint2::Engine&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html">IntegralBuilder</a>&lt; Tile, ComputeTile, Engine &gt; &gt; mpqc::lcao::gaussian::make_integral_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_epool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a2bc1d22947aef467a30a88973291a9fb">BasisShrVector</a> &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>shr_screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make detection of template parameters easier, see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_integral_builder.html" title="Builds integrals from an array of bases and an integral engine pool.">IntegralBuilder</a> for details. </p>

</div>
</div>
<a id="a2afc904ff353145ce6a469402b97bf08" name="a2afc904ff353145ce6a469402b97bf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afc904ff353145ce6a469402b97bf08">&#9670;&#160;</a></span>make_qqr_screener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html">QQRScreen</a> mpqc::lcao::gaussian::make_qqr_screener </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>gaussian_ao_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5078887f903c12dc8cbbea425d4d44e2" name="a5078887f903c12dc8cbbea425d4d44e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5078887f903c12dc8cbbea425d4d44e2">&#9670;&#160;</a></span>make_qqr_screener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q_q_r_screen.html">QQRScreen</a> mpqc::lcao::gaussian::make_qqr_screener </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>engs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bf31eee268163d90a39cd316c46a724" name="a0bf31eee268163d90a39cd316c46a724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf31eee268163d90a39cd316c46a724">&#9670;&#160;</a></span>make_schwarz_screener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a> mpqc::lcao::gaussian::make_schwarz_screener </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>gaussian_ao_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf1e98d2feb096d950421b339aa5aec9" name="adf1e98d2feb096d950421b339aa5aec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1e98d2feb096d950421b339aa5aec9">&#9670;&#160;</a></span>make_schwarz_screener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html">SchwarzScreen</a> &gt; mpqc::lcao::gaussian::make_schwarz_screener </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp; &gt;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp; &gt;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constructs an l2-based <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html" title="Class for Schwarz based screening.">SchwarzScreen</a> screener for (bra[0]|ket[0] ket[1]) integrals </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bra</td><td>tuple of references to bra bases </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ket</td><td>tuple of references to ket bases </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>screening threshold; see <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ac83201be4668305ddc91a24130bc79bb">SchwarzScreen::SchwarzScreen()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9324b9390c81a5391ad96e05b510118" name="ab9324b9390c81a5391ad96e05b510118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9324b9390c81a5391ad96e05b510118">&#9670;&#160;</a></span>make_screener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt; mpqc::lcao::gaussian::make_screener </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">gaussian::GaussianFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>gaussian_ao_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>screen_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>factory for <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html" title="ThresholdedScreener is a Screener equipped with a (mutable) real threshold.">ThresholdedScreener</a> objects </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Bases</td><td>a directly-addressable sequence of basis sets (or reference proxies, e.g. std::reference_wrapper)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gaussian_ao_factory</td><td>pointer to a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a> object used to keep basis and basis pair data; if null, such data will be computed from scratch</td></tr>
    <tr><td class="paramname">libint2_op</td><td>operator type</td></tr>
    <tr><td class="paramname">bs_array</td><td>is a reference to a directly-addressable sequence of basis sets, if the length is 3 then DF integrals are assumed and the first basis is assumed to be the auxiliary basis if the length is 4 then it is assumed that four center screening is desired. There is no requirement that any basis sets be the same.</td></tr>
    <tr><td class="paramname">screen</td><td>string type of the screener requested; valid values are <code>schwarz</code> (Schwarz screener using the L2 norm), <code>schwarz_inf</code> (Schwarz screener using the infinity norm), <code>qqr</code> (QQR screener using the L2 norm; 4-center only), <code>qqr_inf</code> (QQR screener using the infinity norm; 4-center only) <code>sqvl</code> (SQVl screener using the L2 norm; 3-center only), <code>sqvl_inf</code> (SQVl screener using the infinity norm; 3-center only), <code>default</code> (QQR screener for 4-center ints, SQVl screener for 3-center ints, both L2-based)</td></tr>
    <tr><td class="paramname">screen_threshold</td><td>is the screening threshold</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the screener object </dd></dl>

</div>
</div>
<a id="a2013d56ba5fc3bdba0c329c04d747522" name="a2013d56ba5fc3bdba0c329c04d747522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2013d56ba5fc3bdba0c329c04d747522">&#9670;&#160;</a></span>make_screener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt; mpqc::lcao::gaussian::make_screener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;&#160;</td>
          <td class="paramname"><em>wfn_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>screen_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8175706c202c8102a6b9e063180a7be3" name="a8175706c202c8102a6b9e063180a7be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8175706c202c8102a6b9e063180a7be3">&#9670;&#160;</a></span>make_shell_clusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; libint2::Shell &gt; &gt; mpqc::lcao::gaussian::make_shell_clusters </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; libint2::Shell &gt;&#160;</td>
          <td class="paramname"><em>shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>blocksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clusters a sequence of shell </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shells</td><td>a sequence of shells </td></tr>
    <tr><td class="paramname">blocksize</td><td>target block size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence of shell clusters </dd></dl>

</div>
</div>
<a id="ae70c779c4b9824d32f03c91e2b2f5ad2" name="ae70c779c4b9824d32f03c91e2b2f5ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70c779c4b9824d32f03c91e2b2f5ad2">&#9670;&#160;</a></span>make_sqvl_screener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html">SQVlScreen</a> mpqc::lcao::gaussian::make_sqvl_screener </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_gaussian_factory.html">GaussianFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>gaussian_ao_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb825b90f27472339962f0cb0dbbbbc3" name="acb825b90f27472339962f0cb0dbbbbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb825b90f27472339962f0cb0dbbbbc3">&#9670;&#160;</a></span>make_sqvl_screener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_s_q_vl_screen.html">SQVlScreen</a> mpqc::lcao::gaussian::make_sqvl_screener </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>engs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_schwarz_screen.html#ade5e5f8fead5c0d50697d7908e9fd438">SchwarzScreen::norm_op_type</a>&#160;</td>
          <td class="paramname"><em>norm_func</em> = <code><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1detail.html#a365f944411b5f2c933b9393898b7ae8c">detail::l2_norm</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad982d1881c84975870beeb160db6d049" name="ad982d1881c84975870beeb160db6d049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad982d1881c84975870beeb160db6d049">&#9670;&#160;</a></span>map_W_sap_tensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::map_W_sap_tensors </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>eng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; libint2::Shell, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::int64_t, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::int64_t, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Tile &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps the buffer computed by libint engine into vector of 4 tensors with W{0,x,y,z} tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>libint engine to compute the buffer </td></tr>
    <tr><td class="paramname">Tile</td><td>a (contiguous) tensor type to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dummy</td><td>double var to fill the map. </td></tr>
    <tr><td class="paramname">s0,s1</td><td>libint shells over which the buffer is computed </td></tr>
    <tr><td class="paramname">lb,ub</td><td>lower and upper bounds of the tensor blocks to be mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8523fb921743b6bd1186c9f04c7e536" name="ab8523fb921743b6bd1186c9f04c7e536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8523fb921743b6bd1186c9f04c7e536">&#9670;&#160;</a></span>map_W_tensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::map_W_tensors </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>eng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; libint2::Shell, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::int64_t, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::int64_t, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Tile &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps the buffer computed by libint engine into vector of 4 tensors with W{0,x,y,z} tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>libint engine to compute the buffer </td></tr>
    <tr><td class="paramname">Tile</td><td>a (contiguous) tensor type to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s0,s1</td><td>libint shells over which the buffer is computed </td></tr>
    <tr><td class="paramname">lb,ub</td><td>lower and upper bounds of the tensor blocks to be mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8751eea9571113dc8c6b133e22e1fae8" name="a8751eea9571113dc8c6b133e22e1fae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8751eea9571113dc8c6b133e22e1fae8">&#9670;&#160;</a></span>map_xyz_tensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::map_xyz_tensors </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>eng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; libint2::Shell, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::int64_t, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::int64_t, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Tile &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_xyz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps the buffer computed by libint engine into vector of 3 tensors with dipole moment integrals in order ux, uy, uz. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>libint engine to compute the buffer </td></tr>
    <tr><td class="paramname">Tile</td><td>a (contiguous) tensor type to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s0,s1</td><td>libint shells over which the buffer is computed </td></tr>
    <tr><td class="paramname">lb,ub</td><td>lower and upper bounds of the tensor blocks to be mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d9799486007f292ac8c597553dce604" name="a4d9799486007f292ac8c597553dce604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9799486007f292ac8c597553dce604">&#9670;&#160;</a></span>max_am() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::lcao::gaussian::max_am </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;&#160;</td>
          <td class="paramname"><em>shell_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum angular momentum of any shell in the vector. </p>

</div>
</div>
<a id="a87356cfd768c7a7e880cfccbaff41af0" name="a87356cfd768c7a7e880cfccbaff41af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87356cfd768c7a7e880cfccbaff41af0">&#9670;&#160;</a></span>max_am() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::lcao::gaussian::max_am </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum angular momentum of any shell in the cluster of shells. </p>

</div>
</div>
<a id="ae463540711e7a5718ff6f313ac0d84fb" name="ae463540711e7a5718ff6f313ac0d84fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae463540711e7a5718ff6f313ac0d84fb">&#9670;&#160;</a></span>max_nprim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::lcao::gaussian::max_nprim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;&#160;</td>
          <td class="paramname"><em>shell_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of primitives of any shell in the vector. </p>

</div>
</div>
<a id="a14199c8577534e8be792a7103a124036" name="a14199c8577534e8be792a7103a124036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14199c8577534e8be792a7103a124036">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &gt; mpqc::lcao::gaussian::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>nclusters_target</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>merges two <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> objects by such that shells on the same atom are contiguous; the resulting (deduplicated) shell sequence is reclustered </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basis1</td><td>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basis2</td><td>another <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nclusters_target</td><td>the target number of clusters; by default will use <code>max(basis1.nclusters(),basis2.nclusters())</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a union <code>basis1</code> and <code>basis2</code> </dd></dl>

</div>
</div>
<a id="a16939087b32cef6ba81b605fb0ee7657" name="a16939087b32cef6ba81b605fb0ee7657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16939087b32cef6ba81b605fb0ee7657">&#9670;&#160;</a></span>min_ao_occupation_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShellIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; mpqc::lcao::gaussian::min_ao_occupation_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShellIterator&#160;</td>
          <td class="paramname"><em>shell_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShellIterator&#160;</td>
          <td class="paramname"><em>shell_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>Q</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes average orbital occupancies in ground-state atom/ion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>the atomic number </td></tr>
    <tr><td class="paramname">Q</td><td>the net charge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>occupation vector corresponding to the ground state electronic configuration of an atom/ion with atomic number <code>Z</code> and net charge <code>Q</code> corresponding to the canonical orbital ordering in the minimal basis </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Z &lt;= 110 </dd></dl>
<p>adds a subshell of size <code>size</code> created by smearing no more than <code>ne</code> electrons (corresponds to spherical averaging) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size of the subshell </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ne</td><td>the number of electrons, on return contains the number of "remaining" electrons</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cc401f93b3cf3989932e8749bd51eee" name="a0cc401f93b3cf3989932e8749bd51eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc401f93b3cf3989932e8749bd51eee">&#9670;&#160;</a></span>nfunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::lcao::gaussian::nfunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> const &amp;&#160;</td>
          <td class="paramname"><em>shell_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of primitives of any shell in the vector. </p>

</div>
</div>
<a id="ac14daf97f21a6466f9985c84b21333b6" name="ac14daf97f21a6466f9985c84b21333b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14daf97f21a6466f9985c84b21333b6">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; mpqc::lcao::gaussian::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_atomic_basis.html">AtomicBasis</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct a map that maps column of basis to column of sub_basis, sub_basis has to be a subset of basis </p><dl class="section warning"><dt>Warning</dt><dd>the value in index starts with 1, value 0 in index indicates this column is missing in sub_basis This approach uses N^2 algorithm //TODO need unit test for this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </td></tr>
    <tr><td class="paramname">sub_basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object, subset of basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of column id of sub_basis </dd></dl>

</div>
</div>
<a id="ab8e9e89bdcfc1878433bdaf57f037006" name="ab8e9e89bdcfc1878433bdaf57f037006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e9e89bdcfc1878433bdaf57f037006">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; mpqc::lcao::gaussian::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct a map that maps column of basis to column of sub_basis, sub_basis has to be a subset of basis </p><dl class="section warning"><dt>Warning</dt><dd>the value in index starts with 1, value 0 in index indicates this column is missing in sub_basis This approach uses N^2 algorithm //TODO need unit test for this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </td></tr>
    <tr><td class="paramname">sub_basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object, subset of basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of column id of sub_basis </dd></dl>

</div>
</div>
<a id="a5bd9c684fc72526ba39a59078b49c1ac" name="a5bd9c684fc72526ba39a59078b49c1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd9c684fc72526ba39a59078b49c1ac">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; mpqc::lcao::gaussian::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html">Basis::Factory</a> const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct a map that maps column of basis to column of sub_basis, sub_basis has to be a subset of basis </p><dl class="section warning"><dt>Warning</dt><dd>the value in index starts with 1, value 0 in index indicates this column is missing in sub_basis This approach uses N^2 algorithm //TODO need unit test for this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </td></tr>
    <tr><td class="paramname">sub_basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object, subset of basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of column id of sub_basis </dd></dl>

</div>
</div>
<a id="a755d72248fbad1639c6a94f42bf123a1" name="a755d72248fbad1639c6a94f42bf123a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755d72248fbad1639c6a94f42bf123a1">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpqc::lcao::gaussian::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>two</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes matrix transforming <code>primitive_basis</code> to <code>contracted_basis</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uncontracted_basis</td><td>a primitive vesion of <code>contracted_basis</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contracted_basis</td><td>a contracted basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix transforming primitive AOs to contracted AOs </dd></dl>

</div>
</div>
<a id="affa037266c1937ea7d9b1d7cb4441245" name="affa037266c1937ea7d9b1d7cb4441245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa037266c1937ea7d9b1d7cb4441245">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpqc::lcao::gaussian::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html">Q2Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html" title="Class which holds shell set information for screening.">Q2Matrix</a> objects. This does not handle transposes, i.e. it returns false if <code>first</code> is a transpose of <code>second</code> .</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html" title="Class which holds shell set information for screening.">Q2Matrix</a> object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_q2_matrix.html" title="Class which holds shell set information for screening.">Q2Matrix</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>first</code> refers to the same bases and <code>second</code> and uses same operator type and norm op </dd></dl>

</div>
</div>
<a id="aace25fc31194c5c92a23c5faf3a5bdc7" name="aace25fc31194c5c92a23c5faf3a5bdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace25fc31194c5c92a23c5faf3a5bdc7">&#9670;&#160;</a></span>parallel_compute_shellpair_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; size_t &gt; &gt; mpqc::lcao::gaussian::parallel_compute_shellpair_list </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>engine_precision</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This computes non-negligible shell pair list; shells <code>i</code> and <code>j</code> form a non-negligible pair if they share a center or the Frobenius norm of their overlap is greater than threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis1</td><td>a basis </td></tr>
    <tr><td class="paramname">basis2</td><td>a basis </td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of pairs with key: shell index mapped value: a vector of shell indices </dd></dl>

</div>
</div>
<a id="a0d921175ffc2f59e28f7322f23c1441e" name="a0d921175ffc2f59e28f7322f23c1441e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d921175ffc2f59e28f7322f23c1441e">&#9670;&#160;</a></span>parallel_make_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> mpqc::lcao::gaussian::parallel_make_basis </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html">Basis::Factory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_molecule.html">mpqc::Molecule</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> from a factory and a <a class="el" href="classmpqc_1_1_molecule.html" title="Molecule is a class which contains a vector of AtomBasedClusterables.">Molecule</a> on process 0 and broadcast to the entire world </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>the madness::World </td></tr>
    <tr><td class="paramname">factory</td><td>the <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis_1_1_factory.html" title="Factory is a ctor helper.">Basis::Factory</a> object </td></tr>
    <tr><td class="paramname">mol</td><td>the <a class="el" href="classmpqc_1_1_molecule.html" title="Molecule is a class which contains a vector of AtomBasedClusterables.">Molecule</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmpqc_1_1_uncomputable.html">Uncomputable</a></td><td>if Libint does not include this basis or it is not supported for one or more atoms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7eab76800c2eb2a8c34db5346ffefcf" name="ab7eab76800c2eb2a8c34db5346ffefcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7eab76800c2eb2a8c34db5346ffefcf">&#9670;&#160;</a></span>print_in_gaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::print_in_gaussian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dump cluster in gaussian format </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusters</td><td>a sequence of shell clusters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b7233f3f1617b95869c9c07d78111c" name="a36b7233f3f1617b95869c9c07d78111c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b7233f3f1617b95869c9c07d78111c">&#9670;&#160;</a></span>recenter_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; libint2::Shell &gt; mpqc::lcao::gaussian::recenter_cluster </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recenter cluster to a new center </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>a sequence of shell clusters </td></tr>
    <tr><td class="paramname">center</td><td>new center </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of shell clusters recentered to the new center </dd></dl>

</div>
</div>
<a id="a31ca7c1d50c5fee6a5c40601433e2794" name="a31ca7c1d50c5fee6a5c40601433e2794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ca7c1d50c5fee6a5c40601433e2794">&#9670;&#160;</a></span>recenter_shells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; libint2::Shell &gt; mpqc::lcao::gaussian::recenter_shells </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; libint2::Shell &gt; &amp;&#160;</td>
          <td class="paramname"><em>shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recenter shells to a new center </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shells</td><td>a sequence of shells </td></tr>
    <tr><td class="paramname">center</td><td>new center </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of shells recentered to the new center </dd></dl>

</div>
</div>
<a id="a9a7e99c5fa82162344fae7040cbc8e1f" name="a9a7e99c5fa82162344fae7040cbc8e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7e99c5fa82162344fae7040cbc8e1f">&#9670;&#160;</a></span>retile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> mpqc::lcao::gaussian::retile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retiles a basis preserving shell structure </p>
<dl class="section warning"><dt>Warning</dt><dd>When retiling a basis with the intent to use it with tensors computed with the old basis you must be careful not to reorder the shells.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>should be a function that takes a std::vector&lt;Shell&gt; and returns a std::vector&lt;std::vector&lt;Shell&gt;&gt; for use in initializing a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7181d4196807e3d4e075141e6ec47f5" name="af7181d4196807e3d4e075141e6ec47f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7181d4196807e3d4e075141e6ec47f5">&#9670;&#160;</a></span>soad_density_eig_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a> mpqc::lcao::gaussian::soad_density_eig_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> const &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> const &amp;&#160;</td>
          <td class="paramname"><em>minbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>atomic_net_charges</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae24f4ec89de556dfce536b5a9088cd60" name="ae24f4ec89de556dfce536b5a9088cd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24f4ec89de556dfce536b5a9088cd60">&#9670;&#160;</a></span>soad_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engs , typename Tile , typename ComputeTile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::soad_task </td>
          <td>(</td>
          <td class="paramtype">Engs&#160;</td>
          <td class="paramname"><em>eng_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int64_t, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; libint2::Shell &gt; const *, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obs_row_and_col_ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; libint2::Shell &gt; const *&#160;</td>
          <td class="paramname"><em>min_bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#a582eb590cd34f97119116067abb18c3e">RowMatrixXd</a> *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA::DistArray&lt; Tile, Policy &gt; *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>, 3 &gt; *&#160;</td>
          <td class="paramname"><em>shellpair_data_accessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_thresholded_screener.html">ThresholdedScreener</a> &gt;, 2 &gt; *&#160;</td>
          <td class="paramname"><em>jk_screeners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5441f5d04156be1aa94e292b925c8c6f" name="a5441f5d04156be1aa94e292b925c8c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5441f5d04156be1aa94e292b925c8c6f">&#9670;&#160;</a></span>sparse_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::sparse_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct sparse integral tensors in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralTSPool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes Tile&amp;&amp; and returns an type. Op is copied so it can be moved. <div class="fragment"><div class="line"><span class="keyword">auto</span> t = [](TA::TensorD &amp;&amp;ten){<span class="keywordflow">return</span> std::move(ten);};</div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">screen</td><td>a std::shared_ptr to a <a class="el" href="classmpqc_1_1lcao_1_1_screener.html" title="Base class for screeners will never skip any integrals.">Screener</a>. </td></tr>
    <tr><td class="paramname">make_shellpair_data_accessor</td><td>a functor that makes shellpair data accessors; such accessors are to accept basis function indices, rather than shell indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f8c813a8f68db9917b8a79702570140" name="a4f8c813a8f68db9917b8a79702570140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8c813a8f68db9917b8a79702570140">&#9670;&#160;</a></span>sparse_multi_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases , typename Mapper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::sparse_multi_integrals </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapper &amp;&#160;</td>
          <td class="paramname"><em>map_tensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct set of sparse multi tensor integrals in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>libint engine to compute the buffer. </td></tr>
    <tr><td class="paramname">Tile</td><td>a (contiguous) tensor type to store the result. </td></tr>
    <tr><td class="paramname">Mapper</td><td>a mapper function to map engine buffer to different tensors </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_ints</td><td>number of integral tensors </td></tr>
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralTSPool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">map_tensors</td><td>a void function to map the buffer into individual tensors </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes a TA::TensorD &amp;&amp; and returns any valid tile type. Op is copied so it can be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc375d8dc0a5b7cc60bff91945056192" name="adc375d8dc0a5b7cc60bff91945056192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc375d8dc0a5b7cc60bff91945056192">&#9670;&#160;</a></span>sparse_multi_integrals3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases , typename Mapper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::sparse_multi_integrals3 </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_ints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapper &amp;&#160;</td>
          <td class="paramname"><em>map_tensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct set of sparse multi tensor 3-center integrals in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>libint engine to compute the buffer. </td></tr>
    <tr><td class="paramname">Tile</td><td>a (contiguous) tensor type to store the result. </td></tr>
    <tr><td class="paramname">Mapper</td><td>a mapper function to map engine buffer to different tensors </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_ints</td><td>number of integral tensors </td></tr>
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralTSPool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">map_tensors</td><td>a void function to map the buffer into individual tensors </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes a TA::TensorD &amp;&amp; and returns any valid tile type. Op is copied so it can be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6132b68519a0b7c8886d78449580fafa" name="a6132b68519a0b7c8886d78449580fafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6132b68519a0b7c8886d78449580fafa">&#9670;&#160;</a></span>sparse_W_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::sparse_W_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45d959b5f2c3c6892567bdf1e4b0744c" name="a45d959b5f2c3c6892567bdf1e4b0744c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d959b5f2c3c6892567bdf1e4b0744c">&#9670;&#160;</a></span>sparse_W_sap_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::sparse_W_sap_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a073a15bb99fd8c89824f911daeea65" name="a7a073a15bb99fd8c89824f911daeea65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a073a15bb99fd8c89824f911daeea65">&#9670;&#160;</a></span>sparse_xyz_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename Tile  = TA::TensorD, typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, TA::SparsePolicy &gt; mpqc::lcao::gaussian::sparse_xyz_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct set of sparse integral tensors in parallel. </p>
<p>This is needed for integrals such as the dipole integrals that come as a set.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tile</td><td>a (contiguous) tensor type to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralTSPool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes a TA::TensorD &amp;&amp; and returns any valid tile type. Op is copied so it can be moved. <div class="fragment"><div class="line"><span class="keyword">auto</span> t = [](TA::TensorD &amp;&amp;ten){<span class="keywordflow">return</span> std::move(ten);};</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c702195651def7f9156e01a8b429f3b" name="a0c702195651def7f9156e01a8b429f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c702195651def7f9156e01a8b429f3b">&#9670;&#160;</a></span>split_by_am()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; mpqc::lcao::gaussian::split_by_am </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#ae867b676d97f85013d7c64e693923168">ShellVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split clusters into angular momentum blocks </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusters</td><td>a sequence of shell clusters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of shell clusters, each containing shells of the same angular momentum </dd></dl>

</div>
</div>
<a id="a3d324854ba6f208cda3f9bdce132d412" name="a3d324854ba6f208cda3f9bdce132d412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d324854ba6f208cda3f9bdce132d412">&#9670;&#160;</a></span>sub_basis_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::RowVectorXi mpqc::lcao::gaussian::sub_basis_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct a map that maps column of basis to column of sub_basis, sub_basis has to be a subset of basis </p><dl class="section warning"><dt>Warning</dt><dd>the value in index starts with 1, value 0 in index indicates this column is missing in sub_basis This approach uses N^2 algorithm //TODO need unit test for this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object </td></tr>
    <tr><td class="paramname">sub_basis</td><td><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> object, subset of basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of column id of sub_basis </dd></dl>

</div>
</div>
<a id="a1b9b7c4f2213466b2cac67291bc97e29" name="a1b9b7c4f2213466b2cac67291bc97e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9b7c4f2213466b2cac67291bc97e29">&#9670;&#160;</a></span>tensorZ_to_tensorD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Policy , bool is_real = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArray&lt; TA::TensorD, Policy &gt; mpqc::lcao::gaussian::tensorZ_to_tensorD </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; TA::TensorZ, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>complex_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes real or imaginary part from a complex array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>can be TA::SparsePolicy or TA::DensePolicy </td></tr>
    <tr><td class="paramname">Is_real</td><td>true if user requests real part, false if imaginary </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>TensorZ array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a TensorD array </dd></dl>

</div>
</div>
<a id="af9b8c088e51da32c6410c2aa431bd817" name="af9b8c088e51da32c6410c2aa431bd817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b8c088e51da32c6410c2aa431bd817">&#9670;&#160;</a></span>to_ao_factory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt; Tile, Policy &gt; &gt; mpqc::lcao::gaussian::to_ao_factory </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_a_o_factory.html">lcao::AOFactory</a>&lt; Tile, Policy &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdcd976886feaeb7d161824c36ecbb5a" name="abdcd976886feaeb7d161824c36ecbb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcd976886feaeb7d161824c36ecbb5a">&#9670;&#160;</a></span>to_ao_factory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_a_o_factory.html">AOFactory</a>&lt; Tile, Policy &gt; &amp; mpqc::lcao::gaussian::to_ao_factory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1lcao_1_1_a_o_factory.html">lcao::AOFactory</a>&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aade0cff827d164f6eb0aeb54b8129299" name="aade0cff827d164f6eb0aeb54b8129299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade0cff827d164f6eb0aeb54b8129299">&#9670;&#160;</a></span>to_libint2_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libint2::Operator mpqc::lcao::gaussian::to_libint2_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_oper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07cc61b0f4ad28acd3040acd3d471c7e" name="a07cc61b0f4ad28acd3040acd3d471c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cc61b0f4ad28acd3040acd3d471c7e">&#9670;&#160;</a></span>to_libint2_operator_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libint2::any mpqc::lcao::gaussian::to_libint2_operator_params </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_molecule.html">Molecule</a> &amp;&#160;</td>
          <td class="paramname"><em>molecule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>, libint2::any &gt; *&#160;</td>
          <td class="paramname"><em>oper_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipole_origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07479e80d39fec6897ee99c6f59e6667" name="a07479e80d39fec6897ee99c6f59e6667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07479e80d39fec6897ee99c6f59e6667">&#9670;&#160;</a></span>to_libint2_scale_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libint2::scalar_type mpqc::lcao::gaussian::to_libint2_scale_factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td>
          <td class="paramname"><em>mpqc_oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>, libint2::any &gt; *&#160;</td>
          <td class="paramname"><em>oper_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92beac907f517f3e088b5d1064a132cf" name="a92beac907f517f3e088b5d1064a132cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92beac907f517f3e088b5d1064a132cf">&#9670;&#160;</a></span>to_molden() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrbSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::to_molden </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>fname_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrbSpace &amp;&#160;</td>
          <td class="paramname"><em>orbspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;&#160;</td>
          <td class="paramname"><em>wfn_world</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints an orbital space to a Molden file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OrbSpace</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orbspace</td><td></td></tr>
    <tr><td class="paramname">wfn_world</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8e29bfd654bb561f89ad695f648a7c6" name="ad8e29bfd654bb561f89ad695f648a7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e29bfd654bb561f89ad695f648a7c6">&#9670;&#160;</a></span>to_molden() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OrbSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::lcao::gaussian::to_molden </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>fname_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const OrbSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>orbspace_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1_wavefunction_world.html">WavefunctionWorld</a> &amp;&#160;</td>
          <td class="paramname"><em>wfn_world</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints an orbital space to a Molden file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OrbSpace</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orbspace_ptr</td><td></td></tr>
    <tr><td class="paramname">wfn_world</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa553b885e80e63bf7bd89bda96a8038a" name="aa553b885e80e63bf7bd89bda96a8038a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa553b885e80e63bf7bd89bda96a8038a">&#9670;&#160;</a></span>uncontract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> mpqc::lcao::gaussian::uncontract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> &amp;&#160;</td>
          <td class="paramname"><em>basis1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>uncontracts individual shells in shell cluster (the structure of the cluster remains unchanged) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basis1</td><td>a <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> clustered shell (uses clustered shells by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an uncontracted version of <code><a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a></code> </dd></dl>

</div>
</div>
<a id="a813d472178204ffe2463c580159ee36c" name="a813d472178204ffe2463c580159ee36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813d472178204ffe2463c580159ee36c">&#9670;&#160;</a></span>untruncated_direct_sparse_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile  = TA::TensorD, typename ComputeTile  = Tile, typename Engine , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, TA::SparsePolicy, Engine &gt; mpqc::lcao::gaussian::untruncated_direct_sparse_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; Engine &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a> &gt;&#160;</td>
          <td class="paramname"><em>screen</em> = <code>std::make_shared&lt;<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>&gt;(<a class="el" href="classmpqc_1_1lcao_1_1_screener.html">Screener</a>{})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(ComputeTile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;ComputeTile,&#160;true&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacempqc_1_1lcao_1_1gaussian.html#a45f3517e0399a3e6a4966e7a1e6df29a">shellpair_data_accessor_t</a>(const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *, const <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a> *)&gt;&#160;</td>
          <td class="paramname"><em>make_shellpair_data_accessor</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const math::PetiteList &gt;&#160;</td>
          <td class="paramname"><em>plist</em> = <code><a class="el" href="classmpqc_1_1math_1_1_petite_list.html#a4610f62d3211547339fc74f219ff04b2">math::PetiteList::make_trivial</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct direct integral tensors in parallel with screening. </p>
<p>Same requirements on Op as those in Integral Builder.</p>
<p>I only plan to use this for CADF, no point in truncating tiles. </p>

</div>
</div>
<a id="a9d084b43e954e9dca1a628afccbdbd17" name="a9d084b43e954e9dca1a628afccbdbd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d084b43e954e9dca1a628afccbdbd17">&#9670;&#160;</a></span>W_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt; &gt; mpqc::lcao::gaussian::W_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct set of sparse W {0,x,y,z} integral tensors in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tile</td><td>a (contiguous) tensor type to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shr_pool</td><td>should be a std::shared_ptr to an IntegralTSPool </td></tr>
    <tr><td class="paramname">bases</td><td>should be a std::array of <a class="el" href="classmpqc_1_1lcao_1_1gaussian_1_1_basis.html">Basis</a>, which will be copied. </td></tr>
    <tr><td class="paramname">op</td><td>needs to be a function or functor that takes a TA::TensorD &amp;&amp; and </td></tr>
    <tr><td class="paramname">atoms</td><td>vector of atoms. returns any valid tile type. Op is copied so it can be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dc21d1f2d7c377113965e26bb19135a" name="a3dc21d1f2d7c377113965e26bb19135a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc21d1f2d7c377113965e26bb19135a">&#9670;&#160;</a></span>W_sap_integrals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt; &gt; mpqc::lcao::gaussian::W_sap_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72fe9cad4a734ee3dc01ac1bab2ebca5" name="a72fe9cad4a734ee3dc01ac1bab2ebca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fe9cad4a734ee3dc01ac1bab2ebca5">&#9670;&#160;</a></span>xyz_integrals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::DensePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::DensePolicy &gt; &gt; mpqc::lcao::gaussian::xyz_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae23765e93d3338e61943c6f6189e76d9" name="ae23765e93d3338e61943c6f6189e76d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23765e93d3338e61943c6f6189e76d9">&#9670;&#160;</a></span>xyz_integrals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename E , typename Bases &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DistArrayVector&lt; Tile, std::enable_if_t&lt; std::is_same&lt; Policy, TA::SparsePolicy &gt;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">::value</a>, TA::SparsePolicy &gt; &gt; mpqc::lcao::gaussian::xyz_integrals </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc_1_1lcao_1_1gaussian_1_1utility.html#a051e5b4d60cbe779182d6a9502a1f1c3">ShrPool</a>&lt; E &gt;&#160;</td>
          <td class="paramname"><em>shr_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bases &amp;&amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Tile(Tile &amp;&amp;)&gt;&#160;</td>
          <td class="paramname"><em>op</em> = <code>TA::detail::Noop&lt;Tile,&#160;Tile,&#160;true&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 13 2025 23:43:47 for MPQC-Docs by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
