<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC-Docs: mpqc::detail Namespace Reference</title>
<!--BEGIN PROJECT_ICON-->
<link rel="icon" href="$projecticon" type="image/x-icon" />
<!--END PROJECT_ICON-->
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--BEGIN COPY_CLIPBOARD-->
<script type="text/javascript" src="clipboard.js"></script>
<!--END COPY_CLIPBOARD-->
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init();
        DoxygenAwesomeParagraphLink.init();
    </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"$logosize/></td>
  <td id="projectalign">
   <div id="projectname">MPQC-Docs<span id="projectnumber">&#160;4.0.0-beta.1</span>
   </div>
   <div id="projectbrief">Massively Parallel Electronic Structure platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempqc.html">mpqc</a></li><li class="navelem"><a class="el" href="namespacempqc_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">mpqc::detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacempqc_1_1detail_1_1simplification" id="r_namespacempqc_1_1detail_1_1simplification"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail_1_1simplification.html">simplification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1_abs_max_compare.html">AbsMaxCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_abs_max_n_index_reduction.html">AbsMaxNIndexReduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_abs_max_n_reduction.html">AbsMaxNReduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1_abs_max_pair_compare.html">AbsMaxPairCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1append__count.html">append_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms strings by appending string representation of an integral counter  <a href="structmpqc_1_1detail_1_1append__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_backtrace.html">Backtrace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1empty.html">empty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_force_link.html">ForceLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This, together with <a class="el" href="classmpqc_1_1detail_1_1_force_link_base.html">ForceLinkBase</a>, is used to force code for particular classes to be linked into executables.  <a href="classmpqc_1_1detail_1_1_force_link.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_force_link_base.html">ForceLinkBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1_fundamental_constants.html">FundamentalConstants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1has__provider.html">has_provider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmpqc_1_1detail_1_1has__provider.html#abe183dc6e9c873615e5bd9bb5943db85">has_provider&lt;T&gt;::value</a> is true if T::Provider is a valid type  <a href="structmpqc_1_1detail_1_1has__provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides identity transform for strings  <a href="structmpqc_1_1detail_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1init__list__ctor.html">init_list_ctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to help <code>make_shared_from_list</code> work  <a href="structmpqc_1_1detail_1_1init__list__ctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1init__list__ctor_3_01_molecule_01_4.html">init_list_ctor&lt; Molecule &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1is__const__iterator__range.html">is_const_iterator_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_const_iterator_range&lt; T, std::conditional_t&lt; false, is_const_iterator_range_helper&lt; decltype(cbegin(std::declval&lt; const T &amp; &gt;())), decltype(cend(std::declval&lt; const T &amp; &gt;()))&gt;, void &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1is__const__iterator__range__helper.html">is_const_iterator_range_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_max_n_index_reduction.html">MaxNIndexReduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_max_n_reduction.html">MaxNReduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1_max_pair_compare.html">MaxPairCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1_pair_approx_unique.html">PairApproxUnique</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1register__keyval__ctor.html">register_keyval_ctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1scalar__type.html">scalar_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1scalar__type_3_01double_01_4.html">scalar_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1scalar__type_3_01float_01_4.html">scalar_type&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>scalar_type&lt; std::complex&lt; T &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpqc_1_1detail_1_1_shape_tracker.html">ShapeTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1_sub_tree_key_val.html">SubTreeKeyVal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1uccf12.html">uccf12</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CT-F12 implementation.  <a href="classmpqc_1_1detail_1_1uccf12.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpqc_1_1detail_1_1virt__base__of__enable__shared__from__this.html">virt_base_of_enable_shared_from_this</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for <a class="el" href="classmpqc_1_1enable__shared__from__this.html" title="just like std::enable_shared_from_this but can appear multiple times in the subhierarchy of a class">mpqc::enable_shared_from_this</a>  <a href="classmpqc_1_1detail_1_1virt__base__of__enable__shared__from__this.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0ea13c010f2296c08621dfe18a417590" id="r_a0ea13c010f2296c08621dfe18a417590"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a0ea13c010f2296c08621dfe18a417590">MatrixI</a> = Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a0ea13c010f2296c08621dfe18a417590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9f8a0e2f3fe0a37075e57a90787235" id="r_a4e9f8a0e2f3fe0a37075e57a90787235"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e9f8a0e2f3fe0a37075e57a90787235"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a4e9f8a0e2f3fe0a37075e57a90787235">scalar_t</a> = typename <a class="el" href="structmpqc_1_1detail_1_1scalar__type.html">scalar_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a4e9f8a0e2f3fe0a37075e57a90787235"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a72f968a9608405ce7b677e29f263de76" id="r_a72f968a9608405ce7b677e29f263de76"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a72f968a9608405ce7b677e29f263de76">Z_to_element</a> (int64_t Z)</td></tr>
<tr class="separator:a72f968a9608405ce7b677e29f263de76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef672ed271ecfc7633770a6b1fb19671" id="r_aef672ed271ecfc7633770a6b1fb19671"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#aef672ed271ecfc7633770a6b1fb19671">element_to_Z</a> (const std::string &amp;symbol)</td></tr>
<tr class="separator:aef672ed271ecfc7633770a6b1fb19671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fba0711c99df332fe1f9337cccb0bdf" id="r_a1fba0711c99df332fe1f9337cccb0bdf"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a1fba0711c99df332fe1f9337cccb0bdf">direct_ord_idx</a> (<a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;in_3D_idx, <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;lattice_max)</td></tr>
<tr class="memdesc:a1fba0711c99df332fe1f9337cccb0bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes the 3D index of a direct lattice and returns the corresponding ordinal index.  <br /></td></tr>
<tr class="separator:a1fba0711c99df332fe1f9337cccb0bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8988b69b3ae503d02a9917a2e02de9d" id="r_ab8988b69b3ae503d02a9917a2e02de9d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ab8988b69b3ae503d02a9917a2e02de9d">direct_ord_idx</a> (int64_t x, int64_t y, int64_t z, <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;lattice_max)</td></tr>
<tr class="memdesc:ab8988b69b3ae503d02a9917a2e02de9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes the 3D index of a direct lattice and returns the corresponding ordinal index.  <br /></td></tr>
<tr class="separator:ab8988b69b3ae503d02a9917a2e02de9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbee4ec1039edd4f6d45f31ed1b6896b" id="r_afbee4ec1039edd4f6d45f31ed1b6896b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#afbee4ec1039edd4f6d45f31ed1b6896b">k_ord_idx</a> (<a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;in_3D_idx, <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;nk)</td></tr>
<tr class="memdesc:afbee4ec1039edd4f6d45f31ed1b6896b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes the 3D index of a reciprocal lattice and returns the corresponding ordinal index.  <br /></td></tr>
<tr class="separator:afbee4ec1039edd4f6d45f31ed1b6896b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2395220a181df2b8dc9c4461b3dc5b10" id="r_a2395220a181df2b8dc9c4461b3dc5b10"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a2395220a181df2b8dc9c4461b3dc5b10">k_ord_idx</a> (int64_t x, int64_t y, int64_t z, <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;nk)</td></tr>
<tr class="memdesc:a2395220a181df2b8dc9c4461b3dc5b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes the 3D index of a reciprocal lattice and returns the corresponding ordinal index.  <br /></td></tr>
<tr class="separator:a2395220a181df2b8dc9c4461b3dc5b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffe47dbffa7af0e555570defb8f7b80" id="r_a4ffe47dbffa7af0e555570defb8f7b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a4ffe47dbffa7af0e555570defb8f7b80">direct_3D_idx</a> (const int64_t ord_idx, <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;lattice_max)</td></tr>
<tr class="memdesc:a4ffe47dbffa7af0e555570defb8f7b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes the ordinal index of a direct lattice and returns the corresponding 3D index.  <br /></td></tr>
<tr class="separator:a4ffe47dbffa7af0e555570defb8f7b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c857a9c5346c8ca2cecf75cda809e28" id="r_a8c857a9c5346c8ca2cecf75cda809e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a8c857a9c5346c8ca2cecf75cda809e28">k_3D_idx</a> (const int64_t ord_idx, <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;nk)</td></tr>
<tr class="memdesc:a8c857a9c5346c8ca2cecf75cda809e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes the ordinal index of a reciprocal lattice and returns the corresponding 3D index.  <br /></td></tr>
<tr class="separator:a8c857a9c5346c8ca2cecf75cda809e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0de6584716c1d038d7d49e15e408b49" id="r_ac0de6584716c1d038d7d49e15e408b49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ac0de6584716c1d038d7d49e15e408b49">is_in_lattice_range</a> (<a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;in_idx, <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;range, <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;<a class="el" href="namespacempqc.html#aac225015bfae4758bdeda59f8d458bf2">center</a>)</td></tr>
<tr class="memdesc:ac0de6584716c1d038d7d49e15e408b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This determines if a unit cell is included by the give lattice range.  <br /></td></tr>
<tr class="separator:ac0de6584716c1d038d7d49e15e408b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afc3c0d861e8c5ebc7309f1ee650a8e" id="r_a4afc3c0d861e8c5ebc7309f1ee650a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a4afc3c0d861e8c5ebc7309f1ee650a8e">lattice_vector</a> (<a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;n, const <a class="el" href="classmpqc_1_1_unit_cell.html">UnitCell</a> &amp;unitcell)</td></tr>
<tr class="memdesc:a4afc3c0d861e8c5ebc7309f1ee650a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts a point in a lattice and returns its coordinates in the lab frame.  <br /></td></tr>
<tr class="separator:a4afc3c0d861e8c5ebc7309f1ee650a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cffa8cd22ea82d3547dd9d526434b5f" id="r_a0cffa8cd22ea82d3547dd9d526434b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a0cffa8cd22ea82d3547dd9d526434b5f">lattice_vector</a> (<a class="el" href="structmpqc_1_1_supercell_1_1_point.html">Supercell::Point</a> const &amp;pt, const <a class="el" href="classmpqc_1_1_unit_cell.html">UnitCell</a> &amp;unitcell)</td></tr>
<tr class="memdesc:a0cffa8cd22ea82d3547dd9d526434b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts a point in a lattice and returns its coordinates in the lab frame.  <br /></td></tr>
<tr class="separator:a0cffa8cd22ea82d3547dd9d526434b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b72430d0094c9ae2ecca805e33ac8b9" id="r_a7b72430d0094c9ae2ecca805e33ac8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a7b72430d0094c9ae2ecca805e33ac8b9">lattice_vector</a> (<a class="el" href="classmpqc_1_1_supercell.html#a9bccb59bc01a8d97f9c24910331c6dd6">Supercell::const_iterator</a> const &amp;supercell_iterator, const <a class="el" href="classmpqc_1_1_unit_cell.html">UnitCell</a> &amp;unitcell)</td></tr>
<tr class="memdesc:a7b72430d0094c9ae2ecca805e33ac8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts a point in a supercell of a lattice and returns its coordinates in the lab frame.  <br /></td></tr>
<tr class="separator:a7b72430d0094c9ae2ecca805e33ac8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68924c26ea0f7cdec4e471ac235a963b" id="r_a68924c26ea0f7cdec4e471ac235a963b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a68924c26ea0f7cdec4e471ac235a963b">lattice_ndim</a> (const <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> &amp;lattice_range)</td></tr>
<tr class="separator:a68924c26ea0f7cdec4e471ac235a963b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25913ae2726538e61ef53f560085d05" id="r_ae25913ae2726538e61ef53f560085d05"><td class="memTemplParams" colspan="2">template&lt;typename ABCRange &gt; </td></tr>
<tr class="memitem:ae25913ae2726538e61ef53f560085d05"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; std::remove_reference_t&lt; ABCRange &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ae25913ae2726538e61ef53f560085d05">shift_atom_based_clusterables</a> (ABCRange &amp;&amp;range_of_atom_based_clusterables, <a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> const &amp;shift)</td></tr>
<tr class="memdesc:ae25913ae2726538e61ef53f560085d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This shifts the position of range of atom-based clusterables.  <br /></td></tr>
<tr class="separator:ae25913ae2726538e61ef53f560085d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab61675d0cd92235983ac2cbaa1d68e9" id="r_aab61675d0cd92235983ac2cbaa1d68e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#aab61675d0cd92235983ac2cbaa1d68e9">swap</a> (<a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;formula)</td></tr>
<tr class="memdesc:aab61675d0cd92235983ac2cbaa1d68e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap bra with ket  <br /></td></tr>
<tr class="separator:aab61675d0cd92235983ac2cbaa1d68e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e054ace4f07d5c99ead4fb29bf4bd3" id="r_a87e054ace4f07d5c99ead4fb29bf4bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a87e054ace4f07d5c99ead4fb29bf4bd3">swap_internal</a> (<a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;formula, bool ket)</td></tr>
<tr class="separator:a87e054ace4f07d5c99ead4fb29bf4bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5fc725c7706367cb431f4b986292b7" id="r_a5d5fc725c7706367cb431f4b986292b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a5d5fc725c7706367cb431f4b986292b7">swap_external</a> (<a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;formula, bool particle1)</td></tr>
<tr class="separator:a5d5fc725c7706367cb431f4b986292b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75979fba7209a69eafa2ec36822fe836" id="r_a75979fba7209a69eafa2ec36822fe836"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmpqc_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a75979fba7209a69eafa2ec36822fe836">permutations_chemical</a> (const <a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;formula)</td></tr>
<tr class="memdesc:a75979fba7209a69eafa2ec36822fe836"><td class="mdescLeft">&#160;</td><td class="mdescRight">return unique permutation of ( p q | r s )  <br /></td></tr>
<tr class="separator:a75979fba7209a69eafa2ec36822fe836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5986817468940eb76f1fa45c07cc7e" id="r_adb5986817468940eb76f1fa45c07cc7e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmpqc_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#adb5986817468940eb76f1fa45c07cc7e">permutations_physical</a> (const <a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;formula)</td></tr>
<tr class="memdesc:adb5986817468940eb76f1fa45c07cc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return unique permutation of &lt; p q | r s &gt;  <br /></td></tr>
<tr class="separator:adb5986817468940eb76f1fa45c07cc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aabf902df74a710f0ed8f333b8115d0" id="r_a2aabf902df74a710f0ed8f333b8115d0"><td class="memItemLeft" align="right" valign="top">sequant::ExprPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a2aabf902df74a710f0ed8f333b8115d0">R12</a> (sequant::IndexSpace gg_space, int ansatz=2)</td></tr>
<tr class="memdesc:a2aabf902df74a710f0ed8f333b8115d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct the R12 tensor from user provided index labels  <br /></td></tr>
<tr class="separator:a2aabf902df74a710f0ed8f333b8115d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee7701dd1c754059fc3dab63d38e7c5" id="r_adee7701dd1c754059fc3dab63d38e7c5"><td class="memItemLeft" align="right" valign="top">sequant::ExprPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#adee7701dd1c754059fc3dab63d38e7c5">R12</a> (std::vector&lt; std::wstring &gt; idx_labels)</td></tr>
<tr class="memdesc:adee7701dd1c754059fc3dab63d38e7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct the R12 tensor from user provided index labels  <br /></td></tr>
<tr class="separator:adee7701dd1c754059fc3dab63d38e7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242de9c69827e2e732bc25e563a4b270" id="r_a242de9c69827e2e732bc25e563a4b270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a242de9c69827e2e732bc25e563a4b270">load_mpqc_sequant_f12_context</a> (sequant::Vacuum vac=sequant::Vacuum::Physical, sequant::SPBasis so=sequant::SPBasis::Spinfree)</td></tr>
<tr class="separator:a242de9c69827e2e732bc25e563a4b270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ac002ce64c3c5a8196e56d565e0758" id="r_a79ac002ce64c3c5a8196e56d565e0758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a79ac002ce64c3c5a8196e56d565e0758">perturbation_to_operator</a> (const <a class="el" href="namespacempqc.html#aceeed0fa428e0f70432297f7e666e579">Perturbation</a> &amp;pert)</td></tr>
<tr class="memdesc:a79ac002ce64c3c5a8196e56d565e0758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert Perturbation to <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>.  <br /></td></tr>
<tr class="separator:a79ac002ce64c3c5a8196e56d565e0758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3883f2c09c111645efb85052bf4bbbc" id="r_ac3883f2c09c111645efb85052bf4bbbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ac3883f2c09c111645efb85052bf4bbbc">sort_eigen</a> (<a class="el" href="namespacempqc.html#a2a006db6d672400f7675eed7269d507e">VectorZ</a> &amp;eigVal, <a class="el" href="namespacempqc.html#af9344a05e92aca2a7a446037c6c1b4e5">MatrixZ</a> &amp;eigVec)</td></tr>
<tr class="memdesc:ac3883f2c09c111645efb85052bf4bbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sorts eigenvalues and eigenvectors in ascending order of the real parts of eigenvalues.  <br /></td></tr>
<tr class="separator:ac3883f2c09c111645efb85052bf4bbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c08c398c5fd2db920f4751fb34897b" id="r_a49c08c398c5fd2db920f4751fb34897b"><td class="memTemplParams" colspan="2">template&lt;typename _Scalar , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:a49c08c398c5fd2db920f4751fb34897b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a49c08c398c5fd2db920f4751fb34897b">format_commainit</a> (const Eigen::Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;matrix, int precision=-1, bool align_cols=true)</td></tr>
<tr class="separator:a49c08c398c5fd2db920f4751fb34897b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ac529b85a957dad9586ec54819856f" id="r_a71ac529b85a957dad9586ec54819856f"><td class="memTemplParams" colspan="2">template&lt;typename _Scalar , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:a71ac529b85a957dad9586ec54819856f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a71ac529b85a957dad9586ec54819856f">write_commainit</a> (std::ostream &amp;os, const Eigen::Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;matrix, const std::string name=&quot;matrix&quot;, int precision=-1, bool align_cols=true)</td></tr>
<tr class="separator:a71ac529b85a957dad9586ec54819856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b76a6a0462f5b85f61113a2c49f8e05" id="r_a5b76a6a0462f5b85f61113a2c49f8e05"><td class="memTemplParams" colspan="2">template&lt;typename _Scalar , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </td></tr>
<tr class="memitem:a5b76a6a0462f5b85f61113a2c49f8e05"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a5b76a6a0462f5b85f61113a2c49f8e05">format_cpp</a> (const Eigen::Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;matrix)</td></tr>
<tr class="separator:a5b76a6a0462f5b85f61113a2c49f8e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8139e87c9b49f334f2264c4985c330a" id="r_ab8139e87c9b49f334f2264c4985c330a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ab8139e87c9b49f334f2264c4985c330a">average_blocksize</a> (TA::TiledRange1 tr1)</td></tr>
<tr class="separator:ab8139e87c9b49f334f2264c4985c330a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71628bee0b913ee75d3c7e4e39097f7" id="r_ad71628bee0b913ee75d3c7e4e39097f7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ad71628bee0b913ee75d3c7e4e39097f7">minmax_blocksize</a> (TiledArray::TiledRange1 tr1)</td></tr>
<tr class="separator:ad71628bee0b913ee75d3c7e4e39097f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1fe0c0a0e3e74432ceed7c1fc63d4c" id="r_a9e1fe0c0a0e3e74432ceed7c1fc63d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a9e1fe0c0a0e3e74432ceed7c1fc63d4c">print_range_info</a> (const TA::TiledRange1 &amp;bs_range, const std::string &amp;name, std::ostream &amp;os)</td></tr>
<tr class="separator:a9e1fe0c0a0e3e74432ceed7c1fc63d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bac083ed388489ce58103b0378bae83" id="r_a9bac083ed388489ce58103b0378bae83"><td class="memTemplParams" colspan="2">template&lt;typename Tile , std::enable_if_t&lt; TA::detail::is_contiguous_tensor_v&lt; Tile &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9bac083ed388489ce58103b0378bae83"><td class="memTemplItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a9bac083ed388489ce58103b0378bae83">tile_clr_storage</a> (Tile const &amp;)</td></tr>
<tr class="separator:a9bac083ed388489ce58103b0378bae83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5abe0606a76fc87e0d4f42b2de28111" id="r_ac5abe0606a76fc87e0d4f42b2de28111"><td class="memTemplParams" colspan="2">template&lt;typename TileType , typename Policy &gt; </td></tr>
<tr class="memitem:ac5abe0606a76fc87e0d4f42b2de28111"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ac5abe0606a76fc87e0d4f42b2de28111">array_storage</a> (TA::DistArrayVector&lt; TileType, Policy &gt; const &amp;A)</td></tr>
<tr class="separator:ac5abe0606a76fc87e0d4f42b2de28111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b26a9c843edbf48e951434cc8fbe1a4" id="r_a8b26a9c843edbf48e951434cc8fbe1a4"><td class="memTemplParams" colspan="2">template&lt;typename TileType , typename Policy &gt; </td></tr>
<tr class="memitem:a8b26a9c843edbf48e951434cc8fbe1a4"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a8b26a9c843edbf48e951434cc8fbe1a4">array_storage</a> (TA::DistArray&lt; TileType, Policy &gt; const &amp;A)</td></tr>
<tr class="separator:a8b26a9c843edbf48e951434cc8fbe1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8773baa2e7468196e19760e37f7c2a86" id="r_a8773baa2e7468196e19760e37f7c2a86"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename  = typename std::enable_if&lt;              TA::detail::is_numeric&lt;typename Tile::value_type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8773baa2e7468196e19760e37f7c2a86"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a8773baa2e7468196e19760e37f7c2a86">array_rank_sizes</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A)</td></tr>
<tr class="memdesc:a8773baa2e7468196e19760e37f7c2a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">reports array size (in bytes) on each process  <br /></td></tr>
<tr class="separator:a8773baa2e7468196e19760e37f7c2a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cc4ccc310ca49d82e33906efacb0de" id="r_a75cc4ccc310ca49d82e33906efacb0de"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a75cc4ccc310ca49d82e33906efacb0de"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a75cc4ccc310ca49d82e33906efacb0de">array_size</a> (const TA::DistArray&lt; Tile, Policy &gt; &amp;A)</td></tr>
<tr class="memdesc:a75cc4ccc310ca49d82e33906efacb0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">reports the total size of an array's tiles (in gigabytes)  <br /></td></tr>
<tr class="separator:a75cc4ccc310ca49d82e33906efacb0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f0587de69dba63c6ea424e093f1cfe" id="r_a34f0587de69dba63c6ea424e093f1cfe"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a34f0587de69dba63c6ea424e093f1cfe"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a34f0587de69dba63c6ea424e093f1cfe">array_size</a> (const std::vector&lt; TA::DistArray&lt; Tile, Policy &gt; &gt; &amp;As)</td></tr>
<tr class="memdesc:a34f0587de69dba63c6ea424e093f1cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">reports the total size of an array set's tiles (in gigabytes)  <br /></td></tr>
<tr class="separator:a34f0587de69dba63c6ea424e093f1cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f6f321a380fe29b086fc0dbc0abdf7" id="r_a11f6f321a380fe29b086fc0dbc0abdf7"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a11f6f321a380fe29b086fc0dbc0abdf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a11f6f321a380fe29b086fc0dbc0abdf7">print_size_info</a> (Array const &amp;A, std::string const &amp;name)</td></tr>
<tr class="separator:a11f6f321a380fe29b086fc0dbc0abdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f875ccde00432e550b8b1067b92c97d" id="r_a8f875ccde00432e550b8b1067b92c97d"><td class="memTemplParams" colspan="2">template&lt;typename T , int Row&gt; </td></tr>
<tr class="memitem:a8f875ccde00432e550b8b1067b92c97d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a8f875ccde00432e550b8b1067b92c97d">write_eigen_mat_to_csv</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Row &gt; const &amp;mat, std::string const &amp;file_name)</td></tr>
<tr class="separator:a8f875ccde00432e550b8b1067b92c97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc1992c47c80dcfadc430deb2b27491" id="r_a7fc1992c47c80dcfadc430deb2b27491"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a7fc1992c47c80dcfadc430deb2b27491"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a7fc1992c47c80dcfadc430deb2b27491">write_array_to_csv</a> (Array const &amp;A, std::string const &amp;file_name)</td></tr>
<tr class="memdesc:a7fc1992c47c80dcfadc430deb2b27491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a DistArray in a matricized form to a csv file.  <br /></td></tr>
<tr class="separator:a7fc1992c47c80dcfadc430deb2b27491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978c55f50c53d833743a224030f1f468" id="r_a978c55f50c53d833743a224030f1f468"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a978c55f50c53d833743a224030f1f468"><td class="memTemplItemLeft" align="right" valign="top">TA::TiledRange&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a978c55f50c53d833743a224030f1f468">fuse_tranges</a> (const std::vector&lt; TA::DistArray&lt; Tile, Policy &gt; &gt; &amp;arrays)</td></tr>
<tr class="separator:a978c55f50c53d833743a224030f1f468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d73b807a94ca0129bff0a36f412e90" id="r_a45d73b807a94ca0129bff0a36f412e90"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a45d73b807a94ca0129bff0a36f412e90"><td class="memTemplItemLeft" align="right" valign="top">TA::DenseShape&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a45d73b807a94ca0129bff0a36f412e90">fuse_shapes</a> (const std::vector&lt; TA::DistArray&lt; Tile, TA::DensePolicy &gt; &gt; &amp;arrays, const TA::TiledRange &amp;trange)</td></tr>
<tr class="separator:a45d73b807a94ca0129bff0a36f412e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6b0ff34815c047f676d8df7f4efcd4" id="r_a0f6b0ff34815c047f676d8df7f4efcd4"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a0f6b0ff34815c047f676d8df7f4efcd4"><td class="memTemplItemLeft" align="right" valign="top">TA::SparseShape&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a0f6b0ff34815c047f676d8df7f4efcd4">fuse_shapes</a> (const std::vector&lt; TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &gt; &amp;arrays, const TA::TiledRange &amp;trange)</td></tr>
<tr class="separator:a0f6b0ff34815c047f676d8df7f4efcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe27b6b6a08feefac0a5827a22a9bd3" id="r_a3fe27b6b6a08feefac0a5827a22a9bd3"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a3fe27b6b6a08feefac0a5827a22a9bd3"><td class="memTemplItemLeft" align="right" valign="top">TA::DenseShape&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a3fe27b6b6a08feefac0a5827a22a9bd3">split_fused_shape</a> (const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;fused_array, const std::size_t i, const TA::TiledRange &amp;split_trange)</td></tr>
<tr class="separator:a3fe27b6b6a08feefac0a5827a22a9bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e340d54be86458784adea74634e41" id="r_af02e340d54be86458784adea74634e41"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:af02e340d54be86458784adea74634e41"><td class="memTemplItemLeft" align="right" valign="top">TA::SparseShape&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#af02e340d54be86458784adea74634e41">split_fused_shape</a> (const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;fused_array, const std::size_t i, const TA::TiledRange &amp;split_trange)</td></tr>
<tr class="separator:af02e340d54be86458784adea74634e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7447408350c17f68cb7096736a8453a8" id="r_a7447408350c17f68cb7096736a8453a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7447408350c17f68cb7096736a8453a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a7447408350c17f68cb7096736a8453a8">write_tensor_to_csv</a> (TiledArray::Tensor&lt; T &gt; const &amp;t, std::ofstream &amp;file, typename TiledArray::Tensor&lt; T &gt;::scalar_type threshold=std::numeric_limits&lt; typename TiledArray::Tensor&lt; T &gt;::scalar_type &gt;::epsilon(), const TiledArray::Permutation &amp;perm={})</td></tr>
<tr class="separator:a7447408350c17f68cb7096736a8453a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2840d97eba1328cb88ec53e2ea0d2bc8" id="r_a2840d97eba1328cb88ec53e2ea0d2bc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a2840d97eba1328cb88ec53e2ea0d2bc8">write_array_to_csv</a> (TiledArray::DistArray&lt; TiledArray::Tensor&lt; double &gt;, TiledArray::SparsePolicy &gt; const &amp;A, std::string const &amp;output_file_name)</td></tr>
<tr class="separator:a2840d97eba1328cb88ec53e2ea0d2bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb572c6982a363e4bbace31c1b449eb4" id="r_acb572c6982a363e4bbace31c1b449eb4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:acb572c6982a363e4bbace31c1b449eb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#acb572c6982a363e4bbace31c1b449eb4">write_shape_to_csv</a> (TiledArray::DistArrayVector&lt; T, P &gt; const &amp;A, std::string const &amp;output_file_name, const TiledArray::Permutation &amp;perm={})</td></tr>
<tr class="separator:acb572c6982a363e4bbace31c1b449eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc734519e7b066060466ff65617b156" id="r_afbc734519e7b066060466ff65617b156"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:afbc734519e7b066060466ff65617b156"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#afbc734519e7b066060466ff65617b156">write_shape_to_csv</a> (TiledArray::DistArray&lt; T, P &gt; const &amp;A, std::string const &amp;output_file_name, const TiledArray::Permutation &amp;perm={})</td></tr>
<tr class="separator:afbc734519e7b066060466ff65617b156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1868259504e52934dceed075f312f04a" id="r_a1868259504e52934dceed075f312f04a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename V &gt; </td></tr>
<tr class="memitem:a1868259504e52934dceed075f312f04a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a1868259504e52934dceed075f312f04a">emplace_at</a> (Iterator <a class="el" href="group___chemistry_e_s_spin_util.html#ga4339b210918c3dc6ce1cd41792807803">begin</a>, std::size_t pos, V &amp;&amp;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">value</a>)</td></tr>
<tr class="separator:a1868259504e52934dceed075f312f04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a13a3181844a84b4f358c5563be827" id="r_a56a13a3181844a84b4f358c5563be827"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a56a13a3181844a84b4f358c5563be827"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a56a13a3181844a84b4f358c5563be827">emplace_at</a> (TA::container::svector&lt; std::pair&lt; std::size_t, T &gt; &gt; &amp;vector, std::size_t pos, V &amp;&amp;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">value</a>)</td></tr>
<tr class="separator:a56a13a3181844a84b4f358c5563be827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac066bf4af0cafefca98df5e4395df927" id="r_ac066bf4af0cafefca98df5e4395df927"><td class="memTemplParams" colspan="2">template&lt;std::size_t R&gt; </td></tr>
<tr class="memitem:ac066bf4af0cafefca98df5e4395df927"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; char, R+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ac066bf4af0cafefca98df5e4395df927">make_opstr</a> (const char S)</td></tr>
<tr class="separator:ac066bf4af0cafefca98df5e4395df927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6610fccd67ed0d1cdfc8753ed5152182" id="r_a6610fccd67ed0d1cdfc8753ed5152182"><td class="memTemplParams" colspan="2">template&lt;std::size_t Nc, std::size_t Na, std::size_t Nc_from_a = 0, typename String , bool Lower&gt; </td></tr>
<tr class="memitem:a6610fccd67ed0d1cdfc8753ed5152182"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a6610fccd67ed0d1cdfc8753ed5152182">make_str_parrepl_list_impl_partial</a> (const String &amp;str, const <a class="el" href="classmpqc_1_1_fermion_string_sparse_set.html">FermionStringSparseSet</a>&lt; String &gt; &amp;sset_dst, <a class="el" href="structmpqc_1_1_string_multi_replacements.html">StringMultiReplacements</a>&lt; String, Nc, Na, Lower &gt; &amp;result)</td></tr>
<tr class="separator:a6610fccd67ed0d1cdfc8753ed5152182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85044b9247e46c7c88c051d88bf2144" id="r_af85044b9247e46c7c88c051d88bf2144"><td class="memTemplParams" colspan="2">template&lt;std::size_t Nc, std::size_t Na, std::size_t Nc_from_a, typename String , bool Lower&gt; </td></tr>
<tr class="memitem:af85044b9247e46c7c88c051d88bf2144"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#af85044b9247e46c7c88c051d88bf2144">make_str_parrepl_list_impl_partial_invoke</a> (const String &amp;str, const <a class="el" href="classmpqc_1_1_fermion_string_sparse_set.html">FermionStringSparseSet</a>&lt; String &gt; &amp;sset_dst, <a class="el" href="structmpqc_1_1_string_multi_replacements.html">StringMultiReplacements</a>&lt; String, Nc, Na, Lower &gt; &amp;result)</td></tr>
<tr class="separator:af85044b9247e46c7c88c051d88bf2144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d45854c4e67ef035fe2812b4b798168" id="r_a8d45854c4e67ef035fe2812b4b798168"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; char[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a8d45854c4e67ef035fe2812b4b798168">clone</a> (const char *str) noexcept</td></tr>
<tr class="separator:a8d45854c4e67ef035fe2812b4b798168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebc36c7d4519f5be94b5bd5a3e1c25a" id="r_abebc36c7d4519f5be94b5bd5a3e1c25a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; char[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#abebc36c7d4519f5be94b5bd5a3e1c25a">clone</a> (const std::unique_ptr&lt; char[]&gt; &amp;str)</td></tr>
<tr class="separator:abebc36c7d4519f5be94b5bd5a3e1c25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff171d413a794ce3feb7e31a0062c74" id="r_a8ff171d413a794ce3feb7e31a0062c74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ff171d413a794ce3feb7e31a0062c74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a8ff171d413a794ce3feb7e31a0062c74">hash_combine</a> (std::size_t &amp;seed, const T &amp;<a class="el" href="namespacempqc.html#aa172e42fca83352732eed5b638320a9c">value</a>)</td></tr>
<tr class="separator:a8ff171d413a794ce3feb7e31a0062c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac81034533113d3f8e99a13e1a72cb5" id="r_a9ac81034533113d3f8e99a13e1a72cb5"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:a9ac81034533113d3f8e99a13e1a72cb5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a9ac81034533113d3f8e99a13e1a72cb5">hash_range</a> (It <a class="el" href="namespacempqc.html#a572c63d97f13a82cbec00eb2c761e22ca8b04d5e3775d298e78455efc5ca404d5">first</a>, It last)</td></tr>
<tr class="separator:a9ac81034533113d3f8e99a13e1a72cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad040525db735a262d5323707cf45d864" id="r_ad040525db735a262d5323707cf45d864"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#ad040525db735a262d5323707cf45d864">dump</a> (const <a class="el" href="classmpqc_1_1_key_val.html">KeyVal</a> &amp;kv)</td></tr>
<tr class="memdesc:ad040525db735a262d5323707cf45d864"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a string representation of a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object useful for debugging  <br /></td></tr>
<tr class="separator:ad040525db735a262d5323707cf45d864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51380990296da4faabd1080a6ae27230" id="r_a51380990296da4faabd1080a6ae27230"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51380990296da4faabd1080a6ae27230"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a51380990296da4faabd1080a6ae27230">guid</a> ()</td></tr>
<tr class="separator:a51380990296da4faabd1080a6ae27230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d2072c6debc7bc7d91f14bfb498b21" id="r_ga69d2072c6debc7bc7d91f14bfb498b21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga69d2072c6debc7bc7d91f14bfb498b21"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___util_misc_property_provider.html#ga69d2072c6debc7bc7d91f14bfb498b21">description</a> (T *obj_ptr)</td></tr>
<tr class="memdesc:ga69d2072c6debc7bc7d91f14bfb498b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a description of the object pointer to by <code>obj_ptr</code>  <br /></td></tr>
<tr class="separator:ga69d2072c6debc7bc7d91f14bfb498b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga9cd6c18c34234bdacc76ebe64c735bd8" id="r_ga9cd6c18c34234bdacc76ebe64c735bd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9cd6c18c34234bdacc76ebe64c735bd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmpqc_1_1_property_provider.html">PropertyProvider</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___util_misc_property_provider.html#ga9cd6c18c34234bdacc76ebe64c735bd8">provider_cast</a> (T *obj)</td></tr>
<tr class="separator:ga9cd6c18c34234bdacc76ebe64c735bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03d65275b39148068ce4e6deaa8e441" id="r_gae03d65275b39148068ce4e6deaa8e441"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae03d65275b39148068ce4e6deaa8e441"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmpqc_1_1_property_provider.html">PropertyProvider</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___util_misc_property_provider.html#gae03d65275b39148068ce4e6deaa8e441">provider_cast</a> (T &amp;obj)</td></tr>
<tr class="separator:gae03d65275b39148068ce4e6deaa8e441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ecb4ffad027e636effc8f092c44b1d" id="r_ga98ecb4ffad027e636effc8f092c44b1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga98ecb4ffad027e636effc8f092c44b1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmpqc_1_1_property_provider.html">PropertyProvider</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___util_misc_property_provider.html#ga98ecb4ffad027e636effc8f092c44b1d">provider_cast</a> (std::shared_ptr&lt; T &gt; &amp;obj)</td></tr>
<tr class="separator:ga98ecb4ffad027e636effc8f092c44b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga086454bbed95b599d635f4ca191d02d6" id="r_ga086454bbed95b599d635f4ca191d02d6"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classmpqc_1_1_property.html">Property</a> , typename T &gt; </td></tr>
<tr class="memitem:ga086454bbed95b599d635f4ca191d02d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___util_misc_property_provider.html#ga086454bbed95b599d635f4ca191d02d6">provider_cast</a> (T &amp;&amp;obj)</td></tr>
<tr class="separator:ga086454bbed95b599d635f4ca191d02d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa49f1f066e5280efdd73c00663b9ca37" id="r_aa49f1f066e5280efdd73c00663b9ca37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa49f1f066e5280efdd73c00663b9ca37"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#aa49f1f066e5280efdd73c00663b9ca37">is_direct_array_v</a> = false</td></tr>
<tr class="separator:aa49f1f066e5280efdd73c00663b9ca37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a95041f38583afabbbad89668af7e1" id="r_a12a95041f38583afabbbad89668af7e1"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Builder &gt; </td></tr>
<tr class="memitem:a12a95041f38583afabbbad89668af7e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a12a95041f38583afabbbad89668af7e1">is_direct_array_v&lt; DirectArray&lt; Tile, Policy, Builder &gt; &gt;</a> = true</td></tr>
<tr class="separator:a12a95041f38583afabbbad89668af7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d099890731f1c043773c2a39c395443" id="r_a9d099890731f1c043773c2a39c395443"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a9d099890731f1c043773c2a39c395443">keep_H_computation_statistics</a> = false</td></tr>
<tr class="separator:a9d099890731f1c043773c2a39c395443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c84a6aba0f1435a23713da5cf07f705" id="r_a5c84a6aba0f1435a23713da5cf07f705"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a5c84a6aba0f1435a23713da5cf07f705">num_generated_replacements</a> = 0</td></tr>
<tr class="separator:a5c84a6aba0f1435a23713da5cf07f705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2423653b05c234c2ed35f008587a93ae" id="r_a2423653b05c234c2ed35f008587a93ae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a2423653b05c234c2ed35f008587a93ae">num_used_replacements</a> = 0</td></tr>
<tr class="separator:a2423653b05c234c2ed35f008587a93ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712dbaabd89c8dbff860d47ff3c1185a" id="r_a712dbaabd89c8dbff860d47ff3c1185a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#a712dbaabd89c8dbff860d47ff3c1185a">always_true</a> = [](const auto&amp; any) { return true; }</td></tr>
<tr class="separator:a712dbaabd89c8dbff860d47ff3c1185a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeebe93da89c3cb86c3a248f1714aa8" id="r_abfeebe93da89c3cb86c3a248f1714aa8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempqc_1_1detail.html#abfeebe93da89c3cb86c3a248f1714aa8">no_op</a> = [](const auto&amp;... any) {}</td></tr>
<tr class="separator:abfeebe93da89c3cb86c3a248f1714aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0ea13c010f2296c08621dfe18a417590" name="a0ea13c010f2296c08621dfe18a417590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea13c010f2296c08621dfe18a417590">&#9670;&#160;</a></span>MatrixI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1detail.html#a0ea13c010f2296c08621dfe18a417590">mpqc::detail::MatrixI</a> = typedef Eigen::Matrix&lt;int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e9f8a0e2f3fe0a37075e57a90787235" name="a4e9f8a0e2f3fe0a37075e57a90787235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9f8a0e2f3fe0a37075e57a90787235">&#9670;&#160;</a></span>scalar_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacempqc_1_1detail.html#a4e9f8a0e2f3fe0a37075e57a90787235">mpqc::detail::scalar_t</a> = typedef typename <a class="el" href="structmpqc_1_1detail_1_1scalar__type.html">scalar_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8773baa2e7468196e19760e37f7c2a86" name="a8773baa2e7468196e19760e37f7c2a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8773baa2e7468196e19760e37f7c2a86">&#9670;&#160;</a></span>array_rank_sizes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename  = typename std::enable_if&lt;              TA::detail::is_numeric&lt;typename Tile::value_type&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; mpqc::detail::array_rank_sizes </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reports array size (in bytes) on each process </p>
<dl class="section note"><dt>Note</dt><dd>this is a collective operation </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vector of integers, each element is the aggregate size of array's tiles on the corresponding process </dd></dl>

</div>
</div>
<a id="a34f0587de69dba63c6ea424e093f1cfe" name="a34f0587de69dba63c6ea424e093f1cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f0587de69dba63c6ea424e093f1cfe">&#9670;&#160;</a></span>array_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mpqc::detail::array_size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TA::DistArray&lt; Tile, Policy &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reports the total size of an array set's tiles (in gigabytes) </p>
<dl class="section note"><dt>Note</dt><dd>this is a collective operation </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the aggregate size of array's tiles in gigabytes </dd></dl>

</div>
</div>
<a id="a75cc4ccc310ca49d82e33906efacb0de" name="a75cc4ccc310ca49d82e33906efacb0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cc4ccc310ca49d82e33906efacb0de">&#9670;&#160;</a></span>array_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mpqc::detail::array_size </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reports the total size of an array's tiles (in gigabytes) </p>
<dl class="section note"><dt>Note</dt><dd>this is a collective operation </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the aggregate size of array's tiles in gigabytes </dd></dl>

</div>
</div>
<a id="a8b26a9c843edbf48e951434cc8fbe1a4" name="a8b26a9c843edbf48e951434cc8fbe1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b26a9c843edbf48e951434cc8fbe1a4">&#9670;&#160;</a></span>array_storage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TileType , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; mpqc::detail::array_storage </td>
          <td>(</td>
          <td class="paramtype">TA::DistArray&lt; TileType, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5abe0606a76fc87e0d4f42b2de28111" name="ac5abe0606a76fc87e0d4f42b2de28111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5abe0606a76fc87e0d4f42b2de28111">&#9670;&#160;</a></span>array_storage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TileType , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; mpqc::detail::array_storage </td>
          <td>(</td>
          <td class="paramtype">TA::DistArrayVector&lt; TileType, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8139e87c9b49f334f2264c4985c330a" name="ab8139e87c9b49f334f2264c4985c330a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8139e87c9b49f334f2264c4985c330a">&#9670;&#160;</a></span>average_blocksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mpqc::detail::average_blocksize </td>
          <td>(</td>
          <td class="paramtype">TA::TiledRange1&#160;</td>
          <td class="paramname"><em>tr1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d45854c4e67ef035fe2812b4b798168" name="a8d45854c4e67ef035fe2812b4b798168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d45854c4e67ef035fe2812b4b798168">&#9670;&#160;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; char[]&gt; mpqc::detail::clone </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abebc36c7d4519f5be94b5bd5a3e1c25a" name="abebc36c7d4519f5be94b5bd5a3e1c25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebc36c7d4519f5be94b5bd5a3e1c25a">&#9670;&#160;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; char[]&gt; mpqc::detail::clone </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; char[]&gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ffe47dbffa7af0e555570defb8f7b80" name="a4ffe47dbffa7af0e555570defb8f7b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffe47dbffa7af0e555570defb8f7b80">&#9670;&#160;</a></span>direct_3D_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> mpqc::detail::direct_3D_idx </td>
          <td>(</td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>ord_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>lattice_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes the ordinal index of a direct lattice and returns the corresponding 3D index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ord_idx</td><td>the ordinal index in direct space </td></tr>
    <tr><td class="paramname">lattice_max</td><td>the range of included lattices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3D index in direct space </dd></dl>

</div>
</div>
<a id="ab8988b69b3ae503d02a9917a2e02de9d" name="ab8988b69b3ae503d02a9917a2e02de9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8988b69b3ae503d02a9917a2e02de9d">&#9670;&#160;</a></span>direct_ord_idx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::detail::direct_ord_idx </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>lattice_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes the 3D index of a direct lattice and returns the corresponding ordinal index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the direct lattice index on x axis </td></tr>
    <tr><td class="paramname">y</td><td>the direct lattice index on y axis </td></tr>
    <tr><td class="paramname">z</td><td>the direct lattice index on z axis </td></tr>
    <tr><td class="paramname">lattice_max</td><td>the range of included lattices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ordinal index in direct space </dd></dl>

</div>
</div>
<a id="a1fba0711c99df332fe1f9337cccb0bdf" name="a1fba0711c99df332fe1f9337cccb0bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fba0711c99df332fe1f9337cccb0bdf">&#9670;&#160;</a></span>direct_ord_idx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::detail::direct_ord_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>in_3D_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>lattice_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes the 3D index of a direct lattice and returns the corresponding ordinal index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_3D_idx</td><td>input 3D index </td></tr>
    <tr><td class="paramname">lattice_max</td><td>the range of included lattices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ordinal index in direct space </dd></dl>

</div>
</div>
<a id="ad040525db735a262d5323707cf45d864" name="ad040525db735a262d5323707cf45d864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad040525db735a262d5323707cf45d864">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mpqc::detail::dump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_key_val.html">KeyVal</a> &amp;&#160;</td>
          <td class="paramname"><em>kv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a string representation of a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object useful for debugging </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kv</td><td>a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::string containing the string representation of the current kv </dd></dl>

</div>
</div>
<a id="aef672ed271ecfc7633770a6b1fb19671" name="aef672ed271ecfc7633770a6b1fb19671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef672ed271ecfc7633770a6b1fb19671">&#9670;&#160;</a></span>element_to_Z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::detail::element_to_Z </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1868259504e52934dceed075f312f04a" name="a1868259504e52934dceed075f312f04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1868259504e52934dceed075f312f04a">&#9670;&#160;</a></span>emplace_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::emplace_at </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56a13a3181844a84b4f358c5563be827" name="a56a13a3181844a84b4f358c5563be827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a13a3181844a84b4f358c5563be827">&#9670;&#160;</a></span>emplace_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::emplace_at </td>
          <td>(</td>
          <td class="paramtype">TA::container::svector&lt; std::pair&lt; std::size_t, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49c08c398c5fd2db920f4751fb34897b" name="a49c08c398c5fd2db920f4751fb34897b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c08c398c5fd2db920f4751fb34897b">&#9670;&#160;</a></span>format_commainit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Scalar , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::detail::format_commainit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_cols</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an Eigen::IOFormat object for printing Eigen matrices in format understood by comma initialization operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>an Eigen::Matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>number of digits to print; default (-1) is to use full precision </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align_cols</td><td>a flag that controls whether columns are aligned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an Eigen::IOFormat object; to use a format object <code>fmt</code> to print matrix <code>M</code> do <div class="fragment"><div class="line">std::cout &lt;&lt; M.format(fmt) &lt;&lt; std::endl; </div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacempqc_1_1detail.html#a71ac529b85a957dad9586ec54819856f">mpqc::detail::write_commainit</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Eigen::IOFormat is described at <a href="https://eigen.tuxfamily.org/dox/structEigen_1_1IOFormat.html">https://eigen.tuxfamily.org/dox/structEigen_1_1IOFormat.html</a> </dd>
<dd>
comma initialization is described at <a href="https://eigen.tuxfamily.org/dox/group__TutorialAdvancedInitialization.html">https://eigen.tuxfamily.org/dox/group__TutorialAdvancedInitialization.html</a> </dd></dl>

</div>
</div>
<a id="a5b76a6a0462f5b85f61113a2c49f8e05" name="a5b76a6a0462f5b85f61113a2c49f8e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b76a6a0462f5b85f61113a2c49f8e05">&#9670;&#160;</a></span>format_cpp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Scalar , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mpqc::detail::format_cpp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an Eigen::IOFormat object for printing Eigen matrices in format useful for static initialization of C++ multidimentional arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>an Eigen::Matrix object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an Eigen::IOFormat object; to use a format object <code>fmt</code> to print matrix <code>M</code> do <div class="fragment"><div class="line">std::cout &lt;&lt; M.format(fmt) &lt;&lt; std::endl; </div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Eigen::IOFormat is described at <a href="https://eigen.tuxfamily.org/dox/structEigen_1_1IOFormat.html">https://eigen.tuxfamily.org/dox/structEigen_1_1IOFormat.html</a> </dd></dl>

</div>
</div>
<a id="a45d73b807a94ca0129bff0a36f412e90" name="a45d73b807a94ca0129bff0a36f412e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d73b807a94ca0129bff0a36f412e90">&#9670;&#160;</a></span>fuse_shapes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DenseShape mpqc::detail::fuse_shapes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TA::DistArray&lt; Tile, TA::DensePolicy &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::TiledRange &amp;&#160;</td>
          <td class="paramname"><em>trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fuse the Shapes of a vector of Arrays into 1 Shape</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrays</td><td>a vector of DistArray with the same TiledRanges </td></tr>
    <tr><td class="paramname">trange</td><td>the TiledRange of fused Array object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f6b0ff34815c047f676d8df7f4efcd4" name="a0f6b0ff34815c047f676d8df7f4efcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6b0ff34815c047f676d8df7f4efcd4">&#9670;&#160;</a></span>fuse_shapes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::SparseShape&lt; float &gt; mpqc::detail::fuse_shapes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::TiledRange &amp;&#160;</td>
          <td class="paramname"><em>trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fuse the Shapes of a vector of Arrays into 1 Shape</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrays</td><td>a vector of DistArray with the same TiledRanges </td></tr>
    <tr><td class="paramname">trange</td><td>the TiledRange of fused Array object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a978c55f50c53d833743a224030f1f468" name="a978c55f50c53d833743a224030f1f468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978c55f50c53d833743a224030f1f468">&#9670;&#160;</a></span>fuse_tranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::TiledRange mpqc::detail::fuse_tranges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TA::DistArray&lt; Tile, Policy &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fuse the TRanges of a vector of Arrays into 1 Tranges the new dimension will be the leading dimension, and will be blocked by 1 all the arrays must have the same TiledRange object </p>
<p>make the new TiledRange1 for new dimension</p>
<p>make the new range for N+1 Array</p>

</div>
</div>
<a id="a51380990296da4faabd1080a6ae27230" name="a51380990296da4faabd1080a6ae27230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51380990296da4faabd1080a6ae27230">&#9670;&#160;</a></span>guid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * mpqc::detail::guid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>replaces boost serialization GUID: there is no default implementation of <a class="el" href="namespacempqc_1_1detail.html#a51380990296da4faabd1080a6ae27230">guid()</a> to avoid the issues with the primary template getting picked up due to incorrect ordering of specialization and use </p>

</div>
</div>
<a id="a8ff171d413a794ce3feb7e31a0062c74" name="a8ff171d413a794ce3feb7e31a0062c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff171d413a794ce3feb7e31a0062c74">&#9670;&#160;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>hashes <code>value</code> using std::hash and folds into the current <code>seed</code> </p><dl class="section note"><dt>Note</dt><dd>implements boost::hash_combine </dd></dl>

</div>
</div>
<a id="a9ac81034533113d3f8e99a13e1a72cb5" name="a9ac81034533113d3f8e99a13e1a72cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac81034533113d3f8e99a13e1a72cb5">&#9670;&#160;</a></span>hash_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mpqc::detail::hash_range </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>hashes range <code></code>[first,last) </p><dl class="section note"><dt>Note</dt><dd>implements boost::hash_range </dd></dl>

</div>
</div>
<a id="ac0de6584716c1d038d7d49e15e408b49" name="ac0de6584716c1d038d7d49e15e408b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0de6584716c1d038d7d49e15e408b49">&#9670;&#160;</a></span>is_in_lattice_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpqc::detail::is_in_lattice_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>in_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This determines if a unit cell is included by the give lattice range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_idx</td><td>3D index of a unit cell </td></tr>
    <tr><td class="paramname">range</td><td>lattice range </td></tr>
    <tr><td class="paramname">center</td><td>center of \range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8c857a9c5346c8ca2cecf75cda809e28" name="a8c857a9c5346c8ca2cecf75cda809e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c857a9c5346c8ca2cecf75cda809e28">&#9670;&#160;</a></span>k_3D_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> mpqc::detail::k_3D_idx </td>
          <td>(</td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>ord_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>nk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes the ordinal index of a reciprocal lattice and returns the corresponding 3D index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ord_idx</td><td>the ordinal index in reciprocal space </td></tr>
    <tr><td class="paramname">nk</td><td>number of k points in each direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 3D index in reciprocal space </dd></dl>

</div>
</div>
<a id="a2395220a181df2b8dc9c4461b3dc5b10" name="a2395220a181df2b8dc9c4461b3dc5b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2395220a181df2b8dc9c4461b3dc5b10">&#9670;&#160;</a></span>k_ord_idx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::detail::k_ord_idx </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>nk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes the 3D index of a reciprocal lattice and returns the corresponding ordinal index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the reciprocal lattice index on x' axis </td></tr>
    <tr><td class="paramname">y</td><td>the reciprocal lattice index on y' axis </td></tr>
    <tr><td class="paramname">z</td><td>the reciprocal lattice index on z' axis </td></tr>
    <tr><td class="paramname">nk</td><td>the range of included k points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ordinal index in k space </dd></dl>

</div>
</div>
<a id="afbee4ec1039edd4f6d45f31ed1b6896b" name="afbee4ec1039edd4f6d45f31ed1b6896b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbee4ec1039edd4f6d45f31ed1b6896b">&#9670;&#160;</a></span>k_ord_idx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpqc::detail::k_ord_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>in_3D_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>nk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes the 3D index of a reciprocal lattice and returns the corresponding ordinal index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_3D_idx</td><td>input 3D index </td></tr>
    <tr><td class="paramname">nk</td><td>the range of included k points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ordinal index in k space </dd></dl>

</div>
</div>
<a id="a68924c26ea0f7cdec4e471ac235a963b" name="a68924c26ea0f7cdec4e471ac235a963b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68924c26ea0f7cdec4e471ac235a963b">&#9670;&#160;</a></span>lattice_ndim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpqc::detail::lattice_ndim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> &amp;&#160;</td>
          <td class="paramname"><em>lattice_range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of periodic dimensions </dd></dl>

</div>
</div>
<a id="a7b72430d0094c9ae2ecca805e33ac8b9" name="a7b72430d0094c9ae2ecca805e33ac8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b72430d0094c9ae2ecca805e33ac8b9">&#9670;&#160;</a></span>lattice_vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> mpqc::detail::lattice_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_supercell.html#a9bccb59bc01a8d97f9c24910331c6dd6">Supercell::const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>supercell_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_unit_cell.html">UnitCell</a> &amp;&#160;</td>
          <td class="paramname"><em>unitcell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This converts a point in a supercell of a lattice and returns its coordinates in the lab frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">supercell_iterator</td><td>the iterator of a supercell that dereferences to the point whose coordinates are to be determined </td></tr>
    <tr><td class="paramname">unitcell</td><td>the unit cell of the lattice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point's coordinates in the lab frame </dd></dl>

</div>
</div>
<a id="a0cffa8cd22ea82d3547dd9d526434b5f" name="a0cffa8cd22ea82d3547dd9d526434b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cffa8cd22ea82d3547dd9d526434b5f">&#9670;&#160;</a></span>lattice_vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> mpqc::detail::lattice_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1_supercell_1_1_point.html">Supercell::Point</a> const &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_unit_cell.html">UnitCell</a> &amp;&#160;</td>
          <td class="paramname"><em>unitcell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This converts a point in a lattice and returns its coordinates in the lab frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>point in a lattice </td></tr>
    <tr><td class="paramname">unitcell</td><td>the unit cell of the lattice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point's coordinates in the lab frame </dd></dl>

</div>
</div>
<a id="a4afc3c0d861e8c5ebc7309f1ee650a8e" name="a4afc3c0d861e8c5ebc7309f1ee650a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afc3c0d861e8c5ebc7309f1ee650a8e">&#9670;&#160;</a></span>lattice_vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> mpqc::detail::lattice_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a0393d8ccb4c53e30ff8e88e1913c9dbd">Vector3i</a> const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_unit_cell.html">UnitCell</a> &amp;&#160;</td>
          <td class="paramname"><em>unitcell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This converts a point in a lattice and returns its coordinates in the lab frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>point in a lattice </td></tr>
    <tr><td class="paramname">unitcell</td><td>the unit cell of the lattice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point's coordinates in the lab frame </dd></dl>

</div>
</div>
<a id="a242de9c69827e2e732bc25e563a4b270" name="a242de9c69827e2e732bc25e563a4b270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242de9c69827e2e732bc25e563a4b270">&#9670;&#160;</a></span>load_mpqc_sequant_f12_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::load_mpqc_sequant_f12_context </td>
          <td>(</td>
          <td class="paramtype">sequant::Vacuum&#160;</td>
          <td class="paramname"><em>vac</em> = <code>sequant::Vacuum::Physical</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sequant::SPBasis&#160;</td>
          <td class="paramname"><em>so</em> = <code>sequant::SPBasis::Spinfree</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac066bf4af0cafefca98df5e4395df927" name="ac066bf4af0cafefca98df5e4395df927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac066bf4af0cafefca98df5e4395df927">&#9670;&#160;</a></span>make_opstr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; char, R+1 &gt; mpqc::detail::make_opstr </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6610fccd67ed0d1cdfc8753ed5152182" name="a6610fccd67ed0d1cdfc8753ed5152182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6610fccd67ed0d1cdfc8753ed5152182">&#9670;&#160;</a></span>make_str_parrepl_list_impl_partial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Nc, std::size_t Na, std::size_t Nc_from_a = 0, typename String , bool Lower&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::make_str_parrepl_list_impl_partial </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_fermion_string_sparse_set.html">FermionStringSparseSet</a>&lt; String &gt; &amp;&#160;</td>
          <td class="paramname"><em>sset_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1_string_multi_replacements.html">StringMultiReplacements</a>&lt; String, Nc, Na, Lower &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af85044b9247e46c7c88c051d88bf2144" name="af85044b9247e46c7c88c051d88bf2144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85044b9247e46c7c88c051d88bf2144">&#9670;&#160;</a></span>make_str_parrepl_list_impl_partial_invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Nc, std::size_t Na, std::size_t Nc_from_a, typename String , bool Lower&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::make_str_parrepl_list_impl_partial_invoke </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_fermion_string_sparse_set.html">FermionStringSparseSet</a>&lt; String &gt; &amp;&#160;</td>
          <td class="paramname"><em>sset_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpqc_1_1_string_multi_replacements.html">StringMultiReplacements</a>&lt; String, Nc, Na, Lower &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad71628bee0b913ee75d3c7e4e39097f7" name="ad71628bee0b913ee75d3c7e4e39097f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71628bee0b913ee75d3c7e4e39097f7">&#9670;&#160;</a></span>minmax_blocksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, std::size_t &gt; mpqc::detail::minmax_blocksize </td>
          <td>(</td>
          <td class="paramtype">TiledArray::TiledRange1&#160;</td>
          <td class="paramname"><em>tr1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75979fba7209a69eafa2ec36822fe836" name="a75979fba7209a69eafa2ec36822fe836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75979fba7209a69eafa2ec36822fe836">&#9670;&#160;</a></span>permutations_chemical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmpqc_1_1_formula.html">Formula</a> &gt; mpqc::detail::permutations_chemical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>formula</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return unique permutation of ( p q | r s ) </p>

</div>
</div>
<a id="adb5986817468940eb76f1fa45c07cc7e" name="adb5986817468940eb76f1fa45c07cc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5986817468940eb76f1fa45c07cc7e">&#9670;&#160;</a></span>permutations_physical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmpqc_1_1_formula.html">Formula</a> &gt; mpqc::detail::permutations_physical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>formula</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return unique permutation of &lt; p q | r s &gt; </p>

</div>
</div>
<a id="a79ac002ce64c3c5a8196e56d565e0758" name="a79ac002ce64c3c5a8196e56d565e0758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ac002ce64c3c5a8196e56d565e0758">&#9670;&#160;</a></span>perturbation_to_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> mpqc::detail::perturbation_to_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacempqc.html#aceeed0fa428e0f70432297f7e666e579">Perturbation</a> &amp;&#160;</td>
          <td class="paramname"><em>pert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to convert Perturbation to <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pert</td><td>Perturbation (eg: electric, magnetic) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>corresponding <a class="el" href="classmpqc_1_1_operator.html#a4b6bc00ce51abe96e809cf7293e2a3a6">Operator::Type</a> </dd></dl>

</div>
</div>
<a id="a9e1fe0c0a0e3e74432ceed7c1fc63d4c" name="a9e1fe0c0a0e3e74432ceed7c1fc63d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1fe0c0a0e3e74432ceed7c1fc63d4c">&#9670;&#160;</a></span>print_range_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::print_range_info </td>
          <td>(</td>
          <td class="paramtype">const TA::TiledRange1 &amp;&#160;</td>
          <td class="paramname"><em>bs_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11f6f321a380fe29b086fc0dbc0abdf7" name="a11f6f321a380fe29b086fc0dbc0abdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f6f321a380fe29b086fc0dbc0abdf7">&#9670;&#160;</a></span>print_size_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::print_size_info </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2aabf902df74a710f0ed8f333b8115d0" name="a2aabf902df74a710f0ed8f333b8115d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aabf902df74a710f0ed8f333b8115d0">&#9670;&#160;</a></span>R12() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sequant::ExprPtr mpqc::detail::R12 </td>
          <td>(</td>
          <td class="paramtype">sequant::IndexSpace&#160;</td>
          <td class="paramname"><em>gg_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ansatz</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct the R12 tensor from user provided index labels </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx_labels</td><td>a list of 4 strings corresponding to the IndexSpace blocking of the R12 tensor. ket spaces (geminal generating) spaces first then bra spaces (excitation spaces) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>no longer require ansatz specification in this function </dd></dl>

</div>
</div>
<a id="adee7701dd1c754059fc3dab63d38e7c5" name="adee7701dd1c754059fc3dab63d38e7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee7701dd1c754059fc3dab63d38e7c5">&#9670;&#160;</a></span>R12() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sequant::ExprPtr mpqc::detail::R12 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::wstring &gt;&#160;</td>
          <td class="paramname"><em>idx_labels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct the R12 tensor from user provided index labels </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx_labels</td><td>a list of 4 strings corresponding to the IndexSpace blocking of the R12 tensor. ket spaces (geminal generating) spaces first then bra spaces (excitation spaces) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>no longer require ansatz specification in this function </dd></dl>

</div>
</div>
<a id="ae25913ae2726538e61ef53f560085d05" name="ae25913ae2726538e61ef53f560085d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25913ae2726538e61ef53f560085d05">&#9670;&#160;</a></span>shift_atom_based_clusterables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ABCRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; std::remove_reference_t&lt; ABCRange &gt; &gt; mpqc::detail::shift_atom_based_clusterables </td>
          <td>(</td>
          <td class="paramtype">ABCRange &amp;&amp;&#160;</td>
          <td class="paramname"><em>range_of_atom_based_clusterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#aedd447c924ca4379fdb97151825ddd9e">Vector3d</a> const &amp;&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This shifts the position of range of atom-based clusterables. </p>
<dl class="section note"><dt>Note</dt><dd>All atom positions will be shifted </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ABCRange</td><td>the type of atom-based clusterable range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_of_atom_based_clusterables</td><td>a range of atom-based clusterables </td></tr>
    <tr><td class="paramname">shift</td><td>the shift vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to the shifted range </dd></dl>

</div>
</div>
<a id="ac3883f2c09c111645efb85052bf4bbbc" name="ac3883f2c09c111645efb85052bf4bbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3883f2c09c111645efb85052bf4bbbc">&#9670;&#160;</a></span>sort_eigen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::sort_eigen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#a2a006db6d672400f7675eed7269d507e">VectorZ</a> &amp;&#160;</td>
          <td class="paramname"><em>eigVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempqc.html#af9344a05e92aca2a7a446037c6c1b4e5">MatrixZ</a> &amp;&#160;</td>
          <td class="paramname"><em>eigVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sorts eigenvalues and eigenvectors in ascending order of the real parts of eigenvalues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">eigVal</td><td>the vector of complex eigenvalues </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">eigVec</td><td>the complex matrix consisting of complex eigenvectors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fe27b6b6a08feefac0a5827a22a9bd3" name="a3fe27b6b6a08feefac0a5827a22a9bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe27b6b6a08feefac0a5827a22a9bd3">&#9670;&#160;</a></span>split_fused_shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::DenseShape mpqc::detail::split_fused_shape </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::DensePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::TiledRange &amp;&#160;</td>
          <td class="paramname"><em>split_trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split the ith mode of a fused Array, the leading dimension of Array must blocked by 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrays</td><td>a vector of DistArray with the same TiledRanges </td></tr>
    <tr><td class="paramname">i</td><td>the number of mode to split </td></tr>
    <tr><td class="paramname">trange</td><td>the TiledRange of the split Array object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af02e340d54be86458784adea74634e41" name="af02e340d54be86458784adea74634e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e340d54be86458784adea74634e41">&#9670;&#160;</a></span>split_fused_shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TA::SparseShape&lt; float &gt; mpqc::detail::split_fused_shape </td>
          <td>(</td>
          <td class="paramtype">const TA::DistArray&lt; Tile, TA::SparsePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TA::TiledRange &amp;&#160;</td>
          <td class="paramname"><em>split_trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split the ith mode of a fused Array, the leading dimension of Array must blocked by 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrays</td><td>a vector of DistArray with the same TiledRanges </td></tr>
    <tr><td class="paramname">i</td><td>the number of mode to split </td></tr>
    <tr><td class="paramname">trange</td><td>the TiledRange of the split Array object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab61675d0cd92235983ac2cbaa1d68e9" name="aab61675d0cd92235983ac2cbaa1d68e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab61675d0cd92235983ac2cbaa1d68e9">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>formula</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swap bra with ket </p>

</div>
</div>
<a id="a5d5fc725c7706367cb431f4b986292b7" name="a5d5fc725c7706367cb431f4b986292b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5fc725c7706367cb431f4b986292b7">&#9670;&#160;</a></span>swap_external()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::swap_external </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>particle1</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>swap bra and ket indices for particle 0 or 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particle1</td><td>if true, swap particle 1 indices, else swap particle 0 indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87e054ace4f07d5c99ead4fb29bf4bd3" name="a87e054ace4f07d5c99ead4fb29bf4bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e054ace4f07d5c99ead4fb29bf4bd3">&#9670;&#160;</a></span>swap_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::swap_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpqc_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ket</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>swap indices within bra or ket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ket</td><td>if true, do intra-ket swap, else do intra-bra swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bac083ed388489ce58103b0378bae83" name="a9bac083ed388489ce58103b0378bae83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bac083ed388489ce58103b0378bae83">&#9670;&#160;</a></span>tile_clr_storage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , std::enable_if_t&lt; TA::detail::is_contiguous_tensor_v&lt; Tile &gt; &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned long mpqc::detail::tile_clr_storage </td>
          <td>(</td>
          <td class="paramtype">Tile const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fc1992c47c80dcfadc430deb2b27491" name="a7fc1992c47c80dcfadc430deb2b27491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc1992c47c80dcfadc430deb2b27491">&#9670;&#160;</a></span>write_array_to_csv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::write_array_to_csv </td>
          <td>(</td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a DistArray in a matricized form to a csv file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>a TA::DistArray type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>an Array to be written to csv; <code>A.trange()</code>.range() must be 2, 3, or 4 </td></tr>
    <tr><td class="paramname">file_name</td><td>a the name of the file to write <code>A</code> to; <code>.csv</code> is not prepended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if <code>A.trange()</code>.rank()==3 then the second and third modes are fused </dd>
<dd>
if <code>A.trange()</code>.rank()==4 then the first two and last two modes are fused </dd></dl>

</div>
</div>
<a id="a2840d97eba1328cb88ec53e2ea0d2bc8" name="a2840d97eba1328cb88ec53e2ea0d2bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2840d97eba1328cb88ec53e2ea0d2bc8">&#9670;&#160;</a></span>write_array_to_csv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::write_array_to_csv </td>
          <td>(</td>
          <td class="paramtype">TiledArray::DistArray&lt; TiledArray::Tensor&lt; double &gt;, TiledArray::SparsePolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>output_file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71ac529b85a957dad9586ec54819856f" name="a71ac529b85a957dad9586ec54819856f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ac529b85a957dad9586ec54819856f">&#9670;&#160;</a></span>write_commainit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Scalar , int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::write_commainit </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;matrix&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_cols</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes an Eigen matrix to a stream in format understood by comma initialization operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>a std::ostream object reference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>an Eigen::Matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>a string identifying this matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>number of digits to print; default (-1) is to use full precision </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align_cols</td><td>a flag that controls whether columns are aligned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>comma initialization is described at <a href="https://eigen.tuxfamily.org/dox/group__TutorialAdvancedInitialization.html">https://eigen.tuxfamily.org/dox/group__TutorialAdvancedInitialization.html</a> </dd></dl>

</div>
</div>
<a id="a8f875ccde00432e550b8b1067b92c97d" name="a8f875ccde00432e550b8b1067b92c97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f875ccde00432e550b8b1067b92c97d">&#9670;&#160;</a></span>write_eigen_mat_to_csv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Row&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::write_eigen_mat_to_csv </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Row &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbc734519e7b066060466ff65617b156" name="afbc734519e7b066060466ff65617b156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc734519e7b066060466ff65617b156">&#9670;&#160;</a></span>write_shape_to_csv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::write_shape_to_csv </td>
          <td>(</td>
          <td class="paramtype">TiledArray::DistArray&lt; T, P &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>output_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TiledArray::Permutation &amp;&#160;</td>
          <td class="paramname"><em>perm</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb572c6982a363e4bbace31c1b449eb4" name="acb572c6982a363e4bbace31c1b449eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb572c6982a363e4bbace31c1b449eb4">&#9670;&#160;</a></span>write_shape_to_csv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::write_shape_to_csv </td>
          <td>(</td>
          <td class="paramtype">TiledArray::DistArrayVector&lt; T, P &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>output_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TiledArray::Permutation &amp;&#160;</td>
          <td class="paramname"><em>perm</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7447408350c17f68cb7096736a8453a8" name="a7447408350c17f68cb7096736a8453a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7447408350c17f68cb7096736a8453a8">&#9670;&#160;</a></span>write_tensor_to_csv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mpqc::detail::write_tensor_to_csv </td>
          <td>(</td>
          <td class="paramtype">TiledArray::Tensor&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename TiledArray::Tensor&lt; T &gt;::scalar_type&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>std::numeric_limits&lt;&#160;typename&#160;TiledArray::Tensor&lt;T&gt;::scalar_type&gt;::epsilon()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TiledArray::Permutation &amp;&#160;</td>
          <td class="paramname"><em>perm</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72f968a9608405ce7b677e29f263de76" name="a72f968a9608405ce7b677e29f263de76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f968a9608405ce7b677e29f263de76">&#9670;&#160;</a></span>Z_to_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mpqc::detail::Z_to_element </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a712dbaabd89c8dbff860d47ff3c1185a" name="a712dbaabd89c8dbff860d47ff3c1185a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712dbaabd89c8dbff860d47ff3c1185a">&#9670;&#160;</a></span>always_true</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mpqc::detail::always_true = [](const auto&amp; any) { return true; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa49f1f066e5280efdd73c00663b9ca37" name="aa49f1f066e5280efdd73c00663b9ca37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49f1f066e5280efdd73c00663b9ca37">&#9670;&#160;</a></span>is_direct_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mpqc::detail::is_direct_array_v = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12a95041f38583afabbbad89668af7e1" name="a12a95041f38583afabbbad89668af7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a95041f38583afabbbad89668af7e1">&#9670;&#160;</a></span>is_direct_array_v&lt; DirectArray&lt; Tile, Policy, Builder &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Builder &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacempqc_1_1detail.html#aa49f1f066e5280efdd73c00663b9ca37">mpqc::detail::is_direct_array_v</a>&lt; <a class="el" href="classmpqc_1_1_direct_array.html">DirectArray</a>&lt; Tile, Policy, Builder &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d099890731f1c043773c2a39c395443" name="a9d099890731f1c043773c2a39c395443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d099890731f1c043773c2a39c395443">&#9670;&#160;</a></span>keep_H_computation_statistics</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mpqc::detail::keep_H_computation_statistics = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfeebe93da89c3cb86c3a248f1714aa8" name="abfeebe93da89c3cb86c3a248f1714aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfeebe93da89c3cb86c3a248f1714aa8">&#9670;&#160;</a></span>no_op</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mpqc::detail::no_op = [](const auto&amp;... any) {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c84a6aba0f1435a23713da5cf07f705" name="a5c84a6aba0f1435a23713da5cf07f705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c84a6aba0f1435a23713da5cf07f705">&#9670;&#160;</a></span>num_generated_replacements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpqc::detail::num_generated_replacements = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2423653b05c234c2ed35f008587a93ae" name="a2423653b05c234c2ed35f008587a93ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2423653b05c234c2ed35f008587a93ae">&#9670;&#160;</a></span>num_used_replacements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpqc::detail::num_used_replacements = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 13 2025 23:43:46 for MPQC-Docs by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
